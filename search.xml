<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>调用大模型 API 解决简单信息处理任务</title>
      <link href="/posts/573fc6c3/"/>
      <url>/posts/573fc6c3/</url>
      
        <content type="html"><![CDATA[<p>近年来大模型的发展推动了不同领域的范式变革，大模型强悍的理解、推理和生成能力使得其在各类任务中取得优异表现。<br>如今，随着大模型相关产业不断成熟，大模型的使用门槛也逐渐降低：不仅不具备大模型硬件本地部署条件的用户可以通过 API 获取大模型服务，且多家服务商提供了多样化的服务可供用户选择，调用 API 的成本也逐渐降低。<br>本文将以 <a href="https://bigmodel.cn/">智谱 AI 开放平台</a> 为例，简要介绍如何调用大模型 API 解决简单信息处理任务，其他平台的使用方法可类推。<br>如需具体了解智谱 AI 开放平台的详细功能，可以参考 <a href="https://bigmodel.cn/dev/howuse/">智谱 AI 开放平台开发文档</a></p><h1>开发平台准备</h1><p>进入 <a href="https://bigmodel.cn/">智谱 AI 开放平台</a>，注册账号。</p><p><img src="https://download.mariozzj.cn/img/picgo/202408261420667.png" alt="智谱 AI 网站界面"></p><p>点击右上角的用户图标，进入个人中心，点击「实名认证」选项卡完成实名认证。</p><p><img src="https://download.mariozzj.cn/img/picgo/202408261424272.png" alt="控制台界面"></p><p><img src="https://download.mariozzj.cn/img/picgo/202408261426343.png" alt="个人中心界面"></p><p><img src="https://download.mariozzj.cn/img/picgo/202408261426954.png" alt="完成注册"></p><p>随后点击右上角的「API 密钥」，创建一个 API 密钥。</p><p><img src="https://download.mariozzj.cn/img/picgo/202408261428481.png" alt="创建密钥"></p><p><img src="https://download.mariozzj.cn/img/picgo/202408261433024.png" alt="点击「添加新的 API key」"></p><p><img src="https://download.mariozzj.cn/img/picgo/202408261434888.png" alt="点击图标可复制密钥"></p><p>点击复制即可复制密钥，这是调用 API 时服务端验证的凭证。</p><h1>本地环境准备</h1><p>在本地用于调用 API 的 Python 环境中，安装 <code>zhipuai</code> 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install zhipuai</span><br></pre></td></tr></table></figure><p>安装完成后，可以参照 <a href="https://bigmodel.cn/dev/api">接口文档</a> 中的 SDK 代码示例，执行一个简单的 API 调用，测试是否能够成功调用 API。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> zhipuai <span class="keyword">import</span> ZhipuAI</span><br><span class="line">client = ZhipuAI(api_key=<span class="string">&quot;&quot;</span>) <span class="comment"># 填写您自己的APIKey</span></span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">    model=<span class="string">&quot;glm-4-0520&quot;</span>,  <span class="comment"># 填写需要调用的模型编码</span></span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;作为一名营销专家，请为我的产品创作一个吸引人的slogan&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;当然，为了创作一个吸引人的slogan，请告诉我一些关于您产品的信息&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;智谱AI开放平台&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;智启未来，谱绘无限一智谱AI，让创新触手可及!&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;创造一个更精准、吸引人的slogan&quot;</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(response.choices[<span class="number">0</span>].message)</span><br></pre></td></tr></table></figure><p>这是一个要求智谱 AI 模型为用户创作 slogan 的例子，如果调用成功，将会输出智谱 AI 为用户创作的 slogan：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletionMessage(content=&#x27;&quot;智领变革，图创未来 —— 智谱AI，智慧加速每一步&quot;&#x27;, role=&#x27;assistant&#x27;, tool_calls=None)</span><br></pre></td></tr></table></figure><p>至此，本地环境准备完成。</p><h1>信息抽取任务应用</h1><p>在线和本地环境准备完成后，我们就可以使用已有条件解决我们的实际问题了。事实上，我们在利用大模型 API 的理解与生成能力解决实际信息抽取任务中的问题时，都满足一个最基本的流程：</p><ol><li>构造有利于模型理解的输入。将待处理的<strong>数据</strong>和<strong>要求</strong>（体现为提示词 Prompt）转化为模型可理解的格式。这也是 <em>提示工程</em> 的重要一环。</li><li>调用 API。将构造好的输入传入 API，调用模型进行处理，获取模型的输出。</li><li>解析输出。将模型输出解析为我们需要的结果。为了提升解析的效率，我们可以在设计提示词时就考虑输出的格式，作为要求的一部分。</li></ol><p>下面，我们以抽取主题词为例，展示如何使用大模型 API 解决简单信息抽取任务。</p><h2 id="构造输入">构造输入</h2><p>我们构造的提示词输入是包含数据和要求的文本。设计提示词存在许多技巧，能够显著提升模型的输出效果，在这里不赘述具体技巧。我们这里直接使用智谱 AI 的 <a href="https://chatglm.cn/share/FW4o9">Prompt 优化专家</a> 为我们的任务设计提示词：</p><blockquote><p>(我的输入) 我想要模型是一个能够理解学术论文文本内容的主题词提取专家。<br>我将向模型提供若干篇学术论文的标题和摘要内容，要求模型为每篇论文按照相关性依次输出和论文研究内容较为相关的五个主题词。<br>请在设计 prompt 时提供插入论文标题摘要的位置。输出要求仅包含关键词内容。<br>请使用代码块方式向我提供 prompt。</p></blockquote><p>下面是优化专家提供的 prompt 模板：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Role: Academic Paper Theme Extractor : 专注于从学术论文标题和摘要中提取主题词</span><br><span class="line"></span><br><span class="line"><span class="section">## Goals</span></span><br><span class="line"><span class="bullet">-</span> 从提供的学术论文标题和摘要中提取五个与研究内容最相关的主题词。</span><br><span class="line"></span><br><span class="line"><span class="section">## Constrains</span></span><br><span class="line"><span class="bullet">-</span> 输出必须仅包含关键词内容。</span><br><span class="line"><span class="bullet">-</span> 输出格式必须是Markdown列表形式。</span><br><span class="line"><span class="bullet">-</span> 按照相关性依次输出主题词。</span><br><span class="line"></span><br><span class="line"><span class="section">## Skills</span></span><br><span class="line"><span class="bullet">-</span> 理解学术论文标题和摘要的能力。</span><br><span class="line"><span class="bullet">-</span> 提取关键信息的能力。</span><br><span class="line"><span class="bullet">-</span> 排序和筛选主题词的能力。</span><br><span class="line"></span><br><span class="line"><span class="section">## Output Format</span></span><br><span class="line"><span class="bullet">-</span> 以Markdown列表形式输出五个主题词。</span><br><span class="line"></span><br><span class="line"><span class="section">## Workflow</span></span><br><span class="line"><span class="bullet">1.</span> 读取并理解学术论文的标题和摘要。</span><br><span class="line"><span class="bullet">2.</span> 提取与研究内容最相关的主题词。</span><br><span class="line"><span class="bullet">3.</span> 按照相关性对主题词进行排序。</span><br><span class="line"><span class="bullet">4.</span> 以Markdown列表形式输出五个主题词。</span><br><span class="line"></span><br><span class="line"><span class="section">## Initialization</span></span><br><span class="line">你好，我是一个学术论文主题词提取专家。请提供学术论文的标题和摘要内容，我会从中提取五个与研究内容最相关的主题词，并以Markdown列表形式输出。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整理一下得到我们的 prompt：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## Goals</span></span><br><span class="line"><span class="bullet">-</span> 从提供的学术论文标题和摘要中提取五个与研究内容最相关的主题词。</span><br><span class="line"></span><br><span class="line"><span class="section">## Constrains</span></span><br><span class="line"><span class="bullet">-</span> 输出必须仅包含关键词内容。</span><br><span class="line"><span class="bullet">-</span> 输出格式必须是Markdown列表形式。</span><br><span class="line"><span class="bullet">-</span> 按照相关性依次输出主题词。</span><br><span class="line"></span><br><span class="line"><span class="section">## Skills</span></span><br><span class="line"><span class="bullet">-</span> 理解学术论文标题和摘要的能力。</span><br><span class="line"><span class="bullet">-</span> 提取关键信息的能力。</span><br><span class="line"><span class="bullet">-</span> 排序和筛选主题词的能力。</span><br><span class="line"></span><br><span class="line"><span class="section">## Output Format</span></span><br><span class="line"><span class="bullet">-</span> 以Markdown列表形式输出五个主题词。</span><br><span class="line"></span><br><span class="line"><span class="section">## Workflow</span></span><br><span class="line"><span class="bullet">1.</span> 读取并理解学术论文的标题和摘要。</span><br><span class="line"><span class="bullet">2.</span> 提取与研究内容最相关的主题词。</span><br><span class="line"><span class="bullet">3.</span> 按照相关性对主题词进行排序。</span><br><span class="line"><span class="bullet">4.</span> 以Markdown列表形式输出五个主题词。</span><br><span class="line"></span><br><span class="line"><span class="section">## 标题内容</span></span><br><span class="line">&#123;title&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">## 摘要内容</span></span><br><span class="line">&#123;abstract&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们在 prompt 中留下占位符，用于插入具体的学术论文标题和摘要。</p><h2 id="批量调用-API">批量调用 API</h2><p>实际情况中，我们会有大批量的学术论文需要处理，我们可以使用批量处理的方法调用 API，节省成本的同时提高效率。</p><p>每个论文的处理可以视为一个对 API 的请求，我们把每个请求实例化为一个 json，预先生成所有请求的 json，一次性提交给 API。</p><p>在智谱 AI 的要求中，每个请求的 json 占据一行，至多 50000 个请求组成一个 <code>.jsonl</code> 文件，单个文件最大 100MB。其他平台要求可参见其文档要求。下面，我们假设我们已经读取了论文的标题、摘要，就可以生成一个待提交的 <code>.jsonl</code> 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">content_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">## Goals</span></span><br><span class="line"><span class="string">- 从提供的学术论文标题和摘要中提取五个与研究内容最相关的主题词。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Constrains</span></span><br><span class="line"><span class="string">- 输出必须仅包含关键词内容。</span></span><br><span class="line"><span class="string">- 输出格式必须是Markdown列表形式。</span></span><br><span class="line"><span class="string">- 按照相关性依次输出主题词。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Skills</span></span><br><span class="line"><span class="string">- 理解学术论文标题和摘要的能力。</span></span><br><span class="line"><span class="string">- 提取关键信息的能力。</span></span><br><span class="line"><span class="string">- 排序和筛选主题词的能力。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Output Format</span></span><br><span class="line"><span class="string">- 以Markdown列表形式输出五个主题词。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Workflow</span></span><br><span class="line"><span class="string">1. 读取并理解学术论文的标题和摘要。</span></span><br><span class="line"><span class="string">2. 提取与研究内容最相关的主题词。</span></span><br><span class="line"><span class="string">3. 按照相关性对主题词进行排序。</span></span><br><span class="line"><span class="string">4. 以Markdown列表形式输出五个主题词。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 标题内容</span></span><br><span class="line"><span class="string">&#123;title&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 摘要内容</span></span><br><span class="line"><span class="string">&#123;abstract&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># json 模版，注意这里可以指定特定模型</span></span><br><span class="line">json_template = &#123;<span class="string">&quot;custom_id&quot;</span>: <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/v4/chat/completions&quot;</span>, <span class="string">&quot;body&quot;</span>: &#123;<span class="string">&quot;model&quot;</span>: <span class="string">&quot;glm-4&quot;</span>, <span class="string">&quot;messages&quot;</span>: [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你是一个专注于从学术论文标题和摘要中提取主题词的专家&quot;</span>&#125;,&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;xxx&quot;</span>&#125;]&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> texts_df.iterrows():</span><br><span class="line">    <span class="built_in">id</span> = row[<span class="string">&quot;id&quot;</span>]</span><br><span class="line">    title = row[<span class="string">&quot;title&quot;</span>]</span><br><span class="line">    abstract = row[<span class="string">&quot;abstract&quot;</span>]</span><br><span class="line">    <span class="comment"># 将标题、摘要填入模板</span></span><br><span class="line">    content = content_template.<span class="built_in">format</span>(title=title, abstract=abstract)</span><br><span class="line">    json_row = json_template.copy()</span><br><span class="line">    json_row[<span class="string">&quot;custom_id&quot;</span>] = <span class="built_in">id</span></span><br><span class="line">    json_row[<span class="string">&quot;body&quot;</span>][<span class="string">&quot;messages&quot;</span>][<span class="number">1</span>][<span class="string">&quot;content&quot;</span>] = content</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入文件一行</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;json_submit.jsonl&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(json_row, ensure_ascii=<span class="literal">False</span>) + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="提交任务：通过-python">提交任务：通过 python</h3><p>然后，我们可以把生成的 <code>.jsonl</code> 文件提交到文件系统：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 上传文件</span></span><br><span class="line"><span class="keyword">from</span> zhipuai <span class="keyword">import</span> ZhipuAI</span><br><span class="line"> </span><br><span class="line">client = ZhipuAI(api_key=<span class="string">&quot;&quot;</span>) <span class="comment"># 填写自己的APIKey</span></span><br><span class="line">  </span><br><span class="line">result = client.files.create(</span><br><span class="line">    file=<span class="built_in">open</span>(<span class="string">&quot;json_submit.jsonl&quot;</span>, <span class="string">&quot;rb&quot;</span>),</span><br><span class="line">    purpose=<span class="string">&quot;batch&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(result.<span class="built_in">id</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1725432608_4dc1a45595254515ba04d446f78e383c</span><br></pre></td></tr></table></figure><p>这段程序会打印一个文件 id，我们可以进一步将这个 id 提交给 API，用于创建任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 batch 任务</span></span><br><span class="line"><span class="keyword">from</span> zhipuai <span class="keyword">import</span> ZhipuAI</span><br><span class="line"> </span><br><span class="line">client = ZhipuAI(api_key=<span class="string">&quot;&quot;</span>)  <span class="comment"># 填写您自己的APIKey</span></span><br><span class="line"></span><br><span class="line">create = client.batches.create(</span><br><span class="line">    input_file_id=<span class="string">&quot;1725432608_4dc1a45595254515ba04d446f78e383c&quot;</span>, <span class="comment"># 填入文件 id</span></span><br><span class="line">    endpoint=<span class="string">&quot;/v4/chat/completions&quot;</span>, </span><br><span class="line">    completion_window=<span class="string">&quot;24h&quot;</span>, <span class="comment">#完成时间只支持 24 小时</span></span><br><span class="line">    metadata=&#123;</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;主题词抽取&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(create)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Batch(id=&#x27;batch_1831223675418845184&#x27;, completion_window=&#x27;24h&#x27;, created_at=xxxxxxxxx, endpoint=&#x27;/v4/chat/completions&#x27;, input_file_id=&#x27;1725432608_4dc1a45595254515ba04d446f78e383c&#x27;, object=&#x27;batch&#x27;, status=&#x27;validating&#x27;, cancelled_at=None, cancelling_at=None, completed_at=None, error_file_id=None, errors=None, expired_at=None, expires_at=None, failed_at=None, finalizing_at=None, in_progress_at=None, metadata=&#123;&#x27;description&#x27;: &#x27;主题词抽取&#x27;&#125;, output_file_id=None, request_counts=BatchRequestCounts(completed=None, failed=None, total=3))</span><br></pre></td></tr></table></figure><p>这段程序会打印任务 id。服务端会需要一些时间处理任务，我们可以通过任务 id 查询任务的状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">batch_job = client.batches.retrieve(<span class="string">&quot;batch_1831223675418845184&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(batch_job)</span><br><span class="line"><span class="built_in">print</span>(batch_job.output_file_id)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Batch(id=&#x27;batch_1831223675418845184&#x27;, completion_window=&#x27;24h&#x27;, created_at=0000000000000, endpoint=&#x27;/v4/chat/completions&#x27;, input_file_id=&#x27;1725432608_4dc1a45595254515ba04d446f78e383c&#x27;, object=&#x27;batch&#x27;, status=&#x27;completed&#x27;, cancelled_at=None, cancelling_at=None, completed_at=0000000000000, error_file_id=&#x27;&#x27;, errors=None, expired_at=None, expires_at=None, failed_at=None, finalizing_at=0000000000000, in_progress_at=0000000000000, metadata=&#123;&#x27;description&#x27;: &#x27;主题词抽取&#x27;&#125;, output_file_id=&#x27;1725435402_e5bcfc2d00a34ce4a0c9ea58c27b1041&#x27;, request_counts=BatchRequestCounts(completed=3, failed=0, total=3))</span><br><span class="line">1725435402_e5bcfc2d00a34ce4a0c9ea58c27b1041</span><br></pre></td></tr></table></figure><p>当任务完成后，我们可以通过 <code>output_file_id</code> 下载结果文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> zhipuai <span class="keyword">import</span> ZhipuAI</span><br><span class="line"> </span><br><span class="line">client = ZhipuAI(api_key=<span class="string">&quot;&quot;</span>)  <span class="comment"># 填写自己的APIKey</span></span><br><span class="line">content = client.files.content(<span class="string">&quot;1725435402_e5bcfc2d00a34ce4a0c9ea58c27b1041&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用write_to_file方法把返回结果写入文件</span></span><br><span class="line">content.write_to_file(<span class="string">&quot;write_to_file_batchoutput.jsonl&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="提交任务：通过控制台网页">提交任务：通过控制台网页</h3><p>我们也可以通过控制台网页提交任务。在 <a href="https://bigmodel.cn/console/batch/dataset">BigModel 控制台 - Batch 数据</a> 页面，点击「上传数据」，上传我们生成的 <code>.jsonl</code> 文件。</p><p><img src="https://download.mariozzj.cn/img/picgo/202409041546267.png" alt="上传数据"></p><p>接着，在 <a href="https://bigmodel.cn/console/batch/task">BigModel 控制台 - Batch 任务</a> 界面可以查看任务状态。</p><p><img src="https://download.mariozzj.cn/img/picgo/202409041548999.png" alt="任务状态"></p><p>如果任务已完成，则可以在状态详情页下载成功文件。</p><p><img src="https://download.mariozzj.cn/img/picgo/202409041549490.png" alt=""></p><h2 id="解析输出">解析输出</h2><p>我们可以通过解析输出文件，将模型输出的结果解析为我们需要的格式。输出文件同样是一个 <code>.jsonl</code> 文件，每行是一个请求的结果。形如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;response&quot;:&#123;&quot;status_code&quot;:200,&quot;body&quot;:&#123;&quot;created&quot;:1725435303,&quot;usage&quot;:&#123;&quot;completion_tokens&quot;:38,&quot;prompt_tokens&quot;:373,&quot;total_tokens&quot;:411&#125;,&quot;model&quot;:&quot;glm-4&quot;,&quot;id&quot;:&quot;8991732081299811096&quot;,&quot;choices&quot;:[&#123;&quot;finish_reason&quot;:&quot;stop&quot;,&quot;index&quot;:0,&quot;message&quot;:&#123;&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:&quot;- 颠覆性技术识别\n- 社会网络分析\n- 突变理论\n- 技术共现网络\n- 语义信息分析&quot;&#125;&#125;],&quot;request_id&quot;:&quot;test103&quot;&#125;&#125;,&quot;custom_id&quot;:&quot;test103&quot;,&quot;id&quot;:&quot;batch_1831223675418845184&quot;&#125;</span><br></pre></td></tr></table></figure><p>我们需要的是 <code>choices</code> 字段中的 <code>message</code> 字段中的 <code>content</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ids = []</span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;write_to_file_batchoutput.jsonl&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        response = json.loads(line)[<span class="string">&quot;response&quot;</span>][<span class="string">&quot;body&quot;</span>]</span><br><span class="line">        <span class="built_in">id</span> = response[<span class="string">&#x27;request_id&#x27;</span>]</span><br><span class="line">        content = response[<span class="string">&#x27;choices&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;message&#x27;</span>][<span class="string">&#x27;content&#x27;</span>].replace(<span class="string">&#x27;- &#x27;</span>,<span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>:  <span class="subst">&#123;content&#125;</span>&quot;</span>)</span><br><span class="line">        ids.append(<span class="built_in">id</span>)</span><br><span class="line">        results.append(content)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ids = []</span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line">with open(&quot;write_to_file_batchoutput.jsonl&quot;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        response = json.loads(line)[&quot;response&quot;][&quot;body&quot;]</span><br><span class="line">        id = response[&#x27;request_id&#x27;]</span><br><span class="line">        content = response[&#x27;choices&#x27;][0][&#x27;message&#x27;][&#x27;content&#x27;].replace(&#x27;- &#x27;,&#x27;&#x27;).split(&#x27;\n&#x27;)</span><br><span class="line">        print(f&quot;&#123;id&#125;:  &#123;content&#125;&quot;)</span><br><span class="line">        ids.append(id)</span><br><span class="line">        results.append(content)</span><br></pre></td></tr></table></figure><p>这样，我们就通过调用大模型 API 完成了一个简单的关键词抽取任务。事实上，我们可以通过类似的方法解决更多的信息处理任务，如文本分类、文本生成等，只需要根据具体任务的要求设计好提示词，调用 API，解析输出即可。</p>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NJUHPC 运行 Python 程序简明流程</title>
      <link href="/posts/6ab96d9d/"/>
      <url>/posts/6ab96d9d/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hpc.nju.edu.cn/">NJU HPC</a> 指南京大学人工微结构科学与技术协同创新中心高性能计算中心，中心提供多种软硬件资源以供高性能运算服务，本文简单介绍在 NJU HPC 上运行 Python 程序的流程，更多详细使用方法可参见 <a href="https://doc.nju.edu.cn/books/efe93">使用手册</a>。</p><h1>账号注册与登录</h1><h2 id="申请账号">申请账号</h2><p>NJU HPC 的用户由用户组方式管理，如课题组已申请用户组，新用户可以在 <a href="https://scc.nju.edu.cn/user/register">注册页面</a> 注册个人用户，其中用户组名称填写课题组的用户组。<br>提交表单后，用户组组长可以对新用户进行审核，审核通过后，系统会向注册时填写的邮箱发送新用户的账号、密码。<br>该密码即为后文中提到的登录密码。<br>随后，新用户即可在 <code>scc.nju.edu.cn</code> 登录。在后台页面可以对账户信息、密码等进行修改。</p><p><img src="https://download.mariozzj.cn/img/picgo20231102090035.png" alt="SCC 后台页面"></p><p>在后台页面的【财务管理】功能中可以查看提交作业及其费用情况，一般每日 2:00 更新前一周期作业结果。</p><h2 id="绑定二度认证">绑定二度认证</h2><p>关于二度认证的详细信息可参见 <a href="https://doc.nju.edu.cn/books/18d80/page/escience-hap">eScience服务双重认证简明指南</a>，可供使用的二度认证客户端可参考 <a href="https://doc.nju.edu.cn/books/efe93/page/b1a59">远程登录文档</a>，下文以 Microsoft Authenticator 为例。</p><p>获得账号用户可用账号密码登录 <code>access.nju.edu.cn</code> 连接资产。<br>首次登录时会要求绑定二度认证，打开 Microsoft Authenticator，点击右上角的 <code>+</code>，选择 <code>其他账户</code>，扫描二维码，即可完成绑定。</p><p><img src="https://download.mariozzj.cn/img/picgo20231102091332.png" alt="使用 Microsoft Authenticator 绑定二度认证"></p><p>绑定后，点击列表中的 <code>access.nju.edu.cn</code>，即可查看二度认证的即时六位验证码，在浏览器中输入当前六位验证码即可完成绑定。</p><h1>SSH 登录资产</h1><p>HPC登陆节点为 Linux 系统，推荐用户与资产使用命令行进行交互，因此用户最好掌握基础的 Linux 命令行操作。<br>这里以 Windows Powershell 为例，介绍如何使用 SSH 登录资产。</p><p>打开 Powershell，输入 <code>ssh &lt;user&gt;@access.nju.edu.cn</code>，其中 <code>&lt;user&gt;</code> 替换为自己的用户名，然后回车。<br>系统此时会要求输入密码，请注意，<strong>ssh 连接登录节点的密码为登陆密码与实时二度认证验证码的结合</strong>，使用空格分隔。<br>如登录密码为 <code>pswd888.nju</code>，当前二度认证验证码为 <code>876543</code>，则要求输入密码时输入 <code>pswd888.nju 876543</code>，然后回车即可。</p><p><img src="https://download.mariozzj.cn/img/picgo/202311021429079.png" alt="SSH 交互"></p><p>在 HPC，登录节点和计算节点共享部分文件系统，因此可以使用 <code>scp</code> 命令传输文件到登录节点供使用，也可以 <a href="https://doc.nju.edu.cn/link/2#bkmrk-sftp%E7%99%BB%E5%BD%95%EF%BC%88%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%EF%BC%89">使用 XFtp 等工具传输文件</a>。<br>如果需要从非内网/教育网终端传输文件，则可以使用 <a href="https://box.nju.edu.cn/">南大云盘</a>，将文件传输至云盘后，登录节点可以挂载云盘，从而访问云盘中的文件。</p><p>详细的集成云盘教程可见 <a href="https://doc.nju.edu.cn/books/efe93/page/352fe">集成云盘教程</a>。</p><h1>模块环境管理</h1><p>集群（包括登录节点和计算节点）上安装了大量的软件，用户可以通过 <code>module</code> 命令加载需要的软件环境。<br>常用的模块管理命令见 <a href="https://doc.nju.edu.cn/books/efe93/page/e1e32">文档#环境变量</a>。<br>这里，我们使用 <code>module avail</code> 命令查看可用的模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">module avail</span></span><br><span class="line">------------------------------------ /fs00/software/modulefiles ------------------------------------</span><br><span class="line">abaqus/6.14-5                    gcc/7.4.0                   make/4.2.1</span><br><span class="line">anaconda/2                       gcc/7.5.0                   make/4.3</span><br><span class="line">anaconda/2-4.3.1                 gcc/8.2.0                   mathematica/11.0</span><br><span class="line">anaconda/2-5.0.1                 gcc/8.3.0                   mathematica/12.1.0</span><br><span class="line">anaconda/3                       gcc/8.5.0                   matlab/r2020a</span><br><span class="line">anaconda/3-4.3.1                 gcc/9.2.0                   nccl/2.16.2-cuda11.0</span><br><span class="line">anaconda/3-5.0.1                 gcc/9.5.0                   nccl/2.16.2-cuda11.8</span><br><span class="line">aocc/2.0.0                       gcc/10.2.0                  nccl/2.16.2-cuda12.0</span><br><span class="line">aocc/2.1.0                       gcc/10.4.0                  nccl/10.1-v2.4.8</span><br><span class="line">aocc/2.3.0                       gcc/11.2.0                  nccl/10.2-v2.5.6</span><br><span class="line">aocl/2.0                         gcc/11.3.0                  netcdf/c-4.7.0</span><br><span class="line">aocl/2.2                         gcc/12.1.0                  openfoam/v1806-ips2017u6</span><br><span class="line">aws-cli/2.9.6                    git/2.38.1                  openmpi/1.10.0-gcc-5.2.0</span><br><span class="line">:q</span><br></pre></td></tr></table></figure><p>结果可以看出，同一个软件可能在集群安装了多个版本模块，这里我们选择 <code>anaconda/3-5.0.1</code> 模块，接下来使用 <code>module load</code> 命令加载该模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">module load anaconda/3-5.0.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> conda <span class="comment"># 查看 conda 命令的路径</span></span></span><br><span class="line">/fs00/software/anaconda/3-5.0.1/bin/conda</span><br></pre></td></tr></table></figure><p>可以看到 <code>conda</code> 命令的路径已经被添加到环境变量中，接下来我们可以使用 <code>conda</code> 命令创建虚拟环境，安装 Python 包等。</p><h1>创建 conda 创建虚拟环境并安装依赖</h1><p><strong>推荐使用 conda 创建虚拟环境用于运行 Python 程序</strong>，因为一方面在虚拟环境中我们普通用户权限也可以方便安装 Python 包，另一方面可以根据不同项目需求创建不同的虚拟环境，避免不同项目间的依赖冲突。<br>我们使用 <code>conda create</code> 命令创建一个名为 <code>test</code> 的虚拟环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda create -n <span class="built_in">test</span> python=3.8</span></span><br></pre></td></tr></table></figure><p>创建完成后，使用 <code>source activate</code> 命令即可激活该虚拟环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> activate <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p>激活后，命令行提示符前会出现 <code>(test)</code> 字样，表示当前虚拟环境已激活。激活环境后，我们就可以在环境中安装 Python 包了。由于 <a href="https://nju-mirror-help.njuer.org/anaconda.html">南大 anaconda 源公告停止服务</a>，而 <a href="https://doc.nju.edu.cn/books/efe93/page/a1d0c">登录节点访问公网需要认证</a>，我们可以在环境中使用 <code>pip</code> 安装依赖，同时使用 <code>-i</code> 参数指定可访问的南大内网源，以安装安装包较大的 <code>torch</code> 为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install -i https://mirrors.nju.edu.cn/pypi/web/simple torch==2.0</span></span><br></pre></td></tr></table></figure><p>在内网下的安装包下载速度可达千兆。安装完成后，运行的 Python 程序就可以引入 <code>torch</code> 包了。</p><h1>提交作业</h1><p>集群使用作业调度系统管理所有计算作业，该系统接受用户的作业请求，并将作业合理的分配到合适的节点上运行。<br>用户在登录节点使用 <code>bsub</code> 命令提交作业，该命令存在多个参数，这里列出几个重要参数：</p><ul><li><code>-J &lt;job_name&gt;</code>：指定作业名称，以供后续查看作业状态时使用；</li><li><code>-m &lt;node&gt;</code>：指定作业运行的节点，在 <a href="https://doc.nju.edu.cn/books/efe93/page/d9640">计算资源</a> 页面可查看完整的运行队列，在登录节点也可使用 <code>bqueues</code>；</li><li><code>-o &lt;output_file&gt;</code>：标准输出文件</li><li><code>-e &lt;error_file&gt;</code>：错误输出文件</li><li><code>-n &lt;num_cpu&gt;</code>：指定作业运行需要的 CPU 核心数，如 <code>-n 4</code> 表示需要 4 个 CPU 核心；</li><li><code>-gpu &lt;opt_str&gt;</code>：指定作业运行的 GPU 参数，参数以 <code>:</code> 分隔选项，默认值为 <code>num=1:mode=shared:mps=no</code>，包含以下选项：<ul><li><code>num=number</code>：每台主机需要 GPU 的数量，当指定 GPU 数量时，CPU 核心数会根据队列中的 GPU 资源自动分配；</li><li><code>mode=shared|exclusive_process</code>：GPU运行模式，<code>shared</code>对应 Nvidia/AMD DEFAULT compute mode、<code>exclusive_process</code>对应 Nvidia EXCLUSIVE_PROCESS</li><li><code>mps=yes|no</code>：开启或关闭Nvidia Multi-Process Service (MPS)。关闭MPS，多进程通过时间分片的方式共享GPU；开启MPS，多进程共享一个CUDA Context并发执行，增加了GPU利用率。</li></ul></li></ul><p>其他参数可查阅 <a href="https://www.ibm.com/docs/en/spectrum-lsf/10.1.0?topic=bsub-options">IBM 手册</a> 或 <a href="https://doc.nju.edu.cn/books/efe93/page/4f4ad">提交作业教程</a>。例如，我们需要在 <code>734090ib</code> 队列提交一个 GPU 计算任务——运行 <code>train.py</code>，占用 1 张显卡，则输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bsub -J train_model -m 734090ib -gpu num=1:mode=shared:mps=no python train.py</span></span><br><span class="line">Job &lt;********&gt; is submitted to queue &lt;734090ib&gt;.</span><br></pre></td></tr></table></figure><p>提交作业后，系统会返回一个作业 ID，以供后续查看作业状态时使用。</p><p>除了用命令行方式提交作业，也可使用脚本方式提交作业，形如 <code>bsub &lt; jobfile.sh</code>，其中 <code>jobfile.sh</code> 为脚本文件，在脚本文件中可以写多行命令，同时 <code>bsub</code> 命令的各个参数可以在脚本文件中定义，如以上命令等价于以下脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">BSUB -J train_model</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">BSUB -m 734090ib</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">BSUB -gpu num=1:mode=shared:mps=no</span></span><br><span class="line"></span><br><span class="line">python train.py</span><br></pre></td></tr></table></figure><p>最后需要注意，作业最终是提交到计算节点上运行，因此需要在执行 <code>python</code> 命令前需要先激活虚拟环境，加载 anaconda，因此完整的脚本应该为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">BSUB -J train_model</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">BSUB -m 734090ib</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">BSUB -gpu num=1:mode=shared:mps=no</span></span><br><span class="line"></span><br><span class="line">module load anaconda/3-5.0.1</span><br><span class="line">source activate test</span><br><span class="line">python train.py</span><br></pre></td></tr></table></figure><h1>作业管理</h1><p>作业提交后会得到一个作业 ID，可以使用 <code>bjobs</code> 命令查看作业状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bjobs ********</span></span><br><span class="line">JOBID    USER        STAT  QUEUE       JOB_NAME   SUBMIT_TIME  EXEC_HOST</span><br><span class="line">******** ********** RUN   734090ib    train_model  Nov  2 15:51 8*m006</span><br></pre></td></tr></table></figure><p>可以看到，该作业已经在 <code>734090ib</code> 队列中运行，运行的节点为 <code>m006</code>，同时可以看到该作业的状态为 <code>RUN</code>，表示正在运行。<br>在作业运行的过程中，我们可以使用 <code>ssh</code> 命令连接计算节点查看状态，这里 <code>ssh m006</code> 即可。</p><p>如果我们需要终止提交的作业，则可以使用 <code>bkill</code> 命令终止作业：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bkill *******</span></span><br><span class="line">Job &lt;********&gt; is being terminated</span><br></pre></td></tr></table></figure><p>以上就是一次利用 NJUHPC 运行 Python 脚本的简明流程。更多详细用法，可以查阅 <a href="https://doc.nju.edu.cn/books/efe93">超级计算指引文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> bsub </tag>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下载 OpenAlex 数据集并配置 PySpark 的一次记录</title>
      <link href="/posts/fb1f3a84/"/>
      <url>/posts/fb1f3a84/</url>
      
        <content type="html"><![CDATA[<h1>关于 OpenAlex 数据集</h1><p>2015 年微软发布了微软学术知识图谱（MAG）数据集[^1]，因其海量、全面的特点被广泛应用于各类研究，但好景不长，2021 年该数据集停止维护。2022 年，OpenAlex 数据集应运而生[^2]，该数据集继承了大量来自 MAG 的数据，同时整合了来自 OpenCitations[^3]、AMiner[^4]、PID Graph[^5]、Open Research Knowledge Graph[^6]、Semantic Scholar[^7]、OpenAIRE research graph[^8] 的数据。</p><p>该数据集开放下载，将科学研究中的重要环节实体化，共分为 Works、Authors、Concepts、Institutions、Venues 等多个实体，并建立关联，每日更新。详见 <a href="https://docs.openalex.org/">OpenAlex 文档</a><br><img src="https://download.mariozzj.cn/img/picgo/202210151055844.png" alt="OpenAlex Entities"></p><p>因为研究需要，我需要对 OpenAlex 进行下载配置。阅读文档后发现数据的获取较为轻松，因此记录一下。</p><h1>下载 OpenAlex</h1><p>OpenAlex 官方最推荐的使用方法是通过 API 调用的方式获取需要的部分数据，但是这对我来说或许有些麻烦，且不利于我了解整个数据集，因此计划将 OpenAlex 快照下载至高性能计算服务器进行进一步分析。</p><p>OpenAlex 数据集存储在 Amazon S3 上，以 gzip 压缩的 json 文件格式存储，根据数据的更新日期，对不同实体数据文件分区存储，同一分区下根据数据规模划分为若干文件，每个文件大小不超过 2 GB。</p><h2 id="安装-AWS-CLI">安装 AWS CLI</h2><p>由于数据集存储在 Amazon S3 上，下载需要通过亚马逊 Web 服务命令行界面（Amazon Web Service Command Line Interface，AWSCLI）下载。根据 <a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html">AWS CLI 下载示例</a>，以 Linux 为例，需要执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl <span class="string">&quot;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip&quot;</span> -o <span class="string">&quot;awscliv2.zip&quot;</span> <span class="comment"># 下载安装包</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip awscliv2.zip <span class="comment"># 解压</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ./aws/install <span class="comment"># 执行安装</span></span></span><br></pre></td></tr></table></figure><p>安装完成后，执行 <code>aws</code> 命令检查是否成功安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws --version</span></span><br><span class="line">aws-cli/2.7.24 Python/3.8.8 Linux/4.14.133-113.105.amzn2.x86_64 botocore/2.4.5</span><br></pre></td></tr></table></figure><h2 id="下载数据集">下载数据集</h2><p>安装完 AWS CLI 后即可执行命令下载数据集快照。需注意：整个快照的大小为 330 GB 或更多（可以通过运行 <code>aws s3 ls --summarize --human-readable --no-sign-request --recursive &quot;s3://openalex/&quot;</code> 命令查看当前版本快照大小），需要保证磁盘有足够的存储空间，同时确保网络能够保证完成这段时间的下载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aws s3 <span class="built_in">sync</span> <span class="string">&quot;s3://openalex&quot;</span> <span class="string">&quot;openalex-snapshot&quot;</span> --no-sign-request</span></span><br></pre></td></tr></table></figure><p>所有的数据会被下载至 <code>openalex-snapshot</code> 文件夹中。最终该文件夹的目录形式如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">openalex-snapshot/</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── RELEASE_NOTES.txt</span><br><span class="line">└── data</span><br><span class="line">    ├── authors</span><br><span class="line">    │   ├── manifest</span><br><span class="line">    │   └── updated_date=2021-12-28</span><br><span class="line">    │       ├── 0000_part_00.gz</span><br><span class="line">    │       └── 0001_part_00.gz</span><br><span class="line">    ├── concepts</span><br><span class="line">    │   ├── manifest</span><br><span class="line">    │   └── updated_date=2021-12-28</span><br><span class="line">    │       ├── 0000_part_00.gz</span><br><span class="line">    │       └── 0001_part_00.gz</span><br><span class="line">    ├── institutions</span><br><span class="line">    │   ├── manifest</span><br><span class="line">    │   └── updated_date=2021-12-28</span><br><span class="line">    │       ├── 0000_part_00.gz</span><br><span class="line">    │       └── 0001_part_00.gz</span><br><span class="line">    ├── venues</span><br><span class="line">    │   ├── manifest</span><br><span class="line">    │   └── updated_date=2021-12-28</span><br><span class="line">    │       ├── 0000_part_00.gz</span><br><span class="line">    │       └── 0001_part_00.gz</span><br><span class="line">    └── works</span><br><span class="line">        ├── manifest</span><br><span class="line">        └── updated_date=2021-12-28</span><br><span class="line">            ├── 0000_part_00.gz</span><br><span class="line">            └── 0001_part_00.gz</span><br></pre></td></tr></table></figure><h1>本地处理转化 TSV</h1><p>下载的文件分布于多个文件夹、文件中，且以 gzip 压缩的 json 文件形式存储，可能不便于后续 Spark 计算性能的发挥，所以需要将数据文件进行合并，并转化为 TSV 形式（数据内容含逗号，因此采用制表符作为分隔符）。</p><p>由于文件存储形式为 json，需要实现这些 json 文件到关系型数据的转化。这里参照 <a href="https://docs.openalex.org/download-snapshot/upload-to-your-database/load-to-a-relational-database/postgres-schema-diagram">OpenAlex Postgres schema diagram</a> 进行导入，文档中还给出了 <a href="https://gist.github.com/richard-orr/152d828356a7c47ed7e3e22d2253708d">CSV 转换脚本</a>，但是经过测试，发现该脚本存在一些缺陷，可能对后续 spark 读取带来困难，因此我对脚本的缺陷部分进行了调整：</p><ul><li>调整所有读取、写入的文件方法，规定编码集为 <code>utf-8</code>；</li><li>调整分隔符为制表符，取消压缩过程；</li><li>对处理 json 的方法 <code>json.dumps()</code> 添加参数 <code>ensure_ascii=False</code>，确保不会将特殊字符转为 Unicode。（<a href="https://gist.github.com/richard-orr/152d828356a7c47ed7e3e22d2253708d?permalink_comment_id=4336113#gistcomment-4336113">反馈</a>后，作者已修复）</li><li>对于所有的 id，源文件为完整 url，不便于之后的聚合、连接等操作时提升速度，因此均转换为 int 类型。</li></ul><p>最终得到了 <a href="https://gist.github.com/MarioZZJ/3373ecd492af16728ac6c726d8639acd">调整问题后的 TSV 转换脚本</a>。在 <code>openalex-snapshot</code> 文件夹外运行指令即可（注意需保证 python 版本不低于 3.8，以支持海象运算符）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3 flatten-openalex-jsonl.py</span> </span><br></pre></td></tr></table></figure><p>这将会在 <code>csv-files</code> 文件夹生成 27 个 tsv 文件，文件名同下图 Schema 中的表名。生成的 tsv</p><p><img src="https://download.mariozzj.cn/img/picgo/202210151148705.png" alt="OpenAlex Postgres schema"></p><h1>配置 PySpark</h1><p>文件生成后，即可配置 PySpark 进行读取。虽然 PySpark 可以直接读取 json，但是实践发现由于 schema 设置和解析等问题，初始化过程较慢，不如 tsv。在 tsv 中我们的表结构是确定的，因此可以在读入时直接告知 spark 该表的 schema，这样可以加速初始化过程。如 works_concepts 表的读取过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spark 是已经创建的 SparkSession，StructType 等是 pyspark.sql.types 中的类</span></span><br><span class="line">WorksConcepts = spark.read.<span class="built_in">format</span>(<span class="string">&#x27;csv&#x27;</span>).options(</span><br><span class="line">    header=<span class="string">&#x27;true&#x27;</span>, delimiter=<span class="string">&#x27;\t&#x27;</span> <span class="comment"># 分隔符为制表符</span></span><br><span class="line">    ).schema(</span><br><span class="line">        StructType(</span><br><span class="line">        ).add(</span><br><span class="line">            StructField(<span class="string">&#x27;work_id&#x27;</span>, StringType(), <span class="literal">True</span>)</span><br><span class="line">        ).add(</span><br><span class="line">            StructField(<span class="string">&#x27;concept_id&#x27;</span>, StringType(), <span class="literal">True</span>)</span><br><span class="line">        ).add(</span><br><span class="line">            StructField(<span class="string">&#x27;score&#x27;</span>, FloatType(), <span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">    ).load(<span class="string">&#x27;xxx/csv-files/works_concepts.tsv&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当然可以对方法和数据进行封装，最终得到基础的 <a href="https://github.com/whuscity/pySparkDemo_OpenAlex/blob/main/spark_openalex_init.py">OpenAlex PySpark 初始化脚本</a>，在需要使用前调用运行即可。</p><p>[^1]:Arnab Sinha, Zhihong Shen, Yang Song, Hao Ma, Darrin Eide, Bo-June (Paul) Hsu, and Kuansan Wang. 2015. An Overview of Microsoft Academic Service (MAS) and Applications. In Proceedings of the 24th International Conference on World Wide Web (WWW '15 Companion). Association for Computing Machinery, New York, NY, USA, 243–246. <a href="https://doi.org/10.1145/2740908.2742839">https://doi.org/10.1145/2740908.2742839</a><br>[^2]:Priem, J., Piwowar, H., &amp; Orr, R. (2022). OpenAlex: A fully-open index of scholarly works, authors, venues, institutions, and concepts. ArXiv. <a href="https://arxiv.org/abs/2205.01833">https://arxiv.org/abs/2205.01833</a><br>[^3]:Peroni, S., Shotton, D., Vitali, F. (2017). One Year of the OpenCitations Corpus. In: , et al. The Semantic Web – ISWC 2017. ISWC 2017. Lecture Notes in Computer Science(), vol 10588. Springer, Cham. <a href="https://doi.org/10.1007/978-3-319-68204-4_19">https://doi.org/10.1007/978-3-319-68204-4_19</a><br>[^4]:Jie Tang, Jing Zhang, Limin Yao, Juanzi Li, Li Zhang, and Zhong Su. 2008. ArnetMiner: extraction and mining of academic social networks. In Proceedings of the 14th ACM SIGKDD international conference on Knowledge discovery and data mining (KDD '08). Association for Computing Machinery, New York, NY, USA, 990–998. <a href="https://doi.org/10.1145/1401890.1402008">https://doi.org/10.1145/1401890.1402008</a><br>[^5]:Fenner, M., &amp; Aryani, A. (2019). Introducing the PID graph. <a href="https://doi.org/10.5438/JWVF-8A66">https://doi.org/10.5438/JWVF-8A66</a><br>[^6]:Mohamad Yaser Jaradeh, Allard Oelen, Kheir Eddine Farfar, Manuel Prinz, Jennifer D’Souza, Gábor Kismihók, Markus Stocker, and Sören Auer. 2019. Open Research Knowledge Graph: Next Generation Infrastructure for Semantic Scholarly Knowledge. In Proceedings of the 10th International Conference on Knowledge Capture (K-CAP '19). Association for Computing Machinery, New York, NY, USA, 243–246. <a href="https://doi.org/10.1145/3360901.3364435">https://doi.org/10.1145/3360901.3364435</a><br>[^7]:Waleed Ammar, Dirk Groeneveld, Chandra Bhagavatula, Iz Beltagy, Miles Crawford, Doug Downey, Jason Dunkelberger, Ahmed Elgohary, Sergey Feldman, Vu Ha, Rodney Kinney, Sebastian Kohlmeier, Kyle Lo, Tyler Murray, Hsu-Han Ooi, Matthew Peters, Joanna Power, Sam Skjonsberg, Lucy Wang, et al… 2018. Construction of the Literature Graph in Semantic Scholar. In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 3 (Industry Papers), pages 84–91, New Orleans - Louisiana. Association for Computational Linguistics.<br>[^8]:Manghi, P., Atzori, C., Bardi, A., Schirrwagen, J., Dimitropoulos, H., … Summan, F. (2019).<br>OpenAIRE Research Graph Dump. Zenodo. <a href="https://doi.org/10.5281/zenodo.3516918">https://doi.org/10.5281/zenodo.3516918</a></p>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenAlex </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让 Markdown 成为写作的起点</title>
      <link href="/posts/fd830caf/"/>
      <url>/posts/fd830caf/</url>
      
        <content type="html"><![CDATA[<h1>Markdown 是世上最好的写作语言</h1><p>Markdown 是一种轻量级标记语言，由 John Gruber 于 2004 年初创，目前已成为世界上最流行的标记语言之一。它轻量小巧，简单易学，同时又具有无限潜能，近两年已成为我的主力写作语言。</p><p>说 Markdown 是“世界上最好的语言”，当然是在玩 php 的梗，<strong>适合自己的写作方法才是最好的</strong>。随着我认知的深入，我接触到越来越多的奇淫技巧，发现它在提升我写作效率的同时也具有许多意想不到的应用场景。</p><p>略知但不愿意使用 Markdown 来写作的人大概可以分两拨，一类是能够熟练使用 Word 等富文本编辑器，或者是 Latex 大神，认为 Markdown 的应用场景很局限，没法把文档玩出花，根本不够用；另一类是天然地对“编程语言”不感冒，觉得自己肯定学不会，Markdown 是一种语言，那肯定很难学吧？</p><p>事实上这两类人群或许都对 Markdown 存在认知误区。对于前者，在写作前我们应该明确写作的目的，<strong>如果我们非常重视产出文本的格式，那我们自然就不会用 Markdown 来写</strong>，而是用更强力的富文本编辑器或写作语言来完成写作；对于后者，其实写 Markdown 根本不是“编程”，因为文档本身不涉及程序编译，只有渲染等过程需要（当然，渲染都是用现成工具，不需要学会），而且 <strong>Markdown 的语法极其简洁</strong>，如果你不需要格式定义，那这个文档里面除了你的内容文字什么都没有。</p><h2 id="最好的语言：必须易学">最好的语言：必须易学</h2><p>Markdown 的语法相当简单，内容还是原原本本的内容，如果需要<strong>格式定义</strong>仅仅需要利用一系列<strong>标点符号</strong>即可，且种类有限：如 <code>#</code> 用于定义标题，<code>*</code> 用于控制粗体、斜体、列表，<code>&gt;</code> 用于插入引用内容，<code>[]</code>、<code>()</code>、<code>!</code> 等用于插入图片和超链接，<code>$</code> 用于插入 $\LaTeX$ 公式……可以参考 <a href="https://markdown.com.cn/">Markdown 教程</a> 进行简要学习。基础内容大约几分钟就可以学会，不需要任何前置知识。</p><p><img src="https://download.mariozzj.cn/img/picgo/202204191444092.png" alt="Markdown 语法：内容+符号"></p><h2 id="最好的语言：必须够用">最好的语言：必须够用</h2><p>Markdown 介于富文本和纯文本之间，它是纯文本的形式，却能够在渲染后呈现接近富文本的样式。Markdown 支持的基本格式已经基本足够用于<strong>做笔记、形成知识库、发布博文</strong>等，例如 Github Repo以及 Issue、Pull Request 等就支持 Markdown 样式，简书、知乎等平台也支持 Markdown 写文档、回答。而且得益于 Markdown 文档二进制文件特性，利用 Git 等可以进行<strong>版本管理</strong>，回溯每一版本的内容。</p><p>实际上，Markdown 本身只包含两部分信息：内容和标记格式。但标记格式其实是一类内容，类似于 HTML 中的 <code>class</code>，但是这类内容最终如何呈现，取决于渲染器中的选项。因此，如果 Markdown 语法能满足最终需要定义的格式类型需求，完全可以<strong>通过调整模板/配置文件来实现更加细节的格式输出</strong>（如颜色、字号、间距、对齐等在 Markdown 中无法定义的细节）。不同于 Word、LaTeX 是基于页面的写作，Markdown 是基于网页的写作，所以大多数的渲染器都支持 HTML 嵌入，所以也可以通过<strong>插入 HTML 的方式来实现部分细节排版</strong>（不推荐大量使用，这有悖于使用 Markdown 写作的初衷）。所以可以说，Markdown 能实现的排版格式在不同程度上都是够用的，后文还会继续介绍一些方法。</p><p><img src="https://download.mariozzj.cn/img/picgo/202204191702600.jpg" alt="Markdown 流"></p><h2 id="最好的语言：专注内容">最好的语言：专注内容</h2><p>在未接触到 Markdown 前，我一般习惯用 Microsoft Word 等富文本编辑器用于大部分的文本编辑场景。但是用久了会发现，我在写作的过程中，<strong>很大一部分时间并不是在做知识的输入输出，而是在不断地调整格式</strong>。尽管在我大部分的工作流中，一般会在最后一步调整格式并校对，但是仍然避免不了写作中停止我的思考，并且开始玩编辑器控件；另外，在部分场景下，我最终的输出结果并不一定是页面形式（打印等），Word 等编辑器基于页面的文档编辑逻辑会分走我的部分精力。</p><blockquote><p>这个表格怎么错页了？</p><p>这个图片怎么这么大？</p><p>这个字体好难看啊！</p><p>这里怎么换行了？？</p></blockquote><p>实际上，大部分的形式问题在我们产出完整的内容之前无关紧要，有时这些形式打断了我们的输出逻辑，对整体成文质量可能是致命的。而 Markdown 因其<strong>纯文本的编辑方式</strong>，在一定程度上可以<strong>减少我们对格式的关注，专注于内容本身</strong>。而相比于简单的纯文本，Markdown 的基础语法也能够保证我们的行文有基本逻辑（可以用标题控制大纲、有序列表展示条目等）。</p><h2 id="小结">小结</h2><p>到这里，我觉得可以用 <a href="https://www.markdownguide.org/">Markdown Guide</a> 中的部分描述总结 Markdown 语言的优势。</p><p><strong>Markdown can be used for everything./ Markdown is everywhere.</strong> 用途广泛，网站、知识库、笔记、技术文档等都可见 Markdown 的身影。</p><p><strong>Markdown is portable. /Markdown is future proof.</strong> 二进制纯文本文件，不需要特定的编辑器或平台也可以打开，便于版本控制。</p><p><strong>Markdown is platform independent.</strong></p><p>另外，Markdown 简单易学，也能让我们回归写作初衷，提升效率。</p><h1>工欲善其事，必先利其器</h1><p>虽说 Markdown 用普通的文本编辑器就能打开，但是还是有很多编辑器表现优秀，可以提升我们的输入效率，值得推荐。</p><h2 id="Typora">Typora</h2><p><a href="https://typora.io/">Typora</a> 应该是知名度最高的 Markdown 编辑器（没有之一），在很长一段的测试期内一直免费使用，广受好评，虽然最近推出正式版后开始收费，但实属可以理解，也可以继续免费用测试版本。</p><p><img src="https://download.mariozzj.cn/img/picgo/202204191908918.jpg" alt="Typora"></p><p>Typora 的亮点是所见即所得以及<strong>快捷键支持</strong>，如果能够熟记 Typora 的快捷键操作，我们甚至不需要会 Markdown 语法也可以写 Markdown 文档。例如 <u><code>Ctrl</code> + 数字</u> 为设定标题，<u><code>Ctrl</code> + <code>b</code></u> 为加粗，<u><code>Ctrl</code> + <code>Shift</code> + <code>M</code></u> 为插入行间公式等。<strong>所见即所得</strong>是 Typora 会根据选定主题实时渲染 Markdown 文档，可以一边预览一边输入，且预览和输入在同一窗口。</p><p><img src="https://download.mariozzj.cn/img/picgo/typora.gif" alt="Typora 所见即所得"></p><p>另外，Typora 还集成了对 Pandoc 的支持，可以直接导出多种格式（包括我们常用的 PDF、docx 等），方便我们将文档发送给他人查看。后文还将具体介绍 Pandoc。</p><p><img src="https://download.mariozzj.cn/img/picgo/202204191911851.png" alt="Typora 丰富的格式导出"></p><h2 id="Visual-Studio-Code">Visual Studio Code</h2><p><a href="https://code.visualstudio.com/">VSCode</a> 是微软推出的开源轻量级代码编辑器。VSCode 可以<strong>编辑所有的二进制文本文件</strong>，当然也包括 Markdown。这里推荐 VSCode 是因为 VSCode 可以同时编辑所有文本文件（包括文档、代码等）、多窗口支持等特性。VSCode 本身不支持 Markdown 渲染，但是 VSCode 强大就强大在它的<strong>扩展能力</strong>，可以通过插件实现多种功能，如 Markdown 渲染就可以用 <a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a> 插件。</p><p><img src="https://download.mariozzj.cn/img/picgo/202204191444092.png" alt="Markdown All in One: 左栏编辑，右栏预览"></p><h2 id="墨滴MDNice">墨滴MDNice</h2><p>最后推荐一款在线 Markdown 编辑器——<a href="https://editor.mdnice.com/">墨滴</a>，这个编辑器同样是左栏编辑，右栏预览，但是其亮点是<strong>生成可复制到微信公众平台/知乎等内容平台的 HTML</strong>，对于坚持写博客的我来说每次都<strong>免去</strong>了不同平台分发内容时的<strong>排版</strong>过程，节省了很多时间。另外它不用安装软件，使用浏览器即可使用，也可以在线导出 pdf。美中不足之处就是排版版式过少，可能需要更多的前端贡献。</p><p><img src="https://download.mariozzj.cn/img/picgo/202204191931464.png" alt="墨滴 在线编辑预览 Markdown"></p><h2 id="图床">图床</h2><p>在所有需要写入 Markdown 文档的内容中，图片应该是较难处理的。因为 Markdown 是纯文本，所以插入图片只能通过语法中的引用 <code>![图片标题](图片链接)</code> 填入地址。一般情况下，使用 Typora 等编辑器插入图片，会将图片放在本地计算机的某个地方并引用，但是如果我们想让文档分享给他人，就需要将图片一并上传并保证原本的相对文件结构，这样或许会比较麻烦。</p><p>现在比较流行的一种做法是将图片全部都放在云上，Markdown 内填入网络地址，渲染时文档预览者实时获取预览图片。这种专门用于存放图片的方式叫做图床或对象存储，优势在于<strong>图片上传方便</strong>，永久保存，<strong>加载图片时仅占用图床服务资源</strong>，并不与博客内容其他资源冲突造成整体加载缓慢的情况。</p><p>这里分享我的解决方案：<a href="https://cloud.tencent.com/product/cos">腾讯云对象存储</a> + <a href="https://picgo.github.io/PicGo-Doc/zh/">PicGo</a>。其中前者提供图床服务，后者用于图片上传。腾讯云对象存储一般是按用量收费，作为个人用户，我们的用量其实相对较少，每个月的消费可以忽略不计，而且腾讯云的服务相对稳定，可以和绑定在腾讯云的其他资源（CDN、域名）形成配合。选择 PicGo 是因为 Typora 提供了接口支持，可以实现图片复制一键上传重命名；VSCode 也有对应插件提供服务。</p><h1>运用 Pandoc 将文档转换为多种格式</h1><p>Markdown 的缺点之一就是用的人还不够多，在分享协作方面可能存在困难，电脑里安装了 Markdown 阅读器的人一定比安装了 Word 或者 PDF 阅读器的人少非常多，这也是强大的 LaTeX 的缺点之一。但是 Pandoc 解决了这个问题，可以将我们编辑好的 Markdown 文档进行渲染、转换为其他人可以查看的常用格式。</p><p><a href="https://pandoc.org/">Pandoc</a> 由 John MacFarlane 开发，是一个强大的全局文档转换器，提供了 标记语言到几乎所有 <a href="https://pandoc.org/diagram.svgz">常见文档格式的转换</a>（如 HTML、Word、PowerPoint、LaTeX、PDF 等）。这样我们就可以将写完的 Markdown 文档分享给他人阅读。Pandoc 导出时一般需要对样式/模板进行设定，如果确有稳定的文档编辑需求，可以设定好模板便于导出。</p><h2 id="用-Markdown-写论文">用 Markdown 写论文</h2><p>Markdown 可以导出为 docx 格式，并轻松处理引用问题。我的本科毕业论文就是使用 Markdown 完成的，按照导师和学校要求的格式导出为 docx。只需要通过下面一行命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc <span class="literal">--citeproc</span> <span class="literal">--number-sections</span> <span class="literal">--csl</span> ./assets/china<span class="literal">-national-standard-gb-t-7714-2015-numeric</span>.csl <span class="literal">--bibliography</span> ./assets/better_bibtex.bib <span class="literal">-M</span> reference<span class="literal">-section-title</span>=<span class="string">&quot;参考文献&quot;</span> <span class="literal">-M</span> link<span class="literal">-citations</span>=true <span class="literal">--reference-doc</span> ./assets/whu_bsc_dissertation_template_pandoc.docx ./main.md <span class="literal">-o</span> ./output/main.docx</span><br></pre></td></tr></table></figure><p>这里涉及到的部分参数含义如下：</p><ul><li><code>--citeproc</code>：处理文献引用。</li><li><code>--number-sections</code>：导出时对标题进行编号。</li></ul><p>这里涉及到五个文件：</p><ul><li><code>main.md</code>：即撰写的 Markdown 文件。</li><li><code>main.docx</code>：即导出的 Docx 文件。</li><li><code>whu_bsc_dissertation_template_pandoc.docx</code>：按照我校毕业论文标准修改的 Pandoc 模板。</li><li><code>china-national-standard-gb-t-7714-2015-numeric.csl</code>：引用文献参考格式文件，使用 Zotero 的可以在 <a href="https://www.zotero.org/styles">Zotero 样式仓库</a> 下载。</li><li><code>better_bibtex.bib</code>：我参考的文献元信息，Zotero 导出。</li></ul><p>模板文件中，对各类内容预先进行了样式定义（见 <a href="https://pandoc.org/MANUAL.html">Pandoc 手册</a> 中关于 reference-doc 的相关说明），如果没有模板文件可以通过 <code>pandoc -o custom-reference.docx --print-default-data-file reference.docx</code> 命令生成默认样式文件后修改。需注意所有的修改要在 Word 的样式库中进行，<a href="https://github.com/jgm/pandoc/issues/8009">仅仅修改模板文档中的内容无效</a>。</p><p>在源 Markdown 文件中，在 Front Matter 中定义好参考文献的存放位置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">bibliography: [/assets/better<span class="emphasis">_bibtex.bib]</span></span></span><br><span class="line"><span class="emphasis"><span class="section">---</span></span></span><br></pre></td></tr></table></figure><p>随后就可以用 Pandoc 的引用模式插入引文，按照文献元信息中的 CiteKey 按如下形式引用即可（标注单一文献或同时标注多文献均可）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正文正文正文正文 @citekey1 正文正文正文 [ @citekey1; @citekey1 ]</span><br></pre></td></tr></table></figure><p>随后就可以用最开始的那一行命令生成 docx 文件了。</p><p><img src="https://download.mariozzj.cn/img/picgo/202204192045834.png" alt="Markdown 转换为 docx"></p><h2 id="用-Markdown-做幻灯片">用 Markdown 做幻灯片</h2><p>Markdown 也可以按照定义的格式转换为 Powerpoint 格式，在母版中进行调整，原理与转换为 docx 几乎相同，详见 Pandoc 手册。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc <span class="literal">--reference-doc</span> ./custom<span class="literal">-reference</span>.pptx ./test.md <span class="literal">-o</span> ./output/test.pptx</span><br></pre></td></tr></table></figure><p><img src="https://download.mariozzj.cn/img/picgo/202204192101645.png" alt="Markdown 转换为 pptx"></p><p>还有一种转换为幻灯片的方法——借助 <a href="https://revealjs.com/">reveal.js</a> 转换为网页幻灯片。在主机安装 <code>reveal.js</code> 后，可以利用以下命令生成网页幻灯片的 HTML：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc ./test.md <span class="literal">-o</span> ./slides.html <span class="literal">-t</span> revealjs <span class="literal">-s</span></span><br></pre></td></tr></table></figure><p><img src="https://download.mariozzj.cn/img/picgo/md-slidesgo.gif" alt="Markdown 转换为 SlidesGo"></p><p>Reveal.js 自带控制控件，只需要浏览器就可以打开，因此几乎可以在任何一台电脑上都可以展示。可以查看 <a href="https://revealjs.com/config/">Reveal.js 参数列表</a> 配置更多参数，进一步修改格式。</p><hr><p>虽然目前也涌现出越来越多的标记语言，如 RMarkdown、<br>CommonMark 等，增加了更多特性，但是 Markdown 自诞生之日起就因为其简约易学、专注内容、潜力无限的特性被不少人所接受。现在也可以看到许多富文本编辑器都能引入 Markdown 支持，一定程度上提升了写作效率，希望未来能够看到更多兼容 Markdown 的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 工具干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两种图算法：PageRank &amp; EigenFactor</title>
      <link href="/posts/1d43c0e5/"/>
      <url>/posts/1d43c0e5/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍两种图数据的算法，PageRank 和 EigenFactor，都可以用于图数据的链接分析，是无监督算法。首先将介绍 PageRank，这将有助于理解 EigenFactor。</p><h1>PageRank</h1><p>PageRank 算法于 1998 年由 Google 公司的 Larry Page 等提出，最初用于网页排序。</p><p>我们都知道网页上可以存在指向其他网页的超链接，以网页本身为结点，构建基于超链接指向的连边，我们就得到了一个图，现在就可以基于这个图数据进行分析。</p><h2 id="基本理解">基本理解</h2><p>我们可以对结点（网页）进行重要性评价，除去网页质量本身，通过图的拓扑结构我们也能对结点进行评价，如<strong>基于中心性的评价</strong>认为，如果一个结点能被较多其他结点连接到（即入度较高），这个结点就处于较中心的位置，重要性较高。而这样一种方法的缺陷也很明显，就是它在计算影响力时，<strong>仅仅考虑了连边的数量，而没有考虑连接到结点本身的其他结点的影响力</strong>。这很容易理解，例如有两个网页各自都被三个其他网页链接到，但是前者是被三个不知名网站链接到，后者是被三个知名网站链接到，虽然我们都明白后者的影响力更高，但是在基于入度的评价中，二者影响力相同；或者再举一个社会网络中的例子，你和小明都被三个人认识，认识你的三个人是隔壁村的小学生，而认识小明的是三个国家的总统，虽然你们都仅被三个人认识，但是你们实际的影响力却是悬殊的。</p><p>而 PageRank 就解决了这样的问题，在考虑连入结点的边对结点影响力贡献的同时，也考虑了和结点相连结点的影响力对该结点的影响力的贡献。不难理解，PageRank 是一种递归算法，通过在图中不断迭代，实现计算结点的影响力。</p><h2 id="PageRank-基本定义">PageRank 基本定义</h2><h3 id="基本定义">基本定义</h3><p>给定一个包含 $n$ 个结点<strong>强连通且非周期性的有向图</strong>，在有向图上定义<strong>随机游走模型</strong>，即一阶马尔可夫链。其随机游走的特点是从一个结点到有有向边连出的所有结点的<strong>转移概率相等</strong>，转移矩阵为<br>$M$。这个马尔可夫链具有平稳分布 $R$<br>$$ MR=R $$<br>平稳分布 $R$ 称为这个有向图的 <strong>PageRank</strong>。$R$ 的各个分量称为各个结点的 PageRank 值。<br>$$ R= \left[\begin{matrix} PR(v_1) \ PR(v_2) \ \cdots \ PR(v_n) \end{matrix}\right] $$<br>其中 $PR(v_i)（i=1,2,\cdots,n）$ ，表示结点的的 PageRank 值。</p><h3 id="有向图、强连通图、周期性图">有向图、强连通图、周期性图</h3><p>有向图中，要求边是有方向的，有起点和终点。网页、超链接组成的图就可以理解为<strong>有向图</strong>。</p><p>在有向图中，从一个结点出发到达另一个结点，所经过的边的一个序列称为一条路径，路径上边的个数称为路径的长度。如果一个有向图从其中任何一个结点出发可以到达其他任何一个结点，就称这个有向图是<strong>强连通图</strong>。</p><p>假设 $k$ 是一个大于 1 的自然数，如果从有向图的一个结点出发返回到这个结点的路径的长度都是 $k$ 的倍数，那么称这个结点为周期性结点。如果一个有向图不含有周期性结点，则称这个有向图为<strong>非周期性图</strong>，否则为周期性图。<br><img src="https://download.mariozzj.cn/img/picgo/20220330210548.png" alt="有向图、强连通图、非周期性图"></p><h3 id="随机游走模型、一阶马尔可夫链">随机游走模型、一阶马尔可夫链</h3><p>在有向图上定义随机游走模型，此时结点表示状态，连边表示状态的转移，这样的随机游走形成一阶马尔可夫链，也就是说，<strong>随机游走者在 $(t+1)$ 时刻访问某结点的概率仅仅与 $t$ 时刻的状态有关</strong>，和之前的状态无关。</p><p><img src="https://download.mariozzj.cn/img/picgo/20220331193211.png" alt="图(a)"></p><p>我们又定义，其随机游走的特点是从一个结点到有有向边连出的所有结点的<strong>转移概率相等</strong>，转移矩阵为<br>$M$。也就是说，<strong>从一个结点移动到其所有指向的其他节点的概率相等</strong>，以强连通且非周期性的有向图(a)为例，假设当前时刻结点 $A$，那么下一时刻转移到结点 $B、C、D$ 的概率相等，即 $m_{AB}=m_{AC}=m_{AD}=\dfrac{1}{3}$，并以 $0$ 概率转移到 $A$，这一概率仅依赖于当前状态。以此类推我们可以算出其他转移概率，并得到转移矩阵 $M$：</p><p>$$ M = [m_{ij}]_{n \times n} = \left[\begin{matrix} 0 &amp;\dfrac{1}{2} &amp;1 &amp;0 \ \dfrac{1}{3} &amp;0 &amp;0 &amp;\dfrac{1}{2} \ \dfrac{1}{3} &amp;0 &amp;0 &amp;\dfrac{1}{2} \ \dfrac{1}{3} &amp;\dfrac{1}{2} &amp;0 &amp;0  \end{matrix}\right] $$</p><p>随机游走<strong>在某个时刻 $t$ 访问各个结点的概率分布</strong>就是马尔可夫链在时刻 $t$ 的状态分布，可以<strong>用一个 $n$ 维列向量 $R_t$ 表示</strong>，那么在 $(t+1)$ 时刻访问各个结点的概率分布 $R_{t+1}$ 满足<br>$$ R_{t+1} = MR_t $$</p><h3 id="求解-PageRank">求解 PageRank</h3><p>当图结构确定时，转移矩阵也是确定的。回到 PageRank 的基本定义，在初始状态下我们并未处于任何结点，此时访问各个结点的概率相等，即<br>$$ R_0 = \left[\begin{matrix} \dfrac{1}{n} \ \dfrac{1}{n} \ \cdots \ \dfrac{1}{n} \end{matrix}\right] $$<br>而之后状态下的概率分布则会与上一时刻的状态有关，分别为 $MR_0，M^2R_0，\cdots，M^tR_0，\cdots$</p><p>根据马尔可夫链平稳分布定理，强连通且非周期的有向图上定义的随机游走模型（马尔可夫链） ，在图上的随机游走当时间趋于无穷时状态分布<strong>收敛于唯一的平稳分布</strong> $R$，即<br>$$ \lim\limits_{t \to \infty} M^tR_0 = R $$<br>且满足<br>$$ MR=R=\left[\begin{matrix} PR(v_1) \ PR(v_2) \ \cdots \ PR(v_n) \end{matrix}\right]  $$<br>不难得出<br>$$ PR(v_i) \ge 0，i=1,2,\cdots,n $$ $$ \sum\limits_{i=1}^n PR(v_i) = 1 $$ $$ PR(v_i) = \sum\limits_{v_j \in M(v_i)} \dfrac{PR(v_j)}{L(v_j)}，i=1,2,\cdots,n $$<br>这里 $M(v_i)$ 表示指向结点 $v_i$ 的结点集合， $L_(v_j)$ 表示结点 $v_j$ 连出有向边的个数。</p><p>例如，我们可以以图(a)为例求解 PageRank。</p><p><img src="https://download.mariozzj.cn/img/picgo/20220331193211.png" alt="图(a)"></p><p>根据图(a)得出转移矩阵<br>$$ M = [m_{ij}]_{n \times n} = \left[\begin{matrix} 0 &amp;\dfrac{1}{2} &amp;1 &amp;0 \ \dfrac{1}{3} &amp;0 &amp;0 &amp;\dfrac{1}{2} \ \dfrac{1}{3} &amp;0 &amp;0 &amp;\dfrac{1}{2} \ \dfrac{1}{3} &amp;\dfrac{1}{2} &amp;0 &amp;0  \end{matrix}\right] $$<br>初始分布向量<br>$$ R_0 = \left[\begin{matrix} \dfrac{1}{4} \ \dfrac{1}{4} \ \dfrac{1}{4} \ \dfrac{1}{4} \end{matrix}\right] $$<br>以转移矩阵 $M$ 连乘初始向量 $R_0$ 得到向量序列<br>$$ \left[\begin{matrix} \dfrac{1}{4} \ \dfrac{1}{4} \ \dfrac{1}{4} \ \dfrac{1}{4} \end{matrix}\right]，<br>\left[\begin{matrix} \dfrac{9}{24} \ \dfrac{5}{24} \ \dfrac{5}{24} \ \dfrac{5}{24} \end{matrix}\right]，<br>\left[\begin{matrix} \dfrac{15}{48} \ \dfrac{11}{48} \ \dfrac{11}{48} \ \dfrac{11}{48} \end{matrix}\right]，<br>\left[\begin{matrix} \dfrac{11}{32} \ \dfrac{7}{32} \ \dfrac{7}{32} \ \dfrac{7}{32} \end{matrix}\right]，<br>\cdots，<br>\left[\begin{matrix} \dfrac{3}{9} \ \dfrac{2}{9} \ \dfrac{2}{9} \ \dfrac{2}{9} \end{matrix}\right]$$<br>最终得到平稳分布 $R$，即有向图的 PageRank 值<br>$$ R = \left[\begin{matrix} \dfrac{3}{9} \ \dfrac{2}{9} \ \dfrac{2}{9} \ \dfrac{2}{9} \end{matrix}\right] $$</p><p>同时给出 Python 程序实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Simple_PageRank</span>(<span class="params">M, tol=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculates PageRank</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        M: an n*n numpy.matrix, the stochastic matrix of a strongly connected aperiodic graph.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        R: the PageRank Vector for the graph</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = M.shape[<span class="number">0</span>]</span><br><span class="line">    R0 = np.mat(np.ones(n)).T/n</span><br><span class="line">    diff = np.mat(np.ones(n)).T</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> np.square(diff).<span class="built_in">sum</span>() &gt; tol:</span><br><span class="line">        R = M * R0</span><br><span class="line">        diff = R - R0</span><br><span class="line">        R0 = R; i+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\riter:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> R</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M = np.mat([[ <span class="number">0</span> ,<span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span> , <span class="number">0</span> ],</span><br><span class="line">            [<span class="number">1</span>/<span class="number">3</span>, <span class="number">0</span> , <span class="number">0</span> ,<span class="number">1</span>/<span class="number">2</span>],</span><br><span class="line">            [<span class="number">1</span>/<span class="number">3</span>, <span class="number">0</span> , <span class="number">0</span> ,<span class="number">1</span>/<span class="number">2</span>],</span><br><span class="line">            [<span class="number">1</span>/<span class="number">3</span>,<span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span> , <span class="number">0</span> ]])</span><br><span class="line">Simple_PageRank(M)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iter:53</span><br><span class="line">matrix([[0.33333333],</span><br><span class="line">        [0.22222222],</span><br><span class="line">        [0.22222222],</span><br><span class="line">        [0.22222222]])</span><br></pre></td></tr></table></figure><h2 id="PageRank-一般定义">PageRank 一般定义</h2><h3 id="基本定义不适用的情况">基本定义不适用的情况</h3><p>一般的有向图<strong>未必满足强连通且非周期性的条件</strong>。比如，在互联网，大部分网页没有连接出去的超链接， 也就是说从这些网页无法跳转到其他网页。所以 PageRank 的基本定义不适用。<br><img src="https://download.mariozzj.cn/img/picgo/20220331211226.png" alt="图(a')"><br>如图(a’)，结点 $C$ 没有链出，如果写出转移矩阵并进行迭代计算，会发现最终极限为全 0 向量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M = np.mat([[ <span class="number">0</span> ,<span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span> , <span class="number">0</span> ],</span><br><span class="line">            [<span class="number">1</span>/<span class="number">3</span>, <span class="number">0</span> , <span class="number">0</span> ,<span class="number">1</span>/<span class="number">2</span>],</span><br><span class="line">            [<span class="number">1</span>/<span class="number">3</span>, <span class="number">0</span> , <span class="number">0</span> ,<span class="number">1</span>/<span class="number">2</span>],</span><br><span class="line">            [<span class="number">1</span>/<span class="number">3</span>,<span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span> , <span class="number">0</span> ]])</span><br><span class="line">Simple_PageRank(M, tol=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iter:1171</span><br><span class="line">matrix([[2.15506015e-162],</span><br><span class="line">        [3.14084309e-162],</span><br><span class="line">        [3.14084309e-162],</span><br><span class="line">        [3.14084309e-162]])</span><br></pre></td></tr></table></figure><p>而这与实际不符，因此需要介绍 PageRank 的一般定义。</p><h3 id="一般定义：导入平滑项">一般定义：导入平滑项</h3><p>PageRank 一般定义的想法是在基本定义的基础上导入平滑项。<br>给定一个含有 $n$ 个结点的<strong>任意有向图</strong>，在有向图上定义一个一般的随机游走模型，即一阶马尔可夫链。一般的随机游走模型的转移矩阵由两部分的线性组合组成，一部分是<strong>有向图的基本转移矩阵 $M$</strong>， 表示从一个结点到其连出的所有结点的转移概率相等，另一部分是<strong>完全随机的转移矩阵</strong>，表示从任意一个结点到任意一个结点的转移概率都是 $\dfrac{1}{n}$，线性组合系数为阻尼因子 $d$ （$0 \le d \le 1$）。 这个一般随机游走的马尔可夫链存在平稳分布，记作 $R$。定义平稳分布向量 $R$ 为这个有向图的一般 PageRank。$R$ 由公式<br>$$ R=dMR+\dfrac{1-d}{n}\boldsymbol{1} $$<br>决定，其中 $\boldsymbol{1}$ 是所有分量为 1 的 n 维向量。</p><p>定义之中，转移矩阵由两部分组成，有向图的基本转移矩阵包含了有向图的结构，随机游走者依据有向图的边进行随机游走，而另一部分，即完全随机的转移矩阵，表示随机游走者有一定概率（概率为 $1-d$，一般根据经验参数取值 $d=0.85$）等几率跳到图上任意一个结点（跳转到任意一个结点的概率都为 $\dfrac{1}{n}$）</p><p>在一般 PageRank 定义下，互联网浏览者能按照以下方法在网上随机游走：在任意一个网页上，浏览者<strong>以概率 $d$ 决定按照超链接随机跳转</strong>（以等概率从连接出去的超链接跳转到下一个网页），或者<strong>以概率 $(1-d)$ 决定完全随机跳转</strong>（以等概率 $\dfrac{1}{n}$ 跳转到任意一个网页）。<strong>第二个机制就保证了从没有连接出去的超链接网页也可以跳转出</strong>。这样可以保证平稳分布，即一般 PageRank 值（马尔科夫链的平稳分布）的存在，因而一般 PageRank 可以适用于任意有向图。</p><h3 id="在一般有向图上求解-PageRank">在一般有向图上求解 PageRank</h3><p><img src="https://download.mariozzj.cn/img/picgo/20220331230233.png" alt="图(e)"><br>以图(e)为例，取 $d=0.8$，求解 PageRank：<br>由图可以写出转移矩阵<br>$$ M = [m_{ij}]<em>{n \times n} = \left[\begin{matrix} 0 &amp;\dfrac{1}{2} &amp;0 &amp;0 \ \dfrac{1}{3} &amp;0 &amp;0 &amp;\dfrac{1}{2} \ \dfrac{1}{3} &amp;0 &amp;1 &amp;\dfrac{1}{2} \ \dfrac{1}{3} &amp;\dfrac{1}{2} &amp;0 &amp;0  \end{matrix}\right] $$<br>计算出转移矩阵的两部分<br>$$ dM=\dfrac{4}{5} \times \left[\begin{matrix} 0 &amp;\dfrac{1}{2} &amp;0 &amp;0 \ \dfrac{1}{3} &amp;0 &amp;0 &amp;\dfrac{1}{2} \ \dfrac{1}{3} &amp;0 &amp;1 &amp;\dfrac{1}{2} \ \dfrac{1}{3} &amp;\dfrac{1}{2} &amp;0 &amp;0  \end{matrix}\right] = \left[\begin{matrix} 0 &amp;\dfrac{2}{5} &amp;0 &amp;0 \ \dfrac{4}{15} &amp;0 &amp;0 &amp;\dfrac{2}{5} \ \dfrac{4}{15} &amp;0 &amp;\dfrac{4}{5} &amp;\dfrac{2}{5} \ \dfrac{4}{15} &amp;\dfrac{2}{5} &amp;0 &amp;0  \end{matrix}\right] $$<br>$$ \dfrac{1-d}{n} \boldsymbol{1} = \left[\begin{matrix} \dfrac{1}{20} \ \dfrac{1}{20} \ \dfrac{1}{20} \ \dfrac{1}{20} \end{matrix}\right] $$<br>迭代公式为<br>$$ R</em>{t+1} = \left[\begin{matrix} 0 &amp;\dfrac{2}{5} &amp;0 &amp;0 \ \dfrac{4}{15} &amp;0 &amp;0 &amp;\dfrac{2}{5} \ \dfrac{4}{15} &amp;0 &amp;\dfrac{4}{5} &amp;\dfrac{2}{5} \ \dfrac{4}{15} &amp;\dfrac{2}{5} &amp;0 &amp;0  \end{matrix}\right] R_t + \left[\begin{matrix} \dfrac{1}{20} \ \dfrac{1}{20} \ \dfrac{1}{20} \ \dfrac{1}{20} \end{matrix}\right] $$<br>我们知道，初始分布向量<br>$$ R_0 = \left[\begin{matrix} \dfrac{1}{4} \ \dfrac{1}{4} \ \dfrac{1}{4} \ \dfrac{1}{4} \end{matrix}\right] $$<br>得到向量序列<br>$$ \left[\begin{matrix} \dfrac{1}{4} \ \dfrac{1}{4} \ \dfrac{1}{4} \ \dfrac{1}{4} \end{matrix}\right]，<br>\left[\begin{matrix} \dfrac{9}{60} \ \dfrac{13}{60} \ \dfrac{25}{60} \ \dfrac{13}{60} \end{matrix}\right]，<br>\left[\begin{matrix} \dfrac{41}{300} \ \dfrac{53}{300} \ \dfrac{153}{300} \ \dfrac{53}{300} \end{matrix}\right]，<br>\left[\begin{matrix} \dfrac{543}{4500} \ \dfrac{707}{4500} \ \dfrac{2543}{4500} \ \dfrac{707}{4500} \end{matrix}\right]，<br>\cdots，<br>\left[\begin{matrix} \dfrac{15}{148} \ \dfrac{19}{148} \ \dfrac{95}{148} \ \dfrac{19}{148} \end{matrix}\right]$$<br>最终得到平稳分布<br>$$ R = \left[\begin{matrix} \dfrac{15}{148} \ \dfrac{19}{148} \ \dfrac{95}{148} \ \dfrac{19}{148} \end{matrix}\right] $$<br>同时给出 Python 程序实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PageRank</span>(<span class="params">M, d=<span class="number">0.85</span>, tol=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculates PageRank with smoothing</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        M: an n*n numpy.matrix, the stochastic matrix of a strongly connected aperiodic graph.</span></span><br><span class="line"><span class="string">        d: the probability of walking on the edges</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        R: the PageRank Vector for the graph</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = M.shape[<span class="number">0</span>]</span><br><span class="line">    R0 = np.mat(np.ones(n)).T/n</span><br><span class="line">    Ones = np.mat(np.ones(n)).T</span><br><span class="line">    diff = np.mat(np.ones(n)).T</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> np.square(diff).<span class="built_in">sum</span>() &gt; tol:</span><br><span class="line">        R = d * M * R0 + ((<span class="number">1</span>-d)/n) * Ones</span><br><span class="line">        diff = R - R0</span><br><span class="line">        R0 = R; i+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\riter:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> R</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M = np.mat([[ <span class="number">0</span> ,<span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span> , <span class="number">0</span> ],</span><br><span class="line">            [<span class="number">1</span>/<span class="number">3</span>, <span class="number">0</span> , <span class="number">0</span> ,<span class="number">1</span>/<span class="number">2</span>],</span><br><span class="line">            [<span class="number">1</span>/<span class="number">3</span>, <span class="number">0</span> , <span class="number">1</span> ,<span class="number">1</span>/<span class="number">2</span>],</span><br><span class="line">            [<span class="number">1</span>/<span class="number">3</span>,<span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span> , <span class="number">0</span> ]])</span><br><span class="line">PageRank(M, d=<span class="number">0.8</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iter:69</span><br><span class="line">matrix([[0.10135135],</span><br><span class="line">        [0.12837838],</span><br><span class="line">        [0.64189189],</span><br><span class="line">        [0.12837838]])</span><br></pre></td></tr></table></figure><h1>EigenFactor</h1><p>EigenFactor，一说译作“特征因子”[^3]，于 2006 年由  West Bergstorm 等提出，类似于 PageRank 在网页和超链接构成的有向图中计算网页影响力，EigenFactor 一般在期刊和引用关系构成的有向图中计算期刊影响力。理解 PageRank 原理有助于我们理解 EigenFactor 的计算原理。</p><h2 id="基本理解-2">基本理解</h2><p>在研读文献时，文献本身可能会对参考的文献进行引用，我们作为读者就有可能阅读文献的参考文献。而参考文献一般与当前文献不位于同一本期刊上，我们就需要去阅读另一本期刊。这样的一种从期刊到期刊的跳转就类似于 PageRank 中网页到网页的跳转，根据引用关系构成的拓扑结构，以及 EigenFactor 加入的期刊载文量信息，就可以迭代计算出期刊的影响力。</p><h2 id="计算方法">计算方法</h2><p>给定一个包含 $n$ 个期刊结点的有向图，在有向图上定义<strong>随机游走模型</strong>，即一阶马尔可夫链。该随机游走模型的转移矩阵由两部分的线性组合组成，一部分是<strong>修正引文量加权转移矩阵 $\boldsymbol{H’}$</strong>，表示从一个期刊结点到其连出的其他期刊结点的转移概率，另一部分是<strong>载文量加权转移矩阵 $A$</strong>，表示从任意一个期刊结点到任意一个期刊结点的转移概率（由载文量向量 $a$ 拓展而来），线性组合系数为阻尼因子 $\alpha$ （$0 \le \alpha \le 1$）。该随机游走的马尔可夫链存在平稳分布，记作 $\pi^\star$。$\pi^\star$ 由公式<br>$$ \pi^\star = \alpha \boldsymbol{H’}\pi^\star + (1-\alpha)a $$<br>决定。平稳分布向量 $\pi^\star$ 和引文量加权转移矩阵 $\boldsymbol{H}$ 可以计算得出期刊特征因子向量<br>$$ \boldsymbol{EF} = 100\dfrac{\boldsymbol{H}\pi^\star}{\sum\limits_{i=1}^n [\boldsymbol H \pi^\star]_i} $$<br>和各期刊的论文影响分值<br>$$AI_i = 0.01 \dfrac{\boldsymbol{EF}_i}{a_i}$$</p><h3 id="载文量加权转移矩阵">载文量加权转移矩阵</h3><p>载文量加权转移矩阵 $\boldsymbol{A}$ 由引文量向量 $a$ 乘以 全 1 行向量得来。<br>$$ \boldsymbol{A} = ae^{T} $$<br>其中引文量向量 $a$ 各行为归一化处理后的过去五年各期刊的载文量（$\sum\limits_{i=1}^na_i =1$）。</p><p>所以，$\boldsymbol{A}$ 每列的每行都相等，为基于载文量的概率，这与 PageRank 的全 1 向量不同。</p><h3 id="引文量加权转移矩阵">引文量加权转移矩阵</h3><p>根据引文关系，我们可以先确定五年交叉引用矩阵 $\boldsymbol{Z}$，该矩阵是一个 $n$ 阶矩阵，第 $i$ 行第 $j$ 列元素 $z_{ij}$ 取值规则是：某年期刊 $j$ 发表的文章中，共计引用期刊 $i$ 在过去五年内发表的文章的次数。在构建该矩阵时，忽略所有的期刊自引，也就是说 $\boldsymbol{Z}$ 的对角值都为 0。随后，对每一列做归一化处理，此时每列就可以代表阅读期刊时跳转到其他期刊的概率，得到<strong>引文量加权转移矩阵</strong> $\boldsymbol{H}$：<br>$$ \boldsymbol{H}<em>{ij} = \dfrac{\boldsymbol{Z}</em>{ij}}{\sum\limits_{k=1}^n\boldsymbol{Z}<em>{kj}} $$<br>因为计算时忽略了所有的自引，就有可能存在窗口期内某期刊并未引用集合内期刊的情况，即该结点为悬挂结点，矩阵某一列都为 0，类似于之前图(a’)中结点 C 存在向外连边的情况。为了修正该问题，我们用载文量向量 $a$ 替换全 0 向量，得到<strong>修正引文量加权转移矩阵 $\boldsymbol{H’}$</strong>。其中，引文量向量 $a$ 的各行为归一化处理后的过去五年各期刊的载文量（$\sum\limits</em>{i=1}^na_i =1$）。</p><h3 id="理解-EigenFactor">理解 EigenFactor</h3><p>定义之中，转移矩阵由两部分组成，修正引文量加权转移矩阵包含了引文结构和引文量，读者<strong>有一定概率（概率为 $\alpha$）依据有向图的边及权重进行游走</strong>（边权重由引文量决定，如无引文量，由载文量决定），而另一部分，即载文量加权转移矩阵，表示读者<strong>有一定概率（概率为 $1-\alpha$）跳到图上任意一个结点</strong>（跳转到任意一个结点的概率和结点过去五年载文量成正比）。载文量加权矩阵保证了从没有引用的期刊也可以跳转出。</p><p>相比于 PageRank 在计算基本转移矩阵和随机转移矩阵时，对所有的边和结点赋予相同的权重，<strong>EigenFactor 会考虑期刊的载文量和引文量，并赋予结点和边不同的概率权重</strong>，能够在一定程度上更合理评价期刊的影响力。</p><h2 id="计算案例">计算案例</h2><p><img src="https://download.mariozzj.cn/img/picgo/202204010155388.png" alt="图(e')"><br>以图(e)为例，边上的数字为当年引文量，圈内的数字为五年载文量，取 $\alpha=0.8$，求解 EigenFactor 和 Artical Influence Score：<br>由图可以写出载文量向量、引文量加权向量、修正引文量加权向量<br>$$ a=\left[\begin{matrix}\dfrac{4}{20} \ \dfrac{8}{20} \ \dfrac{2}{20} \ \dfrac{6}{20}\end{matrix}\right]，\boldsymbol{H}= \left[\begin{matrix} 0 &amp;\dfrac{5}{6} &amp;0 &amp;0 \ \dfrac{2}{6} &amp;0 &amp;0 &amp;\dfrac{2}{6} \ \dfrac{3}{6} &amp;0 &amp;0 &amp;\dfrac{4}{6} \ \dfrac{1}{6} &amp;\dfrac{1}{6} &amp;0 &amp;0  \end{matrix}\right]，\boldsymbol{H’}= \left[\begin{matrix} 0 &amp;\dfrac{5}{6} &amp;\dfrac{4}{20} &amp;0 \ \dfrac{2}{6} &amp;0 &amp;\dfrac{8}{20} &amp;\dfrac{2}{6} \ \dfrac{3}{6} &amp;0 &amp;\dfrac{2}{20} &amp;\dfrac{4}{6} \ \dfrac{1}{6} &amp;\dfrac{1}{6} &amp;\dfrac{6}{20} &amp;0  \end{matrix}\right] $$<br>迭代公式为<br>$$ \pi_{t+1} = \left[\begin{matrix} 0 &amp;\dfrac{2}{3} &amp;\dfrac{4}{25} &amp;0 \ \dfrac{4}{15} &amp;0 &amp;\dfrac{8}{25} &amp;\dfrac{4}{15} \ \dfrac{2}{5} &amp;0 &amp;\dfrac{2}{25} &amp;\dfrac{8}{15} \ \dfrac{2}{15} &amp;\dfrac{2}{15} &amp;\dfrac{6}{25} &amp;0  \end{matrix}\right] \pi_t + \left[\begin{matrix} \dfrac{1}{25} \ \dfrac{2}{25} \ \dfrac{1}{50} \ \dfrac{3}{50} \end{matrix}\right] $$<br>后续计算过程略。</p><p>同时给出 Python 程序实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">EigenFactor</span>(<span class="params">H, article_vec,d=<span class="number">0.85</span>, tol=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculates EigenFactor</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        H: the stochastic matric, an n*n numpy.matrix</span></span><br><span class="line"><span class="string">        article_vec: the normalized article vector, list</span></span><br><span class="line"><span class="string">        d: the probability of walking on the edges</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        EF: the EigenFactor Score of Journal list</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = H.shape[<span class="number">0</span>]</span><br><span class="line">    Hs = ((<span class="number">1</span> - H.<span class="built_in">sum</span>(axis=<span class="number">0</span>).T) * article_vec).T + H</span><br><span class="line">    pi0 = np.mat(np.ones(n)).T/n</span><br><span class="line">    a = np.mat(article_vec).T</span><br><span class="line">    diff = np.mat(np.ones(n)).T</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> np.square(diff).<span class="built_in">sum</span>() &gt; tol:</span><br><span class="line">        pi = d * Hs * pi0 + ((<span class="number">1</span>-d)) * a</span><br><span class="line">        diff = pi - pi0</span><br><span class="line">        pi0 = pi; i+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\riter:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    EF = (H*pi/(H*pi).<span class="built_in">sum</span>())*<span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> EF</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ArticleInfluenceScore</span>(<span class="params">EF, article_vec</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculates Article Influence Score</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        EF: EigenFactor Vector, n*1 numpy.matrix</span></span><br><span class="line"><span class="string">        article_vec: the normalized article vector, list</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        AIS: the Article Influence Score Score of Journal list</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    AIS = <span class="number">0.01</span> * np.multiply(EF,<span class="number">1</span>/np.mat(article_vec).T)</span><br><span class="line">    <span class="keyword">return</span> AIS</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">H =   np.mat([[ <span class="number">0</span> ,<span class="number">5</span>/<span class="number">6</span>, <span class="number">0</span>  , <span class="number">0</span>  ],</span><br><span class="line">              [<span class="number">1</span>/<span class="number">3</span>, <span class="number">0</span> , <span class="number">0</span>  ,<span class="number">1</span>/<span class="number">3</span> ],</span><br><span class="line">              [<span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span> , <span class="number">0</span>  ,<span class="number">2</span>/<span class="number">3</span> ],</span><br><span class="line">              [<span class="number">1</span>/<span class="number">6</span>,<span class="number">1</span>/<span class="number">6</span>, <span class="number">0</span>  , <span class="number">0</span>  ]])</span><br><span class="line">article_vec = [<span class="number">1</span>/<span class="number">5</span>,<span class="number">2</span>/<span class="number">5</span>,<span class="number">1</span>/<span class="number">10</span>,<span class="number">3</span>/<span class="number">10</span>]</span><br><span class="line">EF = EigenFactor(H, article_vec,d=<span class="number">0.8</span>)</span><br><span class="line">display(EF)</span><br><span class="line">AIS = ArticleInfluenceScore(EF, article_vec)</span><br><span class="line">display(AIS)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iter:38</span><br><span class="line">matrix([[31.65677392],</span><br><span class="line">        [20.67062376],</span><br><span class="line">        [35.33270853],</span><br><span class="line">        [12.33989378]]) # EigenFactor Score</span><br><span class="line">matrix([[1.5828387 ],</span><br><span class="line">        [0.51676559],</span><br><span class="line">        [3.53327085],</span><br><span class="line">        [0.41132979]])  # ArticleInfluence Score</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数科知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PageRank </tag>
            
            <tag> EigenFactor </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转服务器 | 使用 frp 实现内网穿透</title>
      <link href="/posts/9364d192/"/>
      <url>/posts/9364d192/</url>
      
        <content type="html"><![CDATA[<h1>内网穿透</h1><h2 id="基础理解">基础理解</h2><p>内网穿透能够使仅可被内网访问的服务被公网上的设备访问到。</p><p>举个例子，当我需要使用学校实验室的服务器，只能通过使我的电脑连接到学校的网络（与服务器处于同一局域网），再通过局域网下的 IP 地址（内网地址）访问服务器；而当我的电脑和服务器不处于同一局域网时，我便无法连接到服务器。通过内网穿透的方式，我便可以通过一些中介将我的请求转发给服务器，达到和服务器近似处于同一局域网的效果。</p><p>再举个例子，在我的家中有一台主机一直开机，硬盘上存放着一些影视资源。由于默认情况下，我们使用的是 ISP 分配的随机 IP 地址，家中主机的 IP 地址不固定，在外我也就无法和家中的主机建立稳定联系，获取这些影视资源。而通过内网穿透，我便可以通过一些中介进入家庭内网，访问硬盘资源，甚至可以建立 P2P 连接。</p><h2 id="条件支持">条件支持</h2><p>其实有很多服务商提供内网穿透服务，如 <a href="https://hsk.oray.com/">花生壳</a>，在此不赘述。本文将通过自购服务器及 FRP 软件搭建内网穿透服务。所以需要的前提条件是：</p><ol><li>存在具体的内网穿透的需求（如游戏联机、NAS 布置、SSH 访问等）</li><li>拥有一台具有固定 IP 地址的服务器</li><li>在需要被访问的内网拥有可以稳定在线的设备</li><li>内网（局域网）本身可以连接到互联网</li></ol><h1>Frp</h1><p>Frp 本质上是一个反向代理软件，基于 Go 语言，开源免费，支持多种协议，支持多种类型的终端，可以访问 <a href="https://github.com/fatedier/frp">Frp 仓库页面</a> 查看详情。Frp 服务分为服务端（Frps）和客户端（Frpc），分别需要安装在公网 IP 主机上、内网终端/访问端上。本文将使用腾讯云服务器（Lighthouse，Ubuntu 20.04）作为公网服务器，安卓手机（Mi 8，Android 8）作为内网终端搭建 Frp 服务。</p><h2 id="安装">安装</h2><p>Frp 基于 Go 语言，需要先安装好环境，可以参照 <a href="https://go.dev/doc/install#requirements">Download &amp; Install Golang</a> 页面说明配置。对于 Linux 服务器，可以下载 Go，并解压放至 <code>/usr/local/go</code> 文件夹，并添加环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://go.dev/dl/go1.17.8.linux-amd64.tar.gz</span><br><span class="line">rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.17.8.linux-amd64.tar.gz</span><br><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure><p>随后，进入 <a href="https://github.com/fatedier/frp/releases">Releases · fatedier/frp</a> 页面，选择部署终端对应的安装包并下载，如 Ubuntu 系统的服务器下载 <code>frp_0.38.0_linux_amd64.tar.gz</code>。随后将其解压到任意位置即可。对于 Android 设备，可以进入 <a href="https://github.com/HaidyCao/frp/releases/">Releases · HaidyCao/frp</a> 直接下载 apk 安装包安装即可。</p><h2 id="配置">配置</h2><p>进入解压的文件夹，可以看到 <code>frpc</code>、<code>frps</code> 及对应的配置文件 <code>frpc.ini</code>、<code>frps.ini</code>。服务端（公网 ip 设备）运行 <code>frps</code>，修改 <code>frps.ini</code> 配置文件；客户端（内网设备、访问设备）运行 <code>frpc</code>，修改 <code>frpc.ini</code> 配置文件。</p><p><img src="https://download.mariozzj.cn/img/picgo/20220311193827.png" alt="frps 文件夹"></p><p>无论是 <code>frps.ini</code> 还是 <code>frpc.ini</code>，配置文件格式都类似于如下形式：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[&lt;配置服务名&gt;]</span></span><br><span class="line">&lt;参数名&gt; = &lt;参数值&gt;</span><br><span class="line">&lt;参数名&gt; = &lt;参数值&gt;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h2 id="启动">启动</h2><p>编辑完配置文件后，先通过 <code>./frps -c ./frps.ini</code> 启动服务端，再通过 <code>./frpc -c ./frpc.ini</code> 启动客户端。即使是在 Windows 上，也需要在 <code>cmd.exe</code> 终端中执行命令运行。</p><p>对于 Android 端，编辑配置文件后，直接点击右下角图标运行即可。</p><h1>Frp 配置实例</h1><p>下面对特定应用场景举例修改 Frp 的配置文件，更多配置可以参考 <a href="https://gofrp.org/docs/examples/">frp中文文档示例</a> 和 <a href="https://github.com/fatedier/frp/blob/dev/README.md">frp官方文档</a></p><h2 id="例：ssh-访问内网机器">例：ssh 访问内网机器</h2><p>修改服务端配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure><ul><li><code>bind_port</code> 的端口用于监听客户端连接请求。<u>（需在服务器防火墙放行）</u></li></ul><p>修改客户端配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><ul><li><code>server_addr</code> 填入服务端主机的公网 ip</li><li><code>server_port</code> 填入刚才填入的监听端口</li><li><code>local_ip</code> 填入在内网需要访问主机的 ip 地址（可以是局域网地址），如果是本机则填入 <code>127.0.0.1</code></li><li><code>remote_port</code> 填入服务端监听 ssh 请求的端口，访问该端口的请求会被转发到局域网的 <code>&lt;local_ip&gt;:&lt;local_port&gt;</code>。<u>（需在服务器防火墙放行）</u></li></ul><p>启动服务后，执行如下命令即可访问局域网主机，frp 会将请求转发至局域网的 <code>&lt;local_ip&gt;:&lt;local_port&gt;</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -oPort=&lt;remote_port&gt; &lt;username&gt;@&lt;server_addr&gt;</span><br></pre></td></tr></table></figure><h2 id="例：通过域名访问内网-Web-服务">例：通过域名访问内网 Web 服务</h2><p>修改服务端配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">8080</span></span><br></pre></td></tr></table></figure><ul><li><code>vhost_http_port</code> 的端口用于监听来自外网的 http 请求。<u>（需在服务器防火墙放行）</u></li></ul><p>修改客户端配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[xxxx]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">80</span></span><br><span class="line"><span class="attr">custom_domains</span> = www.xxxxxx.com</span><br><span class="line"></span><br><span class="line"><span class="section">[xxxx]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">9090</span></span><br><span class="line"><span class="attr">custom_domains</span> = www.xxxxxx.com</span><br></pre></td></tr></table></figure><ul><li>每项 web 服务单独配置即可；</li><li><code>custom_domain</code> 处填写需在外网访问该应用的域名（该域名需要解析到服务端 ip 地址）。</li></ul><p>其他设备访问 <code>http://&lt;custom_domain&gt;:&lt;vhost_http_port&gt;</code>，即可访问到局域网 <code>http://&lt;local_ip&gt;:&lt;local_port&gt;</code> 的 Web 应用。</p><h2 id="例：P2P-内网穿透">例：P2P 内网穿透</h2><p>大多数情况下，服务端服务器将转发所有内网客户端和外网机器的流量，假设我从 PC 向局域网主机上传一个 100M 的文件，那么这个文件的包会首先经过服务端，再转发给客户端，将消耗服务端服务器的 200M 流量，如果这样的任务较多，对中转服务器的带宽和流量将带来不必要的占用。此时可以采用 frp 的 P2P 配置，服务端仅用于建立外网主机和局域网主机的联系，随后流量仅在外网主机和局域网主机点对点传输。</p><p>要想以该方式进行内网穿透，<strong>额外要求外网连接的机器也部署 frpc</strong>，安装过程同上。</p><p>修改服务端配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">bind_udp_port</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure><ul><li><code>bind_udp_port</code> 用于监听两边客户端（局域网主机、外网访问机）的 UDP 请求，并建立之后的联系。<u>（需在服务器防火墙放行）</u></li></ul><p>修改客户端（局域网主机）配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[p2p_ssh1]</span></span><br><span class="line"><span class="attr">type</span> = xtcp</span><br><span class="line"><span class="attr">sk</span> = secretkey</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure><ul><li><code>sk</code> 为验证字串，只有验证一致的用户才能访问该服务。</li></ul><p>修改客户端（外网访问机）的配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[p2pssh1_visitor]</span></span><br><span class="line"><span class="attr">type</span> = xtcp</span><br><span class="line"><span class="attr">role</span> = visitor</span><br><span class="line"><span class="attr">server_name</span> = p2p_ssh1</span><br><span class="line"><span class="attr">sk</span> = secretkey</span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><ul><li><code>server_name</code> 填入在局域网客户端已配置的应用名</li><li><code>bind_addr</code> 和 <code>bind_port</code> 分别填入本机绑定的 ip 地址和端口，用于访问 ssh 服务。</li></ul><p>启动服务后，执行如下命令即可访问局域网主机，frp 会将请求转发至局域网的 <code>&lt;local_ip&gt;:&lt;local_port&gt;</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -oPort=&lt;bind_port&gt; &lt;username&gt;@&lt;bind_addr&gt;</span><br></pre></td></tr></table></figure><h2 id="例：配置服务端看板">例：配置服务端看板</h2><p>frp 自带一个看板，提供查看服务端配置、连接情况的服务。只需在服务端看板添加如下配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 其他配置略</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"><span class="attr">dashboard_user</span> = username</span><br><span class="line"><span class="attr">dashboard_pwd</span> = password</span><br></pre></td></tr></table></figure><ul><li><code>dashboard_port</code> 端口用于监听访问看板服务的 http 请求。<u>（需在服务器防火墙放行）</u></li><li><code>dashboard_user</code>、<code>dashboard_pwd</code> 配置登录看板的用户名和密码。</li></ul><p>启用后，访问 <code>http://&lt;server_addr&gt;:&lt;dashboard_port&gt;</code> 即可查看服务端看板。</p><p><img src="https://download.mariozzj.cn/img/picgo/202203112113888.png" alt="服务端看板"></p><h2 id="例：配置客户端管理面板">例：配置客户端管理面板</h2><p>frps 也提供管理客户端配置的 web 服务。修改客户端配置文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 其他配置略</span></span><br><span class="line"><span class="attr">admin_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">admin_port</span> = <span class="number">7400</span></span><br><span class="line"><span class="attr">admin_user</span> = admin</span><br><span class="line"><span class="attr">admin_pwd</span> = admin</span><br></pre></td></tr></table></figure><p><img src="https://download.mariozzj.cn/img/picgo/202203112119960.png" alt="客户端管理页面"></p><p>启用后，访问 <code>http://&lt;admin_addr&gt;:&lt;admin_port&gt;</code> 即可查看服务端看板。服务端看板可以实时修改客户端配置并热启动。</p>]]></content>
      
      
      <categories>
          
          <category> 玩转服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务器应用 </tag>
            
            <tag> frp </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转服务器 | Web 应用部署上线全流程（Ubuntu + Nginx + MySQL + Flask）</title>
      <link href="/posts/7f568f00/"/>
      <url>/posts/7f568f00/</url>
      
        <content type="html"><![CDATA[<p>你可能听过 LAMP / LNMP，这是搭建动态 Web 应用的常见环境组合，实质上是 Linux（系统）+ Apache / Nginx（Web 服务器） + MySQL（数据库）+ PHP（编程语言）环境的统称，这套组合较为流行，能够组合解决 Web 应用部署问题。</p><p>当我们在 PC 上完成 Web 应用的开发，想要利用服务器发布到互联网上供更多人访问时，需要先完成服务器软件环境的准备，大体上就可以按照 LNMP 的思路进行：</p><h1>服务器系统安装：Ubuntu</h1><p>见 <a href="https://blog.mariozzj.cn/posts/75521d8e/#%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85">玩转服务器 | 购置自己的第一台服务器 | MarioZZJ’s blog</a></p><p>后续教程也以 Ubuntu 系统为例</p><h1>Web 服务器安装：Nginx</h1><p>这里我们安装 Nginx，后续教程也利用 Nginx 展开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt install nginx -y</span></span><br></pre></td></tr></table></figure><p>安装后，执行 <code>nginx -v</code> 查看 Nginx 版本，如正确打印版本则安装成功。</p><p>然后设置防火墙，以使得 Nginx 服务可以通过防火墙，这里以 ufw 为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw allow <span class="string">&#x27;Nginx Full&#x27;</span></span></span><br></pre></td></tr></table></figure><p>最后设置开机启动 Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> nginx</span></span><br></pre></td></tr></table></figure><h1>数据库服务安装：MySQL</h1><p>如果 Web 项目需要用到数据库，在服务器上安装同版本数据库即可，下面以 MySQL 为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt install mysql-server -y</span></span><br></pre></td></tr></table></figure><p>安装完成后，查看服务状态检验是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl status mysql</span></span><br><span class="line"></span><br><span class="line">● mysql.service - MySQL Community Server</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Sat 2022-02-19 12:31:43 CST; 3min 28s ago</span><br><span class="line">   Main PID: 592500 (mysqld)</span><br><span class="line">     Status: &quot;Server is operational&quot;</span><br><span class="line">      Tasks: 38 (limit: 4603)</span><br><span class="line">     Memory: 358.1M</span><br><span class="line">     CGroup: /system.slice/mysql.service</span><br><span class="line">             └─592500 /usr/sbin/mysqld</span><br></pre></td></tr></table></figure><p>随后，我们配置防火墙，让 MySQL 服务通过防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw allow mysql</span></span><br></pre></td></tr></table></figure><p>完成后，我们运行 MySQL 的安全脚本，完成安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mysql_secure_installation</span></span><br></pre></td></tr></table></figure><p>这里主要是一些配置的设置，其中包括密码设置、远程访问许可等。如果允许了远程访问并打开了防火墙端口，后续可以在 PC 上直接使用数据库管理软件远程连接访问。</p><p>安装完成后，配置开机启动 MySQL 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable mysql</span><br></pre></td></tr></table></figure><h1>编程语言环境安装：Python</h1><p>服务器应当安装与原 Web 应用开发环境相同的编程语言环境。</p><h2 id="安装语言环境">安装语言环境</h2><p>这里以 Python 为例完成安装，Ubuntu 安装时自带 Python，如需安装可执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt install python</span></span><br></pre></td></tr></table></figure><h2 id="安装项目依赖">安装项目依赖</h2><p>在本地项目根目录打开终端，键入命令，生成 <code>requirements.txt</code> 依赖文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip freeze &gt; ./requirements.txt</span></span><br></pre></td></tr></table></figure><p><code>requirements.txt</code> 的形式如下，揭示项目需要依赖的第三方库及其版本。</p><p>随后我们可以将整个项目复制到服务器我们指定的目录下，可以用 Git、XFtp、SCP 等方式，在服务器的项目目录下执行命令，可按照 <code>requirements.txt</code> 安装依赖的包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install -r ./requirements.txt</span></span><br></pre></td></tr></table></figure><h1>服务启动：Flask</h1><h2 id="启动-Web-应用服务：调试方式">启动 Web 应用服务：调试方式</h2><p>以 Python 常用 Web 框架 Flask 为例，在本地调试环境下，我们一般通过运行根目录下的 <code>app.py</code> 启动服务。在服务器这边，我们也可以使用命令启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python app.py</span></span><br><span class="line"> * Serving Flask app &#x27;app&#x27; (lazy loading)</span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: This is a development server. Do not use it in a production deployment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: off</span><br><span class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>根据提示，服务在服务器上是成功启动了。但是要想通过像在本地调试一样，在互联网上发布 Web 应用并通过公网访问，还需要几步调整。</p><h2 id="监听外部网络-IP">监听外部网络 IP</h2><p>根据提示输出 <code> Running on http://127.0.0.1:5000/</code> 可知，Flask 服务仅仅可以在本地服务器地址 127.0.0.1 访问。当我们开发项目调试时，访问项目的就是本机，本机能够正常访问；而目前这个状态下，只有服务器自己能访问，其他设备作为外网设备并不能访问服务。解决的方法是修改对应的 <code>host</code> 参数，将其指定为 <code>0.0.0.0</code>，这样系统就会监听任意 IP 地址而不仅仅是本机。</p><p>体现在 Flask 框架脚本代码中，修改 <code>run()</code> 方法，将</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run()</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="防火墙放行端口">防火墙放行端口</h2><p>目前我们还没有绑定域名，需要通过服务启动时指定的端口访问，而服务器防火墙不一定放行了指定的端口。以 ufw 为例，放行该项目的 <code>5000</code> 端口，执行下述命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw delete allow 5000</span></span><br><span class="line">Rule deleted</span><br><span class="line">Rule deleted (v6)</span><br></pre></td></tr></table></figure><p>放行端口，监听所有 IP 均设置好后，再次启动项目，我们就可以在浏览器中输入 <code>http://&lt;ip地址&gt;:&lt;端口号&gt;</code> 访问项目：</p><p><img src="https://download.mariozzj.cn/img/picgo/202202210019746.png" alt="公网访问项目"></p><h2 id="Gunicorn-启动">Gunicorn 启动</h2><p>最开始的提示信息中，有两行这样的信息：</p><blockquote><p>WARNING: This is a development server.</p><p>Do not use it in a production deployment.  Use a production WSGI server instead.</p></blockquote><p>意思是这样的启动方式仅供调试使用，生产环境下，建议使用 WSGI 服务。这是因为 Flask 自带的 WSGI 性能一般，只用于调试（但是足够应付少量访问），我们可以使用 Gunicorn 方式启动服务。</p><p>首先安装 <code>gunicorn</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install gunicorn</span></span><br></pre></td></tr></table></figure><p>然后使用 gunicorn 命令启动，首先了解 gunicorn 命令常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c CONFIG, --config=CONFIG</span><br><span class="line"># 设定配置文件。</span><br><span class="line">-b BIND, --bind=BIND</span><br><span class="line"># 设定服务需要绑定的端口。建议使用HOST:PORT。</span><br><span class="line">-w WORKERS, --workers=WORKERS</span><br><span class="line"># 设置工作进程数。建议服务器每一个核心可以设置2-4个。</span><br><span class="line">-k MODULE</span><br><span class="line"># 选定异步工作方式使用的模块。</span><br></pre></td></tr></table></figure><p>随后在项目根目录，执行类似下面的命令即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gunicorn -w 3 -b 0.0.0.0:5000 app:app</span><br><span class="line"># 此处app:app中，第一个app为flask项目实例所在的包，第二个app为生成的flask项目实例</span><br></pre></td></tr></table></figure><h2 id="后台启动、开机自启">后台启动、开机自启</h2><p>事实上，远程通过上述方式启动的服务进程，需要保持远程终端连接，否则当连接断开（长时间未交互、网络不通畅等情况），进程可能被终止，Web 应用无法提供持续性服务。</p><p>所以，如果我们想让我们的 Web 应用稳定地在服务器上运行，应当使用后台运行的方式。具体方法很多，如 <code>nohup</code>、<code>screen</code>、<code>tmux</code> 等命令。这里以 <code>nohup</code> 为例，在命令前添加 <code>nohup</code> 即可让命令后台执行。为保存运行日志，在命令尾端也添加输出重定向符号 <code>&gt;</code>，将原本打印到屏幕的输出重定向至我们指定的文件；最后加 <code>&amp;</code> 让我们可以继续与该终端交互：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> gunicorn -w 3 -b 0.0.0.0:5000 app:app &gt; runtest.log &amp;</span></span><br><span class="line">[1] 387135</span><br></pre></td></tr></table></figure><p>当我们确认 Web 应用在服务器上正常运行，想要之后稳定地提供服务，可以将命令设为开机启动，这样如果服务器出现需要重启的情况，系统重新启动后也会自动启动 Web 应用，不用繁复操作。具体方法是编辑 <code>/etc/rc.local</code>，在文件结尾追加需要开机时启动的命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/rc.local</span><br></pre></td></tr></table></figure><p>需要注意，<code>rc.local</code> 执行命令的用户是 <code>root</code>，目录不是项目根目录，所以贴入的脚本需要调整，例如，我贴入的是 <code>nohup gunicorn --chdir /home/mariozzj/github/COS-Viewer -w 6 -b 0.0.0.0:5000 app:app &gt; /home/mariozzj/github/COS-Viewer/runtest.log &amp;</code>（更改了执行地址），同时 <code>root</code> 账户安装了对应的依赖。</p><p>完成之后，每次重启服务器，我们都无需单独去启动 Web 项目，服务器会根据 <code>rc.local</code> 开机自动执行脚本。</p><h1>绑定域名</h1><p>完成上述步骤，只要拥有 ip 地址、端口号，网络上的其他人就能够使用我们 Web 应用提供的服务了。但是要求其他人记住无规则的 ip 地址和端口号较为困难，所以我们还可以将一个容易识记的域名绑定到我们的服务上来，让其他人仅输入域名即可访问我们的服务。</p><h2 id="购买域名">购买域名</h2><p>我们可以前往我们购买云服务器的服务商处（也可选择其他服务商）购买域名，以腾讯云为例，进入 <a href="https://dnspod.cloud.tencent.com/">DNSPOD</a>，搜索我们感兴趣的域名是否被他人注册，如果未被注册即可购买域名。</p><p><img src="https://download.mariozzj.cn/img/picgo/202202212259040.png" alt="域名认证提示信息"></p><p>在我国使用域名需经实名审查，按要求提交实名信息后，等待服务商、管局通知后，待服务商启动域名解析服务，即可进入下一步域名解析。</p><h2 id="域名解析">域名解析</h2><p>域名解析是将拥有的域名或其子域名指向特定的 IP 地址 / 域名地址 / 机构等，向 DNS 登记，这样其他人访问域名时，DNS 就会提供给客户端我们设定好的终点。</p><p>进入服务商的域名控制台，添加记录，填写子域名前缀，选择记录类型为 A（指向 IPV4 地址），记录值填入服务器的 IP 地址：</p><p><img src="https://download.mariozzj.cn/img/picgo/202202220038684.png" alt="域名解析记录添加"></p><p>操作后，该地址即可指向服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping test.mariozzj.asia</span>           </span><br><span class="line">Pinging test.mariozzj.asia [88.88.88.88] with 32 bytes of data:</span><br></pre></td></tr></table></figure><h1>反向代理：Nginx</h1><p>完成域名解析后，我们就实现了域名到服务器 IP 的映射。使用 <code>&lt;域名&gt;:&lt;端口号&gt;</code> 就可以访问我们的项目。利用反向代理，我们可以让其他人仅通过记忆域名，免填写端口号访问项目（端口为默认端口 80 / 443），这也有利于我们在一台服务器上部署多个项目的情况。</p><p><img src="https://download.mariozzj.cn/img/picgo/202202221108764.png" alt="反向代理"></p><p>反向代理简单来说就是启用一个反向代理服务，负责监听一个外来端口，根据客户端提供的信息找出特定的服务端服务提供给客户端，客户端不知道这个服务端服务实际在哪个端口。这里我们以 Nginx 为例设置反向代理：</p><h2 id="安装-Nginx">安装 Nginx</h2><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt install nginx -y</span></span><br></pre></td></tr></table></figure><p>安装后，检查是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> nginx -v</span></span><br><span class="line">nginx version: nginx/1.18.0 (Ubuntu)</span><br></pre></td></tr></table></figure><h2 id="防火墙配置允许-Nginx">防火墙配置允许 Nginx</h2><p>使用 ufw，执行命令允许 Nginx 服务通过防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw allow <span class="string">&#x27;Nginx Full&#x27;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>可用应用服务为 <code>Nginx HTTP</code>、<code>Nginx HTTPS</code>、<code>Nginx Full</code>，分别对应 80、443、80&amp;443端口服务</p></blockquote><p>检查是否配置成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw status</span></span><br><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">22                         ALLOW       Anywhere</span><br><span class="line">Nginx Full                 ALLOW       Anywhere</span><br><span class="line">3306/tcp                   ALLOW       Anywhere</span><br><span class="line">22 (v6)                    ALLOW       Anywhere (v6)</span><br><span class="line">Nginx Full (v6)            ALLOW       Anywhere (v6)</span><br><span class="line">3306/tcp (v6)              ALLOW       Anywhere (v6)</span><br></pre></td></tr></table></figure><h2 id="开机启动-Nginx">开机启动 Nginx</h2><p>执行 start 命令可以在 Nginx 关闭的情况下启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl start nginx</span></span><br></pre></td></tr></table></figure><p>如果要在开机时自动启动 Nginx，也可用 <code>systemctl</code> 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> nginx</span></span><br></pre></td></tr></table></figure><p>启动 Nginx 后，访问服务器 IP 地址，或对应域名，即可看到 Nginx 默认页面</p><p><img src="https://download.mariozzj.cn/img/picgo/202202221545509.png" alt="Nginx 默认页面"></p><h2 id="配置反向代理">配置反向代理</h2><p>在 <code>/etc/nginx/sites-available</code> 下存放着 Nginx 服务器块配置文件，我们可以新建一个配置文件用于当前 Web 应用的反向代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /etc/nginx/sites-available</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">touch</span> test.mariozzj.asia <span class="comment"># 添加文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> vim test.mariozzj.asia   <span class="comment"># 编辑文件</span></span></span><br></pre></td></tr></table></figure><p>文件输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name  test.mariozzj.asia;</span><br><span class="line">  index  index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass  http://127.0.0.1:5000; # 转发规则，将来自域名的访问代理至5000端口的应用</span><br><span class="line">    proxy_set_header Host $proxy_host; # 修改转发请求头，使应用可以收到真实的请求</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件后，我们还需要将这个配置文件软链接到 <code>/etc/nginx/sites-enabled</code> 以启用。执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /etc/nginx/sites-available/test.mariozzj.asia /etc/nginx/sites-enabled/</span></span><br></pre></td></tr></table></figure><p>创建完软链接，为使配置文件生效，我们可以重启服务器，也可以重启 Nginx 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl restart nginx</span></span><br></pre></td></tr></table></figure><p>配置生效后，我们就可以不指定端口直接访问我们的 Web 应用了：</p><p><img src="https://download.mariozzj.cn/img/picgo/202202221626565.png" alt="纯域名访问应用"></p><h1>合法化、安全化</h1><h2 id="域名备案">域名备案</h2><p>根据国家相关法规的相关要求，使用域名需要备案，如果域名是首次购买且映射到国内的服务器，则需要进行备案，否则随时可能被服务商暂停接入。备案一般只需备案二级域名，即我们购买的主域名，对其子域名无需单独备案。关于备案的相关流程可以查看 <a href="https://cloud.tencent.com/document/product/243/37402">网站备案 首次备案 - 备案资料填写流程 - 文档中心 - 腾讯云 (tencent.com)</a>。</p><p>备案流程完成之后，可以根据回函提示，在网站页面底端添加备案相关信息：</p><p><img src="https://download.mariozzj.cn/img/picgo/202202221644105.png" alt="备案信息"></p><h2 id="SSL-证书申请与部署">SSL 证书申请与部署</h2><p>你可能留意到，之前访问应用时，浏览器会提示“不安全”，这是因为我们是以 http 方式访问，如果我们换用 https 方式访问，保障 Web 应用安全性的同时（体现在密文传输等），也能使得 Web 应用得到更广支持。</p><p>首先，我们可以前往域名服务商控制台，为域名申请证书（也可利用 Certbot 等服务获取部署证书）：</p><p><img src="https://download.mariozzj.cn/img/picgo/202202221711069.png" alt="申请证书"></p><p>证书签发后，我们可以在证书列表下载证书，对应 Nginx 的证书文件夹有四个文件，将其中文件名为 <code>&lt;域名&gt;.key</code> 代表的私钥文件和文件名为 <code>&lt;域名&gt;_bundle.crt</code> 代表的证书文件放在 <code>/etc/nginx/certs</code> 目录下（如无 certs 目录可自行创建）</p><p>然后，编辑我们在上一节编辑过的配置文件，将其修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  listen 443 ssl; # 监听 HTTPS 的 443 端口</span><br><span class="line">  ssl on;</span><br><span class="line">  ssl_certificate /etc/nginx/certs/test.mariozzj.asia_bundle.crt; # 证书地址</span><br><span class="line">  ssl_certificate_key /etc/nginx/certs/test.mariozzj.asia.key;    # 私钥地址</span><br><span class="line">  ssl_session_timeout 5m;</span><br><span class="line">  ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">  ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">  server_name  test.mariozzj.asia;</span><br><span class="line">  index  index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass  http://127.0.0.1:5000; # 转发规则</span><br><span class="line">    proxy_set_header Host $proxy_host; # 修改转发请求头，使应用可以收到真实的请求</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重启服务，这样，我们就完成了证书的部署，以 https 方式提供我们的 web 服务了！</p>]]></content>
      
      
      <categories>
          
          <category> 玩转服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务器应用 </tag>
            
            <tag> Web 开发 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转服务器 | 服务器的简单防火墙管理</title>
      <link href="/posts/e0d78514/"/>
      <url>/posts/e0d78514/</url>
      
        <content type="html"><![CDATA[<h1>防火墙、ufw</h1><p>防火墙可以实现流量控制。服务器的防火墙一般不限制从服务器发出的流量，主要限制其他主机传入的请求。</p><h1>服务商防火墙控制</h1><p>一般而言，我们管理服务器的防火墙是对端口进行控制。在购买服务器的服务商控制台处，一般都有防火墙/安全组等配置页面，进入防火墙配置页面即可对端口进行控制：</p><p><img src="https://download.mariozzj.cn/img/picgo/202202171147291.png" alt="腾讯云 - 防火墙"></p><p>以腾讯云为例，服务商默认为我们开启了基本使用所需端口（备注中说明其用途）。如果我们需要放行端口，点击『添加规则』即可：</p><p><img src="https://download.mariozzj.cn/img/picgo/202202171153569.png" alt="添加规则"></p><p>默认情况下，若未经设置，其他的端口都是关闭的。假设我们部署在服务器上的某项目开启了 4000 端口的广播，如果想在外网访问该项目，则需要将防火墙的 4000 端口放行。随后即可通过 &lt;ip地址&gt;:&lt;端口号&gt; 访问。</p><h1>UFW 防火墙控制</h1><p>在之前的情形中，防火墙由服务商控制，每次更改配置需要进入服务商的 web 端控制台。而其实服务器上也有可以单独控制防火墙的手段，下面介绍 ufw 的使用方法。</p><p>ufw，即简单防火墙（Uncomplicated FireWall），可通过命令行的方式控制防火墙，是 ubuntu 等系统的默认防火墙程序（其实本质上是 iptables 的简明实现）。首先，<strong>为了实现 ufw 对服务器防火墙规则的单一控制，避免配置冲突，我们在服务商处将所有端口的 TCP、UDP 放行</strong>：</p><p><img src="https://download.mariozzj.cn/img/picgo/202202171203786.png" alt="放行全部 TCP 和 UDP"></p><p>随后我们远程连接上服务器，进行 ufw 的配置。ufw 的默认配置文件在 <code>/etc/default/ufw</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -v <span class="string">&#x27;^#\|^$&#x27;</span> /etc/default/ufw</span></span><br><span class="line"></span><br><span class="line">IPV6=yes</span><br><span class="line">DEFAULT_INPUT_POLICY=&quot;DROP&quot;</span><br><span class="line">DEFAULT_OUTPUT_POLICY=&quot;ACCEPT&quot;</span><br><span class="line">DEFAULT_FORWARD_POLICY=&quot;DROP&quot;</span><br><span class="line">DEFAULT_APPLICATION_POLICY=&quot;SKIP&quot;</span><br><span class="line">MANAGE_BUILTINS=no</span><br><span class="line">IPT_SYSCTL=/etc/ufw/sysctl.conf</span><br><span class="line">IPT_MODULES=&quot;&quot;</span><br></pre></td></tr></table></figure><p>默认的配置文件中，允许了所有的输出（ACCEPT），而对输入则丢弃（DROP），和服务商那边的逻辑类似。</p><p>使用 <code>ufw</code> 指令可以实现对 ufw 的控制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw &lt;command&gt;</span><br></pre></td></tr></table></figure><p>例如，输入 <code>ufw --help</code> 可以看到 <code>ufw</code> 指令的常见用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ufw --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage: ufw COMMAND</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"> enable                          enables the firewall</span><br><span class="line"> disable                         disables the firewall</span><br><span class="line"> default ARG                     set default policy</span><br><span class="line"> logging LEVEL                   set logging to LEVEL</span><br><span class="line"> allow ARGS                      add allow rule</span><br><span class="line"> deny ARGS                       add deny rule</span><br><span class="line"> reject ARGS                     add reject rule</span><br><span class="line"> limit ARGS                      add limit rule</span><br><span class="line"> delete RULE|NUM                 delete RULE</span><br><span class="line"> insert NUM RULE                 insert RULE at NUM</span><br><span class="line"> route RULE                      add route RULE</span><br><span class="line"> route delete RULE|NUM           delete route RULE</span><br><span class="line"> route insert NUM RULE           insert route RULE at NUM</span><br><span class="line"> reload                          reload firewall</span><br><span class="line"> reset                           reset firewall</span><br><span class="line"> status                          show firewall status</span><br><span class="line"> status numbered                 show firewall status as numbered list of RULES</span><br><span class="line"> status verbose                  show verbose firewall status</span><br><span class="line"> show ARG                        show firewall report</span><br><span class="line"> version                         display version information</span><br><span class="line"></span><br><span class="line">Application profile commands:</span><br><span class="line"> app list                        list application profiles</span><br><span class="line"> app info PROFILE                show information on PROFILE</span><br><span class="line"> app update PROFILE              update PROFILE</span><br><span class="line"> app default ARG                 set default application policy</span><br></pre></td></tr></table></figure><h2 id="查看-ufw-状态">查看 ufw 状态</h2><p>指令：<code>ufw status</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw status</span></span><br><span class="line">Status: inactive</span><br></pre></td></tr></table></figure><p>在默认情况下，ufw 并没有启用（inactive），否则我们 ssh 远程连接的 22 端口也会被屏蔽。在启用状态下，我们可以看到规则信息：端口号、策略、来源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw status</span></span><br><span class="line">Status: active</span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">22                         ALLOW       192.168.0.0/24</span><br><span class="line">9090                       ALLOW       Anywhere</span><br><span class="line">9090 (v6)                  ALLOW       Anywhere (v6)</span><br></pre></td></tr></table></figure><h2 id="启用、禁用、重启-ufw">启用、禁用、重启 ufw</h2><p>指令：</p><ul><li>启用：<code>ufw enable</code></li><li>禁用：<code>ufw disable</code></li><li>重启：<code>ufw reload</code></li></ul><p>启用后，ufw 即会启用防火墙控制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw <span class="built_in">enable</span></span></span><br><span class="line">Command may disrupt existing ssh connections. Proceed with operation (y|n)? y</span><br><span class="line">Firewall is active and enabled on system startup</span><br></pre></td></tr></table></figure><p>提示启动行为可能会影响现存 ssh 连接，因为 ssh 所用端口可能未开启。所以还需完善 ufw 规则</p><h2 id="添加规则">添加规则</h2><p>介绍最基本的规则指令：</p><ul><li>允许规则：<code>ufw allow &lt;参数&gt;</code> 。参数中可填端口、协议等</li><li>阻止规则：<code>ufw deny &lt;参数&gt;</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw allow 22</span></span><br><span class="line">Rule added</span><br><span class="line">Rule added (v6)</span><br></pre></td></tr></table></figure><p>提示信息指示对端口 22 添加了两条规则，分别是 ipv4、ipv6 的 22 端口放行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw allow 9000:9090/tcp</span></span><br><span class="line">Rule added</span><br><span class="line">Rule added (v6)</span><br></pre></td></tr></table></figure><p>该操作对 9000 至 9090 的所有端口，放行 TCP 协议请求。</p><p>执行以上操作后，可查看 ufw 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw status</span></span><br><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">22                         ALLOW       Anywhere</span><br><span class="line">9000:9090/tcp              ALLOW       Anywhere</span><br><span class="line">22 (v6)                    ALLOW       Anywhere (v6)</span><br><span class="line">9000:9090/tcp (v6)         ALLOW       Anywhere (v6)</span><br></pre></td></tr></table></figure><h2 id="删除规则">删除规则</h2><p>指令：</p><ul><li><code>ufw delete &lt;规则/编号&gt;</code></li></ul><p>在删除规则之前，可以通过 <code>ufw status numbered</code> 查看带编号的规则列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw status numbered</span></span><br><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">     To                         Action      From</span><br><span class="line">     --                         ------      ----</span><br><span class="line">[ 1] 22                         ALLOW IN    Anywhere</span><br><span class="line">[ 2] 9000:9090/tcp              ALLOW IN    Anywhere</span><br><span class="line">[ 3] 22 (v6)                    ALLOW IN    Anywhere (v6)</span><br><span class="line">[ 4] 9000:9090/tcp (v6)         ALLOW IN    Anywhere (v6)</span><br></pre></td></tr></table></figure><p>可以使用指定编号的方式删除规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw delete 2</span></span><br><span class="line">Deleting:</span><br><span class="line"> allow 9000:9090/tcp</span><br><span class="line">Proceed with operation (y|n)? y</span><br><span class="line">Rule deleted</span><br></pre></td></tr></table></figure><p>也可以通过指定规则内容的方式删除规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ufw delete allow 9000:9090/tcp</span></span><br><span class="line">Rule deleted</span><br><span class="line">Rule deleted (v6)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 玩转服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务器应用 </tag>
            
            <tag> UFW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转服务器 | 配置 SSH 免密登录</title>
      <link href="/posts/5c25bf34/"/>
      <url>/posts/5c25bf34/</url>
      
        <content type="html"><![CDATA[<p>SSH 即安全外壳协议（Secure Shell），可在不安全的网络环境下提供安全的数据传输。</p><p>在首次 SSH 连接服务器时，会弹出提示：</p><p><img src="https://download.mariozzj.cn/img/picgo/202202162249170.png" alt="认证信息"></p><blockquote><p>The authenticity of host ‘&lt;主机&gt;’ can’t be established.</p><p>RSA key fingerprint is &lt;指纹&gt;.</p><p>Are you sure you want to continue connecting (yes/no/[fingerprint])?</p></blockquote><p>这是因为我们第一次连接未知的主机，无法确认这个主机的真实性。如果输入 yes，则会将该主机记为可信任服务器，并将主机信息及其公钥指纹添加进 <code>~/.ssh/known_hosts</code> 中，后续的连接中则不会再询问。随后进入密码输入和验证阶段。</p><p>使用密码验证方式，随后的每一次连接，我们都需要输入密码，利用服务器公钥加密后以密文形式传输至服务器验证。而如果配置免密登录，则可以跳过输入密码，直接验证。配置免密登录的方法如下：</p><h1>生成本地客户端公钥、私钥</h1><p>打开本地客户端的终端，键入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>根据提示操作，一般全部回车默认即可。随后默认在 <code>~/.ssh/</code> （用户目录下的 <code>.ssh</code> 文件夹）下生成公钥、私钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.ssh</span><br><span class="line">   | ---- id_rsa       # 私钥</span><br><span class="line">   | ---- id_rsa.pub   # 公钥</span><br></pre></td></tr></table></figure><p>将公钥文件中的公钥复制。</p><h1>将公钥上传至服务器</h1><p>远程连接服务端，进入用户目录下的 <code>.ssh</code> 文件夹，编辑（如无则创建） <code>authorized_keys</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh/</span><br><span class="line">vim authorized_keys</span><br></pre></td></tr></table></figure><p>将客户端的 <code>id_rsa.pub</code> 中内容写入，保存。再次连接时，可以发现不用输入密码即可连接。</p><h1>原理对比</h1><p>使用<strong>密码登录</strong>时，客户端使用已获取的服务端公钥对用户输入的密码进行加密，将密文传输至服务端解密、验证；而使用<strong>免密登录</strong>时，收到登录请求的服务端会随机生成一段编码，并使用客户端预先提供的客户端公钥进行加密，并传输至客户端，客户端用客户端私钥解密密文，将解密后的明文发送给服务端验证，免去了输入密码、传输密码的过程。原理如下图：</p><p><img src="https://download.mariozzj.cn/img/picgo/202202162349489.png" alt="密码登录 &amp; 公钥登录原理"></p>]]></content>
      
      
      <categories>
          
          <category> 玩转服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务器应用 </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转服务器 | 购置自己的第一台服务器</title>
      <link href="/posts/75521d8e/"/>
      <url>/posts/75521d8e/</url>
      
        <content type="html"><![CDATA[<h1>什么是买服务器？</h1><p>事实上，我们不是『买』服务器，而是『租赁』服务器。我们在服务商处购买的服务器大多是按时间支付的。云服务器可以理解为在云端的一台电脑主机，服务商会提供给你这个电脑的 <strong>IP 地址</strong>，以便你能够找到他，同时服务商也会在他的<strong>控制台</strong>面板给你提供一些信息和操作选项，让你后续能够操作这台电脑主机。</p><h1>选定服务商</h1><p>就国内而言，知名的服务商有 <a href="https://www.aliyun.com/">阿里云</a>、<a href="https://cloud.tencent.com/">腾讯云</a>、<a href="https://www.huaweicloud.com/">华为云</a> 等，服务器定价类似。也有一些小型服务商，价格则偏向实惠。我的建议是为了稳定的服务支持、更全面的配套体验、更丰富的控制台功能，<strong>尽量选择主流的服务商</strong>。主流服务商一般都有<strong>新用户福利</strong>，可以免费获取 7 天至一个月的云服务器或轻量应用服务器，新手可以都白嫖个遍，体验一下哪一家的服务和生态协同更适合自己，再决定购买。</p><p>我体验过阿里云、腾讯云、华为云，我觉得都够用，但综合体验下来最终选择腾讯云。如果感兴趣可以点击 <a href="https://cloud.tencent.com/act/cps/redirect?redirect=10488&amp;cps_key=8a3d303f847d392194cd29c1311632f4&amp;from=activity">邀请链接</a> 支持一波~</p><p>如果目前还是学生身份，建议在服务商处进行学生认证，认证后购买学生专属服务器可以享受较低价格。如腾讯云推出的 <a href="https://cloud.tencent.com/act/campus?utm_source=qcloud&amp;utm_medium=navigation&amp;utm_campaign=campus">云+校园</a>。而且结合服务商的促销活动也可以对服务器进行配置升级等，可以按需选择。</p><h1>购置服务器</h1><h2 id="配置选择">配置选择</h2><p>出于学习或简单应用搭建目的，购置普通的云服务器或者轻量应用服务器即可。配置方面，一般 1 核 CPU 2G 内存的配置足够个人使用，可以根据需求按需购买。下面贴出我的主力服务器的配置供参考：</p><table><thead><tr><th>产品类型</th><th>腾讯云轻量应用服务器 TencentCloud Lighthouse</th></tr></thead><tbody><tr><td>CPU</td><td>2 核（2x Intel® Xeon® Gold 6148 CPU @ 2.40GHz）</td></tr><tr><td>内存</td><td>4GB</td></tr><tr><td>硬盘</td><td>80GB SSD</td></tr><tr><td>带宽</td><td>8Mbps</td></tr><tr><td>地域</td><td>北京三区</td></tr></tbody></table><h2 id="系统镜像安装">系统镜像安装</h2><p>一般在购置服务器时即需要选定系统镜像，一般建议选用 Linux 系统，理由不赘述。Linux 系统具有很多发行版本，如 CentOS、Ubuntu、Debian 等都是日下使用较为广泛的系统，这里建议选用带有用户界面的 Ubuntu 系统作为系统镜像。</p><p>购置服务器后，在服务商控制台处也可以对服务器进行系统重装。如果使用服务器的目的比较纯粹，也可以直接安装应用镜像，或者 Windows 等可以直接远程桌面操作。</p><p><img src="https://download.mariozzj.cn/img/picgo/202202151614878.png" alt="系统镜像示例"></p><h2 id="重置凭据">重置凭据</h2><p>下单购买服务器，待服务商对服务器实例完成配置，实例正常运行时，说明我们的服务器已经启用了。一般情况下，我们会在自己的常用设备上远程控制服务器，而不是通过浏览器借由服务商访问。一般来说，远程连接服务器需要主机、用户名、密码等凭据：<strong>主机</strong>即控制台页面提供给我们的公网 IP 地址，服务商安装系统时已默认在系统中创建管理员账户，而密码不会提供，此时需要在控制台处重置密码为我们指定的密码：</p><p><img src="https://download.mariozzj.cn/img/picgo/202202151643941.png" alt="服务商控制台页面"></p><p>Linux 系统默认管理员用户名为 root，而 Ubuntu 的管理员用户为 ubuntu。以上，根据公网 IP、用户名、密码，我们便可以远程连接服务器了。</p><h1>SSH 远程连接服务器</h1><p>SSH 访问是通过命令行方式访问并操作服务器。</p><p>连接之前，须确认本地计算机与实例之间的网络连通正常，以及实例的防火墙已放行 22 端口。</p><p>打开本地计算机终端（如 Windows 的 Powershell，MacOS 的 Terminal），执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh &lt;username&gt;@&lt;IP address or domain name&gt;</span><br></pre></td></tr></table></figure><p><code>@</code> 前后分别填入用户名和 IP 地址，按回车连接上后，如果是首次连接，会提示是否接受服务器的 ssh 密钥，输入 <code>yes</code> 即可；随后系统会提示输入远程服务器密码，输入刚才重置时输入的密码，回车即可。</p><p><img src="https://download.mariozzj.cn/img/picgo/202202161620288.png" alt="终端远程连接"></p><p>登录成功后，即可使用一系列 Linux 命令对服务器进行操作。</p><p>至此，已实现我们这台服务器的购置和远程连接。</p>]]></content>
      
      
      <categories>
          
          <category> 玩转服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务器应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转服务器 | 搭建 24h 在线的《饥荒》联机服务器</title>
      <link href="/posts/8d6b8da8/"/>
      <url>/posts/8d6b8da8/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>从这篇开始会写一个系列，叫“玩转服务器”，分享一下怎么把闲置云服务器的价值利用起来。</p><p>这几天想和朋友玩《饥荒》联机，一般的联机方式是房主（Host）创建房间，我们再加入。但是我们发现这种方式不太方便，因为《饥荒》作为一款周期不算短的游戏，是可能要把游戏进程存档下去继续玩的，而游戏的存档默认放在房主电脑的本地，也就意味着每次打这个世界都需要房主开服，非常麻烦。</p><p>因为近期我的云服务器也闲置，参考了网上一系列的教程后摸索出了目前（2022.1）能够稳定建立《饥荒》联机服务器的方法（我的服务器近期也重装了，所以应该在其他机子上面不会有兼容性和依赖性问题），在此做记录。</p><p>我的服务器配置如下：</p><ul><li>型号：Tencent Cloud CVM（腾讯云轻量应用服务器）</li><li>实例规格：<ul><li>2核 CPU（2x Intel® Xeon® Gold 6148 CPU @ 2.40GHz）</li><li>4G 内存</li><li>8M 带宽</li><li>80G 硬盘</li></ul></li><li>系统：Ubuntu 20.04.3 LTS（Linux 系统）</li></ul><p>在我的 Windows 机上的交互需要用到的工具：</p><ul><li>Windows Terminal + Powershell</li><li>XFtp</li></ul><h1>环境准备</h1><h2 id="依赖库安装">依赖库安装</h2><p>使用服务器管理员账户安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dpkg --add-architecture i386</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libstdc++6:i386 libgcc1:i386 libcurl4-gnutls-dev:i386 SDL</span><br></pre></td></tr></table></figure><h2 id="创建用户，安装-SteamCMD-和游戏">创建用户，安装 SteamCMD 和游戏</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser steam</span><br></pre></td></tr></table></figure><p>输入账户基本信息后即可创建名为 <code>steam</code> 的用户。这里不将该用户设为管理员，单独创建用户的目的是为了隔离数据，同时保证服务器其他功能不受影响。随后输入命令和密码切换到该用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - steam</span><br></pre></td></tr></table></figure><p>现在我们在名为 <code>steam</code> 的用户目录下（<code>/home/steam</code>），可下载 SteamCMD 并解压安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/steamcmd</span><br><span class="line">cd ~/steamcmd</span><br><span class="line">wget http://media.steampowered.com/installer/steamcmd_linux.tar.gz</span><br><span class="line">tar -xvzf steamcmd_linux.tar.gz</span><br></pre></td></tr></table></figure><p>随后我们可以启动 SteamCMD：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./steamcmd.sh</span><br></pre></td></tr></table></figure><p>进行必要的启动后，我们会进入 Steam 命令行模式，终端前缀不再是 <code>$</code> 而是 <code>steam &gt;</code>。首先我们创建游戏目录，再匿名登录 steam 更新游戏，最后退出 Steam 命令行即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">force_install_dir ../dstserver</span><br><span class="line">login anonymous</span><br><span class="line">app_update 343050 validate</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><h2 id="开放端口">开放端口</h2><p>如果服务器有防火墙、安全组等，一定要开放指定的端口。默认的端口大概在 10000 - 12000 之间，具体需要开放的端口可以查看存档文件夹下的这几个文件：</p><ul><li><code>~/.klei/DoNotStarveTogether/Cluster_1/cluster.ini</code> 中的 <code>master_port</code>。</li><li><code>~/.klei/DoNotStarveTogether/Cluster_1/Master/server.ini</code> 中的 <code>server_port</code>。</li><li><code>~/.klei/DoNotStarveTogether/Cluster_1/Caves/server.ini</code> 中的 <code>server_port</code>、<code>master_server_port</code>、<code>authentication_port</code>。</li></ul><p>最好 TCP、UDP 全部打开。</p><h1>创建世界</h1><h2 id="在本机完成世界的创建">在本机完成世界的创建</h2><p>在主力机上打开《饥荒联机版》，在选单界面点击【创建游戏】对联机需要创建的世界进行配置，服务器模式选择【公共】，并配置好密码。</p><p><img src="https://download.mariozzj.cn/img/picgo/202201151238562.png" alt="本机创建游戏"></p><p>建议在世界创建时即添加好模组，便于后续云服务器端模组的导入。</p><p>创建世界进入游戏后，即可退出世界，回到游戏选单界面。</p><h2 id="本地存档导出">本地存档导出</h2><p><img src="https://download.mariozzj.cn/img/picgo/202201151239734.png" alt="【数据】"></p><p>在选单界面点击【数据】，此时文件资源管理器会打开《饥荒》存档文件夹，该文件夹下每个世界都有一个文件夹用于存放存档。找到刚才创建世界对应的存档文件夹，这个文件夹稍后将上传到云服务器。</p><h2 id="获取-Token">获取 Token</h2><p><img src="https://download.mariozzj.cn/img/picgo/202201151240163.png" alt="【账号】"></p><p>回到选单界面，点击【账号】即可进入 Klei 账户界面，在首页，复制自己的 Klei 用户 id 并记录下来。</p><p><img src="https://download.mariozzj.cn/img/picgo/202201151242887.png" alt="获取用户id"></p><p>点击【游戏】选项卡，选择《饥荒联机版》的游戏服务器，输入集群服务器名即可创建，建议同时配置服务器密码。随后在该页面会看到该服务器对应的 Token，将其复制并记录下来。</p><p><img src="https://download.mariozzj.cn/img/picgo/202201151245561.png" alt="获取服务器Token"></p><h1>配置服务器端世界</h1><h2 id="服务器端生成默认配置文件">服务器端生成默认配置文件</h2><p>使用之前创建的 <code>steam</code> 账户登录服务器，终端下执行下列命令生成默认配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/dstserver/bin</span><br><span class="line">./dontstarve_dedicated_server_nullrenderer</span><br></pre></td></tr></table></figure><p>生成完成后按 <code>Ctrl+C</code> 强制退出即可。</p><h2 id="设置-Token-和管理员">设置 Token 和管理员</h2><p>上一步应该创建了饥荒存档文件夹，此时在存档文件夹里面配置 Token。使用 Vim 打开配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.klei/DoNotStarveTogether/cluster_token.txt</span><br></pre></td></tr></table></figure><p>按 <code>i</code> 进入编辑模式，输入刚才的 Token。再按 <code>Esc</code> 进入命令模式，输入 <code>:wq</code> 保存并退出。使用同样的方法，编辑刚才默认配置世界下的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.klei/DoNotStarveTogether/Cluster_1/cluster_token.txt</span><br></pre></td></tr></table></figure><p>随后，我们可以将我们配置为该饥荒世界的管理员。同样在世界存档文件夹下添加 <code>adminlist.txt</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.klei/DoNotStarveTogether/Cluster_1/adminlist.txt</span><br></pre></td></tr></table></figure><p>输入之前我们复制的 Klei 用户 id，保存退出即可。</p><h2 id="配置模组">配置模组</h2><p>虽然我们的存档里有模组，但是我们还需要在游戏里面修改配置文件，这样在云服务器端运行时才会加载。加载配置文件名为 <code>dedicated_server_mods_setup.lua</code>。默认在 <code>~/dstserver/mods</code> 里面，如果没有，可以使用 <code>find</code> 命令查找一下。编辑该文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/dstserver/mods/dedicated_server_mods_setup.lua</span><br></pre></td></tr></table></figure><p>在该文件中，按如下格式每行填入一个刚才导入的模组的 ID。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerModSetup(<span class="string">&quot;对应的模组ID&quot;</span>)</span><br><span class="line">ServerModSetup(<span class="string">&quot;对应的模组ID&quot;</span>)</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>模组的 ID 可以根据该模组的创意工坊链接获得，也可以直接从之前的本地存档文件夹中，<code>Master</code> 或 <code>Cave</code> 文件夹下的 <code>modoverrides.lua</code> 中找到。文件中的 <code>&quot;workshop-xxxxx&quot;</code> 的 <code>xxxxx</code> 就是模组 ID。</p><h2 id="上传存档">上传存档</h2><p>使用 XFtp ，创建的 <code>steam</code> 用户登录服务器，进入 <code>~/.klei</code> 文件夹，然后将刚才创建世界的存档文件夹中的内容整个复制到服务器的 <code>~/.klei/Cluster_1</code> 文件夹下，确保存档文件覆盖了默认配置文件。</p><h1>运行世界</h1><h2 id="配置一键运行脚本">配置一键运行脚本</h2><p>建议在用户目录下创建运行脚本，随后可以利用该脚本一键运行。</p><p>创建 <code>rundst.sh</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/rundst.sh</span><br></pre></td></tr></table></figure><p>填入 <a href="https://gist.githubusercontent.com/MarioZZJ/f4b6d55fe6fdd494cf425f819cc51f09/raw/a6811bdd443cc988f91fb7f864892603d9b935bb/rundst.sh">脚本内容</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">steamcmd_dir=<span class="string">&quot;<span class="variable">$HOME</span>/steamcmd&quot;</span></span><br><span class="line">install_dir=<span class="string">&quot;<span class="variable">$HOME</span>/dstserver&quot;</span></span><br><span class="line">cluster_name=<span class="string">&quot;Cluster_1&quot;</span></span><br><span class="line">dontstarve_dir=<span class="string">&quot;<span class="variable">$HOME</span>/.klei/DoNotStarveTogether&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fail</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">echo</span> Error: <span class="string">&quot;<span class="variable">$@</span>&quot;</span> &gt;&amp;2</span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">check_for_file</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> [ ! -e <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            fail <span class="string">&quot;Missing file: <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$steamcmd_dir</span>&quot;</span> || fail <span class="string">&quot;Missing <span class="variable">$steamcmd_dir</span> directory!&quot;</span> <span class="comment"># TODO</span></span><br><span class="line"></span><br><span class="line">check_for_file <span class="string">&quot;steamcmd.sh&quot;</span></span><br><span class="line">check_for_file <span class="string">&quot;<span class="variable">$dontstarve_dir</span>/<span class="variable">$cluster_name</span>/cluster.ini&quot;</span></span><br><span class="line">check_for_file <span class="string">&quot;<span class="variable">$dontstarve_dir</span>/<span class="variable">$cluster_name</span>/cluster_token.txt&quot;</span></span><br><span class="line">check_for_file <span class="string">&quot;<span class="variable">$dontstarve_dir</span>/<span class="variable">$cluster_name</span>/Master/server.ini&quot;</span></span><br><span class="line">check_for_file <span class="string">&quot;<span class="variable">$dontstarve_dir</span>/<span class="variable">$cluster_name</span>/Caves/server.ini&quot;</span></span><br><span class="line"></span><br><span class="line">./steamcmd.sh +force_install_dir <span class="string">&quot;<span class="variable">$install_dir</span>&quot;</span> +login anonymous +app_update 343050 +quit</span><br><span class="line"></span><br><span class="line">check_for_file <span class="string">&quot;<span class="variable">$install_dir</span>/bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$install_dir</span>/bin&quot;</span> || fail </span><br><span class="line"></span><br><span class="line">run_shared=(./dontstarve_dedicated_server_nullrenderer)</span><br><span class="line">run_shared+=(-console)</span><br><span class="line">run_shared+=(-cluster <span class="string">&quot;<span class="variable">$cluster_name</span>&quot;</span>)</span><br><span class="line">run_shared+=(-monitor_parent_process $$)</span><br><span class="line">run_shared+=(-shard)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;run_shared[@]&#125;</span>&quot;</span> Caves  | sed <span class="string">&#x27;s/^/Caves:  /&#x27;</span> &amp;</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;run_shared[@]&#125;</span>&quot;</span> Master | sed <span class="string">&#x27;s/^/Master: /&#x27;</span></span><br></pre></td></tr></table></figure><p>保存关闭后，赋予脚本执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x ~/rundst.sh</span><br></pre></td></tr></table></figure><h2 id="使用-tmux-运行联机脚本">使用 tmux 运行联机脚本</h2><p>上一步的脚本执行后即可一键运行服务器。考虑到我们的远程终端可能会在未来退出，为保持 session 以使得脚本可以在我们退出后后台持续运行，可以使用 tmux 后台运行脚本。</p><p>Ubuntu 20.04 自带了 tmux，无需安装，我们可以直接创建一个会话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s dontstarve</span><br></pre></td></tr></table></figure><p>进入 tmux 界面后，运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/rundst.sh</span><br></pre></td></tr></table></figure><p><img src="https://download.mariozzj.cn/img/picgo/202201151247136.png" alt="tmux 下脚本稳定运行界面"></p><p>待稳定运行后，即可暂挂该会话，回到正常终端。操作是依次按下 <code>Ctrl+B</code> 、<code>D</code>。</p><p><strong>脚本稳定运行创建世界后，即可喊上小伙伴，在游戏选单界面选择【加入游戏】，搜索房间名加入了。</strong></p><p><img src="https://download.mariozzj.cn/img/picgo/202201151246311.png" alt="查找房间"></p><p>之后如果要回到该会话，可以使用 <code>tmux attach -t dontstarve</code> 进行操作。</p><p><img src="https://download.mariozzj.cn/img/picgo/202201151248430.png" alt="快乐游戏"></p>]]></content>
      
      
      <categories>
          
          <category> 玩转服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏《饥荒》 </tag>
            
            <tag> 云服务器应用 </tag>
            
            <tag> 联机游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基础操作学习(3)：文件操作进阶</title>
      <link href="/posts/2c01ed8b/"/>
      <url>/posts/2c01ed8b/</url>
      
        <content type="html"><![CDATA[<h1>文件压缩和解压</h1><p>常用的压缩包后缀有 <code>.tar</code>、<code>.gz</code>、<code>.bz</code>、<code>.z</code>、<code>.zip</code>、<code>.rar</code> 等，分别采用不同压缩方法进行压缩和解压。根据不同类型可以在 Linux 下选择不同的压缩文件。</p><h2 id="gzip、gunzip"><code>gzip</code>、<code>gunzip</code></h2><p><code>gzip</code> 命令和 <code>gunzip</code> 命令用于 <code>.gz</code> 文件的压缩和解压。</p><p><code>gzip &lt;参数&gt; &lt;目录&gt;</code> 可用于目录的压缩，压缩后得到的文件会放在工作目录。</p><ul><li>常用参数：<ul><li><code>-l</code>：列出压缩文件的相关信息（list）</li><li><code>-v</code>：显示指令执行过程（verbose）</li><li><code>-d</code>：改为解压指定文件（decompress）</li><li><code>-r</code>：递归处理目录下的文件及子目录（recursive）</li></ul></li></ul><p><code>gunzip &lt;参数&gt; &lt;文件.gz&gt;</code> 可用于文件的解压，解压的目录放在工作目录下。常用参数同上（除 <code>-d</code>）。</p><h2 id="bzip2、bunzip2"><code>bzip2</code>、<code>bunzip2</code></h2><p><code>bzip2</code> 命令和 <code>bunzip2</code> 命令用于 <code>.bz2</code> 文件的压缩和解压。</p><p><code>bzip2 &lt;参数&gt; &lt;目录&gt;</code> 可用于目录的压缩，压缩后得到的文件会放在工作目录。常用参数同上。</p><p><code>bunzip2 &lt;参数&gt; &lt;文件.bz2&gt;</code> 可用于文件的解压，解压的目录放在工作目录下。常用参数同上（除 <code>-d</code>）。</p><h2 id="compress-、uncompress"><code>compress</code> 、<code>uncompress</code></h2><p><code>compress</code> 命令和 <code>uncompress</code> 命令用于 <code>.Z</code> 文件的压缩和解压。该方法已不太常用</p><p><code>bzip2 &lt;参数&gt; &lt;目录&gt;</code> 可用于目录的压缩，压缩后得到的文件会放在工作目录。支持同上<code>-v</code>、<code>-d</code> 参数。</p><p><code>bunzip2 &lt;参数&gt; &lt;文件.bz2&gt;</code> 可用于文件的解压，解压的目录放在工作目录下。支持同上 <code>-v</code> 参数。</p><h2 id="tar"><code>tar</code></h2><p><code>tar</code> 是用来建立，还原备份文件的工具程序，可以加入、解开备份文件内的文件。（tape archive）</p><p><code>tar</code> 本身可以处理 <code>.tar</code> 格式的压缩和解压。但通过附加参数，<code>tar</code> 命令即可实现 tar 上追加其他属性的压缩和解压。</p><p>模式参数：</p><ul><li><code>-c</code>：建立压缩档案</li><li><code>-x</code>：解压</li><li><code>-t</code>：查看内容</li><li><code>-r</code>：像压缩归档文件末尾追加文件</li><li><code>-u</code>：更新原压缩包中的文件</li></ul><p>以上五个独立命令是使用 <code>tar</code> 操作时必须用到，指定本次命令的目的。五个参数只能选择其一，并可与其他参数混用。</p><p>其他参数：</p><ul><li><code>-z</code>：gzip 属性</li><li><code>-j</code>：bz2 属性</li><li><code>-Z</code>：compress 属性</li><li><code>-v</code>：显示所有过程</li><li><code>-O</code>：将文件解开到标准输出</li></ul><p>必选结尾参数：</p><ul><li><code>-f</code>：使用档案名。该参数是最后一个参数，后面接档案名。</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩操作</span></span><br><span class="line">tar –cvf jpg.tar *.jpg       # 将目录里所有jpg文件打包成 tar.jpg </span><br><span class="line">tar –czf jpg.tar.gz *.jpg    # 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，命名为 jpg.tar.gz </span><br><span class="line">tar –cjf jpg.tar.bz2 *.jpg   # 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，命名为jpg.tar.bz2 </span><br><span class="line">tar –cZf jpg.tar.Z *.jpg     # 将目录里所有 jpg 文件打包成 jpg.tar 后，并且将其用 compress 压缩，生成一个 umcompress 压缩过的包，命名为jpg.tar.Z</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压操作</span></span><br><span class="line">tar –xvf file.tar         # 解压 tar 包 </span><br><span class="line">tar -xzvf file.tar.gz     # 解压 tar.gz </span><br><span class="line">tar -xjvf file.tar.bz2    # 解压 tar.bz2 </span><br><span class="line">tar –xZvf file.tar.Z      # 解压 tar.Z </span><br></pre></td></tr></table></figure><h2 id="zip、unzip"><code>zip</code>、<code>unzip</code></h2><p><code>zip</code> 命令和 <code>unzip</code> 命令用于 <code>.zip</code> 文件的压缩。</p><p>需要额外注意的是要想使用该命令，需要先安装 Zip for Linux。如在 CentOS 下安装，输入指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y zip</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y unzip</span></span><br></pre></td></tr></table></figure><p>用法：<code>zip &lt;参数&gt; [&lt;生成的文件目录&gt;] &lt;目录或多文件&gt;</code></p><p>常用参数：</p><ul><li><code>-v</code>：同上</li><li><code>-r</code>：同上</li><li><code>-d</code>：从压缩文件内删除指定的文件</li><li><code>-q</code>：不显示指令执行过程</li><li><code>-f</code>：更新现有文件</li><li><code>-P &lt;密码&gt;</code>：加密压缩文件，后接加密密码</li></ul><p>用法：<code>unzip &lt;参数&gt; &lt;目录或多文件&gt;</code></p><p>常用参数：</p><ul><li><code>-v</code>：同上</li><li><code>-q</code>：同上</li><li><code>-f</code>：同上</li><li><code>-P &lt;密码&gt;</code>：解压时输入密码</li><li><code>-d &lt;目录&gt;</code>：指定文件解压缩后要存储的目录</li><li><code>-x &lt;空格分隔文件&gt;</code>：指定不处理压缩文件中的哪些文件</li></ul><h2 id="rar、unrar"><code>rar</code>、<code>unrar</code></h2><p><code>rar</code> 命令和 <code>unrar</code> 命令用于 <code>.rar</code> 文件的压缩。</p><p>需要额外注意的是，要使用该命令同样需要先安装 RAR for Linux。直接 <code>yum</code> 安装可能提示无资源，可以添加其他镜像或<a href="http://www.rarlab.com/download.htm">直接下载</a>。<code>rar</code> 和 <code>unrar</code> 的用法和 <code>zip</code>、<code>unzip</code> 类似。</p><h2 id="实战：文件压缩和解压">实战：文件压缩和解压</h2><ol><li>在 <code>/home/datawhale</code> 目录下昵称文件夹中，下载 <a href="https://mirror.coggle.club/dataset/jaychou_lyrics.txt.zip%E3%80%82">https://mirror.coggle.club/dataset/jaychou_lyrics.txt.zip。</a></li><li>使用 <code>zip</code> 压缩该昵称文件夹</li><li>使用 <code>tar</code> 压缩该昵称文件夹</li><li>将该昵称文件夹打包为 <code>tar.gz</code> 格式</li></ol><p>实操：</p><ol><li><p>下载文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ wget https://mirror.coggle.club/dataset/jaychou_lyrics.txt.zip</span><br><span class="line">--2021-12-27 21:48:35--  https://mirror.coggle.club/dataset/jaychou_lyrics.txt.zip</span><br><span class="line">Resolving mirror.coggle.club (mirror.coggle.club)... 113.229.252.249, 2408:872b:f01:1002:3::3fc</span><br><span class="line">Connecting to mirror.coggle.club (mirror.coggle.club)|113.229.252.249|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 52607 (51K) [application/zip]</span><br><span class="line">Saving to: ‘jaychou_lyrics.txt.zip’</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100%</span><span class="language-bash">[==============================================================================&gt;] 52,607      --.-K/s   <span class="keyword">in</span> 0.03s</span></span><br><span class="line"></span><br><span class="line">2021-12-27 21:48:36 (1.71 MB/s) - ‘jaychou_lyrics.txt.zip’ saved [52607/52607]</span><br></pre></td></tr></table></figure></li><li><p><code>zip</code> 压缩目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 大家都在根目录执行压缩语句，压缩包全都默认丢到根目录，已经乱成一锅粥了，所以我还是指定一下目标目录</span></span></span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$ zip -v -r ./MarioZZJ/MarioZZJ.zip ./MarioZZJ</span><br><span class="line">  adding: MarioZZJ/     (in=0) (out=0) (stored 0%)</span><br><span class="line">  adding: MarioZZJ/datawhale/   (in=0) (out=0) (stored 0%)</span><br><span class="line">  adding: MarioZZJ/datawhale/affairs.txt        (in=92161) (out=14343) (deflated 84%)</span><br><span class="line">  adding: MarioZZJ/datawhale/test.py    (in=46) (out=46) (stored 0%)</span><br><span class="line">  adding: MarioZZJ/datawhale/test1.py   (in=46) (out=46) (stored 0%)</span><br><span class="line">  adding: MarioZZJ/datawhale/test2.py   (in=48) (out=48) (stored 0%)</span><br><span class="line">  adding: MarioZZJ/test5.py     (in=188) (out=129) (deflated 31%)</span><br><span class="line">  adding: MarioZZJ/affairs/     (in=0) (out=0) (stored 0%)</span><br><span class="line">  adding: MarioZZJ/affairs/.affairs.py.swp      (in=12288) (out=395) (deflated 97%)</span><br><span class="line">  adding: MarioZZJ/affairs/affairs.py   (in=241) (out=176) (deflated 27%)</span><br><span class="line">  adding: MarioZZJ/affairs/__init__.py  (in=0) (out=0) (stored 0%)</span><br><span class="line">  adding: MarioZZJ/affairs/test6.py     (in=173) (out=129) (deflated 25%)</span><br><span class="line">  adding: MarioZZJ/affairs/__pycache__/ (in=0) (out=0) (stored 0%)</span><br><span class="line">  adding: MarioZZJ/affairs/__pycache__/affairs.cpython-36.pyc   (in=435) (out=328) (deflated 25%)</span><br><span class="line">  adding: MarioZZJ/affairs/__pycache__/__init__.cpython-36.pyc  (in=127) (out=100) (deflated 21%)</span><br><span class="line">  adding: MarioZZJ/test6.py     (in=114) (out=92) (deflated 19%)</span><br><span class="line">  adding: MarioZZJ/sleep.py     (in=108) (out=91) (deflated 16%)</span><br><span class="line">  adding: MarioZZJ/outlog.txt   (in=517740) (out=61794) (deflated 88%)</span><br><span class="line">  adding: MarioZZJ/jaychou_lyrics.txt.zip       (in=52607) (out=52607) (stored 0%)</span><br><span class="line">total bytes=676322, compressed=130324 -&gt; 81% savings</span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$</span><br></pre></td></tr></table></figure></li><li><p><code>tar</code> 压缩目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ tar -cf ./MarioZZJ/MarioZZJ.tar ./MarioZZJ</span><br><span class="line">tar: ./MarioZZJ/MarioZZJ.tar: file is the archive; not dumped</span><br></pre></td></tr></table></figure><p>发现直接这么执行报错了，为什么呢？通过查找资料发现 <code>tar</code> 后接目标时只能写文件名，不能写本例中的目录名。否则只会生成备份文件而非压缩文件。所以我们可以重新操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ cd MarioZZJ</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ rm MarioZZJ.tar </span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ tar -cvf MarioZZJ.tar * # 打包当前目录下所有文件，可以使用通配符 *</span><br><span class="line">affairs/</span><br><span class="line">affairs/.affairs.py.swp</span><br><span class="line">affairs/affairs.py</span><br><span class="line">affairs/__init__.py</span><br><span class="line">affairs/test6.py</span><br><span class="line">affairs/__pycache__/</span><br><span class="line">affairs/__pycache__/affairs.cpython-36.pyc</span><br><span class="line">affairs/__pycache__/__init__.cpython-36.pyc</span><br><span class="line">datawhale/</span><br><span class="line">datawhale/affairs.txt</span><br><span class="line">datawhale/test.py</span><br><span class="line">datawhale/test1.py</span><br><span class="line">datawhale/test2.py</span><br><span class="line">jaychou_lyrics.txt.zip</span><br><span class="line">MarioZZJ.zip</span><br><span class="line">outlog.txt</span><br><span class="line">sleep.py</span><br><span class="line">test5.py</span><br><span class="line">test6.py</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$</span><br></pre></td></tr></table></figure></li><li><p>压缩目录为 <code>tar.gz</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ tar -czf MarioZZJ.tar.gz *</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$</span><br></pre></td></tr></table></figure></li></ol><hr><h1>文件文本字符查找替换</h1><h2 id="grep"><code>grep</code></h2><p><code>grep</code> 命令用于查找文件里符合条件的字符串行，即如果发现某文件包含符合指定范本样式的内容，就把那一行显示出来。</p><p>用法：<code>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示行数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</code></p><p>参数：</p><ul><li><code>-A &lt;显示行数&gt;</code>：除了显示结果行之外并展示该行之后的内容（同 <code>--after-context=&lt;显示行数&gt;</code>）</li><li><code>-B &lt;显示行数&gt;</code>：除了显示结果行之外并展示该行之前的内容（同 <code>--before-context=&lt;显示行数&gt;</code>）</li><li><code>-C &lt;显示行数&gt;</code>：除了显示结果行之外并展示该行之前之后的内容（同 <code>--context=&lt;显示行数&gt;</code>）</li><li><code>-e &lt;范本样式&gt;</code>：指定字符串作为查找文件内容的样式（同 <code>--regexp=&lt;范本样式&gt;</code>），见 <a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式 – 语法 | 菜鸟教程 (runoob.com)</a></li><li><code>-f &lt;规则文件&gt;</code>：指定规则文件，其内容含有一个或多个规则样式，让 grep 查找符合规则条件的文件内容，格式为每行一个规则样式。</li><li><code>-i</code>：忽略字符大小写（同 <code>--ignore-case</code>）</li><li><code>-l</code>：仅输出符合指定样式的文件名称</li><li><code>-n</code>：在显示符合样式的那一行之前，标示出该行的列数编号</li><li><code>-r</code>：以递归方式查找符合条件的文献（查找目录及子目录，同 <code>--recursive</code> 或 <code>-d recurse</code>）</li><li><code>-v</code>：反向查找，打印出不符合条件行的内容（同 <code>--invert-match</code>）</li></ul><p>应用举例：</p><p>系统报警显示了时间，但是日志文件太大无法直接 cat 查看。(查询含有特定文本的文件，并拿到这些文本所在的行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n &#x27;2019-10-24 00:01:11&#x27; *.log</span><br></pre></td></tr></table></figure><p>在当前目录里第一级文件夹中寻找包含指定字符串的 .in 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;thermcontact&quot; /.in</span><br></pre></td></tr></table></figure><p>从根目录开始查找所有扩展名为 .log 的文本文件，并找出包含 “ERROR” 的行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type f -name &quot;*.log&quot; | xargs grep &quot;ERROR&quot;</span><br></pre></td></tr></table></figure><p>例子：从当前目录开始查找所有扩展名为 .in 的文本文件，并找出包含 “thermcontact” 的行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.in&quot; | xargs grep &quot;thermcontact&quot;</span><br></pre></td></tr></table></figure><h2 id="sed"><code>sed</code></h2><p><code>sed</code> 命令可用来自动编辑一个或多个文件，简化对文件的反复操作。</p><p>用法：<code>sed [-hnV][-e &lt;script&gt;][-f &lt;script文件&gt;][文本文件]</code></p><p>参数：</p><ul><li><code>-e</code>：以选项中指定的 script 处理输入的文本文件</li><li><code>-f</code>：以选项中指定的 script 文件来处理输入的文本文件</li><li><code>-n</code>：仅显示 script 处理后的结果</li></ul><p>动作说明：</p><ul><li><code>a</code>：新增， <code>a</code> 的后面接字符串，这些字符串会在新的一行出现</li><li><code>c</code>：取代， <code>c</code> 的后面接字符串，这些字符串可以取代 n1,n2 之间的行！</li><li><code>d</code>：删除</li><li><code>i</code>：插入， <code>i</code> 的后面接字符串，这些字符串会在新的一行出现(目前的上一行)</li><li><code>p</code>：打印，亦即将某个选择的数据印出。通常 <code>p</code> 会与参数 <code>sed -n</code> 一起运行</li><li><code>s</code>：取代，可以直接进行取代的工作哩！通常这个 <code>s</code> 的动作可以搭配正规表示法</li></ul><p>动作举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除某行</span></span><br><span class="line">sed -e &#x27;1d&#x27; ab         #删除第一行 </span><br><span class="line">sed -e &#x27;$d&#x27; ab         #删除最后一行</span><br><span class="line">sed -e &#x27;1,2d&#x27; ab       #删除第一行到第二行</span><br><span class="line">sed -e &#x27;2,$d&#x27; ab       #删除第二行到最后一行</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">　　# </span><span class="language-bash">显示某行</span></span><br><span class="line">sed -e &#x27;1p&#x27; ab         #显示第一行 </span><br><span class="line">sed -e &#x27;$p&#x27; ab         #显示最后一行</span><br><span class="line">sed -e &#x27;1,2p&#x27; ab       #显示第一行到第二行</span><br><span class="line">sed -e &#x27;2,$p&#x27; ab       #显示第二行到最后一行</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">　　# </span><span class="language-bash">使用模式进行查询</span></span><br><span class="line">sed -e &#x27;/ruby/p&#x27; ab    #查询包括关键字ruby所在所有行</span><br><span class="line">sed -e &#x27;/\$/p&#x27; ab      #查询包括关键字$所在所有行，使用反斜线\屏蔽特殊含义</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">　　# </span><span class="language-bash">增加一行或多行字符串</span></span><br><span class="line">cat ab</span><br><span class="line">Hello!</span><br><span class="line">ruby is me,welcome to my blog.</span><br><span class="line">end</span><br><span class="line">sed -e &#x27;1a drink tea&#x27; ab  #第一行后增加字符串&quot;drink tea&quot;</span><br><span class="line">Hello!</span><br><span class="line">drink tea</span><br><span class="line">ruby is me,welcome to my blog. </span><br><span class="line">end</span><br><span class="line">sed -e &#x27;1,3a drink tea&#x27; ab #第一行到第三行后增加字符串&quot;drink tea&quot;</span><br><span class="line">Hello!</span><br><span class="line">drink tea</span><br><span class="line">ruby is me,welcome to my blog.</span><br><span class="line">drink tea</span><br><span class="line">end</span><br><span class="line">drink tea</span><br><span class="line">sed -e &#x27;1a drink tea\nor coffee&#x27; ab   #第一行后增加多行，使用换行符\n</span><br><span class="line">Hello!</span><br><span class="line">drink tea</span><br><span class="line">or coffee</span><br><span class="line">ruby is me,welcome to my blog.</span><br><span class="line">end</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">　　代替一行或多行</span></span><br><span class="line">sed -e &#x27;1c Hi&#x27; ab                #第一行代替为Hi</span><br><span class="line">Hi</span><br><span class="line">ruby is me,welcome to my blog.</span><br><span class="line">end</span><br><span class="line">sed -e &#x27;1,2c Hi&#x27; ab             #第一行到第二行代替为Hi</span><br><span class="line">Hi</span><br><span class="line">end</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">替换一行中的某部分</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式：sed <span class="string">&#x27;s/要替换的字符串/新的字符串/g&#x27;</span>   （要替换的字符串可以用正则表达式）</span></span><br><span class="line">sed -n -e &#x27;/ruby/p&#x27; ab | sed &#x27;s/ruby/bird/g&#x27;    #替换ruby为bird</span><br><span class="line">sed -n -e &#x27;/ruby/p&#x27; ab | sed &#x27;s/ruby//g&#x27;        #删除ruby</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插入</span></span><br><span class="line">sed -i &#x27;$a bye&#x27; ab         #在文件ab中最后一行直接输入&quot;bye&quot;</span><br><span class="line">cat ab</span><br><span class="line">Hello!</span><br><span class="line">ruby is me,welcome to my blog.</span><br><span class="line">end</span><br><span class="line">bye</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除匹配行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式：sed -i <span class="string">&#x27;/匹配字符串/d&#x27;</span>  filename  （注：若匹配字符串是变量，则需要“”，而不是‘’。）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">替换匹配行中的某个字符串</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式：sed -i <span class="string">&#x27;/匹配字符串/s/替换源字符串/替换目标字符串/g&#x27;</span> filename</span></span><br></pre></td></tr></table></figure><h2 id="实战：字符串查找替换">实战：字符串查找替换</h2><ol><li>在 <code>/home/datawhale</code> 目录下昵称文件夹中，下载 <a href="https://mirror.coggle.club/dataset/jaychou_lyrics.txt.zip%EF%BC%8C%E5%B9%B6%E8%A7%A3%E5%8E%8B%E3%80%82">https://mirror.coggle.club/dataset/jaychou_lyrics.txt.zip，并解压。</a></li><li>使用 <code>grep</code> 完成下列操作，并输出到屏幕<ol><li>统计歌词中 包含【超人】的歌词</li><li>统计歌词中 包含【外婆】但不包含【期待】的歌词</li><li>统计歌词中 以【我】开头的歌词</li><li>统计歌词中 以【我】结尾的歌词</li></ol></li><li>使用 <code>sed</code> 命令完成下列操作，并输出到屏幕<ol><li>将歌词中 第2行 至 第40行 删除</li><li>将歌词中 所有【我】替换成【你】</li></ol></li></ol><p>实操：</p><ol><li>下载文件并解压</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ wget https://mirror.coggle.club/dataset/jaychou_lyrics.txt.zip</span><br><span class="line">--2021-12-27 23:45:13--  https://mirror.coggle.club/dataset/jaychou_lyrics.txt.zip</span><br><span class="line">Resolving mirror.coggle.club (mirror.coggle.club)... 113.229.252.249, 2408:872b:f01:1002:3::3fc</span><br><span class="line">Connecting to mirror.coggle.club (mirror.coggle.club)|113.229.252.249|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 52607 (51K) [application/zip]</span><br><span class="line">Saving to: ‘jaychou_lyrics.txt.zip’</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100%</span><span class="language-bash">[==============================================================================&gt;] 52,607      --.-K/s   <span class="keyword">in</span> 0.06s</span></span><br><span class="line"></span><br><span class="line">2021-12-27 23:45:13 (880 KB/s) - ‘jaychou_lyrics.txt.zip’ saved [52607/52607]</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ unzip -d . jaychou_lyrics.txt.zip</span><br><span class="line">Archive:  jaychou_lyrics.txt.zip</span><br><span class="line">inflating: ./jaychou_lyrics.txt</span><br></pre></td></tr></table></figure><ol start="2"><li><code>grep</code> 文本匹配</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ grep -n &quot;超人&quot; jaychou_lyrics.txt</span><br><span class="line">5795:如果超人会飞 那就让我在空中停一停歇</span><br><span class="line">5798:不要问我哭过了没 因為超人不能流眼泪</span><br><span class="line">5815:只能说当超人真的好难</span><br><span class="line">5816:如果超人会飞 那就让我在空中停一停歇</span><br><span class="line">5819:不要问我哭过了没 因為超人不能流眼泪</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ grep -n &quot;外婆&quot; jaychou_lyrics.txt | grep -v &quot;期待&quot;</span><br><span class="line">579:我想带你 回我的外婆家</span><br><span class="line">595:我想带你 回我的外婆家</span><br><span class="line">2267:今天是外婆生日</span><br><span class="line">2269:载着外婆开着拉风的古董车兜兜兜风</span><br><span class="line">2274:外婆她脸上的涟漪</span><br><span class="line">2288:外婆她的无奈</span><br><span class="line">2294:记得去年外婆的生日</span><br><span class="line">2295:表哥带我和外婆参加</span><br><span class="line">2304:是因为看到外婆失落而失落</span><br><span class="line">2313:我告诉外婆 我没输 不需要改变</span><br><span class="line">2316:只要外婆觉得好听</span><br><span class="line">2318:外婆露出了笑容 说她以我为荣</span><br><span class="line">2327:外婆她的无奈</span><br><span class="line">2339:外婆她的无奈</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ grep -n -e &quot;^我&quot; jaychou_lyrics.txt</span><br><span class="line">5:我每天每天每天在想想想想著你</span><br><span class="line">24:我每天每天每天在想想想想著你</span><br><span class="line">51:我想要将我的寂寞封闭</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 太多了，略去部分输出</span></span></span><br><span class="line">5788:我唱的歌词要有点文化 因為随时会被当教材</span><br><span class="line">5811:我到底是一个创作歌手</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ grep -n -e &quot;我$&quot; jaychou_lyrics.txt</span><br><span class="line">82:随风跟著我</span><br><span class="line">120:你在那里 在小村外的溪边河口默默等著我</span><br><span class="line">132:默默的在等著我</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 太多了，略去部分输出</span></span></span><br><span class="line">5361:人群散了后 夜色多朦朧 月光也會跟著我</span><br><span class="line">5365:人群散了后 夜色多朦朧 月光也會跟著我</span><br></pre></td></tr></table></figure><ol start="3"><li><code>sed</code> 文本替换</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ sed -e &#x27;2,40d&#x27; jaychou_lyrics.txt</span><br><span class="line">想要有直升机</span><br><span class="line">透明的让我感动的可爱女人</span><br><span class="line">坏坏的让我疯狂的可爱女人</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 省略其余输出</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ sed -n -e &#x27;/我/p&#x27; jaychou_lyrics.txt | sed &#x27;s/我/你/g&#x27;</span><br><span class="line">你每天每天每天在想想想想著你</span><br><span class="line">让你开始乡相信命运</span><br><span class="line">让你碰到你</span><br><span class="line">漂亮的让你面红的可爱女人</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 太多了，省略部分输出</span></span></span><br><span class="line">拯救地球好累 虽然有些疲惫 但你还是会</span><br><span class="line">不要问你哭过了没 因為超人不能流眼泪</span><br></pre></td></tr></table></figure><hr><h1>文件目录查找</h1><h2 id="find"><code>find</code></h2><p><code>find</code> 命令用于在指定目录下查找文件。</p><p>用法：<code>find &lt;path&gt; &lt;参数&gt; [-exec &lt;命令&gt; &#123;&#125; \]</code></p><p>参数前的字符串视为欲查找的目录名，如果不指定目录名则在当前目录下查找。</p><p>常用参数：</p><ul><li><p><code>-name &lt;文件名&gt;</code>：文件名满足要求的文件。使用 <code>-iname</code> 可以忽略大小写</p></li><li><p><code>-type &lt;类型&gt;</code>：文件类型满足要求的文件。类型包括：</p><ul><li><code>d</code>：目录</li><li><code>f</code>：一般文件</li><li>其他：<code>c</code>、<code>b</code>、<code>p</code>、<code>l</code>、<code>s</code></li></ul></li><li><p><code>-perm &lt;id&gt;</code>：具有特定权限的文件</p></li><li><p><code>-user &lt;user&gt;</code>：根据文件属主查找文件</p></li><li><p><code>-amin &lt;n&gt;</code>：查找系统中最后 n 分钟访问的文件</p></li><li><p><code>-cmin &lt;n&gt;</code>：查找系统中最后 n 分钟被改变文件状态的文件</p></li><li><p><code>-mmin &lt;n&gt;</code>：查找系统中最后 n 分钟被改变文件数据的文件（对于上述三个命令，如果前面是 <code>-</code>，限制的是距当前一定时间内；而如果换用 <code>+</code>，限制的是距当前一定时间前。</p></li><li><p><code>-empty</code>：空文件</p></li><li><p><code>-exec &lt;command&gt; &#123; &#125; \;</code>：对 <code>find</code> 所匹配的文件执行该参数所给出的命令。如将 <code>exec</code> 换为 <code>ok</code>，则是以一种更安全的模式执行命令，在执行每个命令之前提示用户询问是否执行。</p></li></ul><p>使用示例可参见 <a href="https://www.runoob.com/w3cnote/linux-common-command-2.html">Linux 常用命令学习 | 菜鸟教程 (runoob.com)</a> 之 17。</p><h2 id="locate"><code>locate</code></h2><p><code>locate</code> 命令通过搜寻系统内建文档数据库查找符合条件的文档</p><p>用法：<code>locate &lt;参数&gt; &lt;范本样式...&gt;</code></p><p>常用参数：</p><ul><li><code>-r &lt;reg&gt;</code>：使用正则表达式匹配</li><li><code>-l &lt;num&gt;</code>：限定输出的条目数</li><li><code>-c</code>：只输出找到的数量</li><li><code>-q</code>：不显示错误输出</li><li><code>-i</code>：忽略大小写</li></ul><h2 id="实战：文件目录查找">实战：文件目录查找</h2><ol><li>使用 <code>find</code> 统计文件系统中以 <code>py</code> 为后缀名的文件个数</li><li>使用 <code>find</code> 寻找 <code>/home/</code> 文件夹下文件内容包含 datawhale 的文件</li><li>使用 <code>locate</code> 寻找到 <code>python3.6.1.gz</code> 文件</li></ol><p>实操：</p><ol><li>统计文件个数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 这个为什么一定要用 find 呢，locate -c 不是更简单</span></span></span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$ find / -name &quot;*.py&quot; | wc -l # 使用 wc 对输出的换行符数进行统计，即可获知文件数量</span><br><span class="line">find: ‘/proc/tty/driver’: Permission denied</span><br><span class="line">find: ‘/proc/1/task/1/fd’: Permission denied</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 省略其他无权限报错</span></span></span><br><span class="line">find: ‘/boot/grub2’: Permission denied</span><br><span class="line">5907</span><br></pre></td></tr></table></figure><ol start="2"><li>发现包含特定内容的文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅用 find 并不能根据文件内容发现文件，需要结合 grep 使用</span></span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$ find /home -type f -exec grep -l &quot;datawhale&quot; &#123;&#125; \;</span><br><span class="line">/home/datawhale/.bash_history</span><br><span class="line">/home/datawhale/jane/affairs.pyc</span><br><span class="line">/home/datawhale/gjb/__pycache__/affairs.cpython-36.pyc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 符合条件文件过多，省略部分输出</span></span></span><br><span class="line">/home/datawhale/geyashi.tar</span><br><span class="line">/home/datawhale/chen.tar</span><br><span class="line">/home/datawhale/zyc.zip</span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$</span><br></pre></td></tr></table></figure><ol start="3"><li>找到特定文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ locate python3.6.1.gz</span><br><span class="line">/usr/share/man/man1/python3.6.1.gz</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基础操作学习(2)：Python 交互</title>
      <link href="/posts/4449c636/"/>
      <url>/posts/4449c636/</url>
      
        <content type="html"><![CDATA[<h1>Python OS SYS</h1><h2 id="OS-库">OS 库</h2><p>之前的 <a href="https://blog.mariozzj.cn/posts/672ba085/#%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C">Linux 基础教程</a> 中提到了一些可用于目录操作、文件操作的命令，在理解上述知识的基础上我们便可以很快上手 Python <code>os</code> 库的大多数方法。在 <a href="https://www.runoob.com/python/os-file-methods.html">Python OS 文件/目录方法 | 菜鸟教程 (runoob.com)</a> 中列出了多达 64 个方法，这里选取几个常用方法介绍。</p><h3 id="os-chdir"><code>os.chdir()</code></h3><p>作用：改变当前工作目录（change directory），作用类似于 Shell 命令 <code>cd</code>。</p><p>语法格式：<code>os.chdir(path)</code></p><p>参数：</p><ul><li><code>path</code>：要切换到的路径</li></ul><p>返回值：如果允许访问返回 <code>True</code>，否则返回 <code>False</code>。</p><h3 id="os-getcwd"><code>os.getcwd()</code></h3><p>作用：返回当前工作目录（get current working directory），作用类似于 Shell 命令 <code>pwd</code>。</p><p>语法格式：<code>os.getcwd()</code></p><p>返回值：返回当前进程的工作目录</p><h3 id="os-listdir"><code>os.listdir()</code></h3><p>作用：返回指定文件夹包含的文件或文件夹的名字的列表（list directory），作用类似于 Shell 命令 <code>ls</code>。</p><p>语法格式：<code>os.listdir(path)</code></p><p>参数：</p><ul><li><code>path</code>：需要列出的目录路径</li></ul><p>返回值：指定路径 <code>path</code> 下包含的文件或文件夹的名字的列表</p><h3 id="os-mkdir"><code>os.mkdir()</code></h3><p>作用：以指定权限模式创建文件夹（make directory），作用类似于 Shell 命令 <code>mkdir</code>。</p><p>语法格式：<code>os.mkdir(path[,mode])</code></p><p>参数：</p><ul><li><code>path</code>：要创建的目录路径</li><li><code>mode</code>：八进制整数，为目录设置的权限数字模式。默认为 0777。</li></ul><h3 id="os-mkdirs"><code>os.mkdirs()</code></h3><p>作用：以递归方式创建文件夹（make directories），作用类似于 Shell 命令 <code>mkdir -p</code>。</p><p>语法格式：<code>os.mkdirs(path[,mode])</code></p><p>参数：同 <code>os.mkdir()</code></p><h3 id="os-remove"><code>os.remove()</code></h3><p>作用：删除指定路径的文件（remove），作用类似于 Shell 命令 <code>rm</code>。</p><p>语法格式：<code>os.remove(path)</code></p><p>参数：</p><ul><li><code>path</code>：要删除的文件路径</li></ul><p>返回值：无返回值，但如果 <code>path</code> 是一个文件夹，会抛出 <code>OSError</code>。</p><h3 id="os-rmdir"><code>os.rmdir()</code></h3><p>作用：删除指定路径的空目录（remove directory），作用类似于 Shell 命令 <code>rmdir</code>。</p><p>语法格式：<code>os.rmdir(path)</code></p><p>参数：</p><ul><li><code>path</code>：要删除的空目录路径</li></ul><p>返回值：无返回值，但如果 <code>path</code> 是非空目录，会抛出 <code>OSError</code>。</p><h3 id="os-removedirs"><code>os.removedirs()</code></h3><p>作用：递归地删除目录，如果子文件夹成功删除继续尝试父文件夹，直到抛出 <code>Error</code>。作用类似 <code>rmdir -p</code></p><p>语法格式：<code>os.removedirs(path)</code></p><p>参数：</p><ul><li><code>path</code>：要删除的目录路径</li></ul><h3 id="os-open"><code>os.open()</code></h3><p>作用：以指定打开选项打开一个文件。</p><p>语法格式：<code>os.open(file,flags)</code></p><p>参数：</p><ul><li><code>file</code>：要打开的文件路径</li><li><code>flags</code>：打开模式参数，可以是以下选项，多个则使用 <code>|</code> 隔开：<ul><li><code>os.O_RDONLY</code>: 以只读的方式打开</li><li><code>os.O_WRONLY</code>: 以只写的方式打开</li><li><code>os.O_RDWR</code> : 以读写的方式打开</li><li><code>os.O_NONBLOCK</code>: 打开时不阻塞</li><li><code>os.O_APPEND</code>: 以追加的方式打开</li><li><code>os.O_CREAT</code>: 创建并打开一个新文件</li><li><code>os.O_TRUNC</code>: 打开一个文件并截断它的长度为零（必须有写权限）</li><li><code>os.O_EXCL</code>: 如果指定的文件存在，返回错误</li><li><code>os.O_SHLOCK</code>: 自动获取共享锁</li><li><code>os.O_EXLOCK</code>: 自动获取独立锁</li><li><code>os.O_DIRECT</code>: 消除或减少缓存效果</li><li><code>os.O_FSYNC</code> : 同步写入</li><li><code>os.O_NOFOLLOW</code>: 不追踪软链接</li></ul></li><li><code>mode</code>：权限，默认为 0777，可以用以下选项按位生成：<ul><li><code>stat.S_IXOTH</code>: 其他用户有执行权0o001</li><li><code>stat.S_IWOTH</code>: 其他用户有写权限0o002</li><li><code>stat.S_IROTH</code>: 其他用户有读权限0o004</li><li><code>stat.S_IRWXO</code>: 其他用户有全部权限(权限掩码)0o007</li><li><code>stat.S_IXGRP</code>: 组用户有执行权限0o010</li><li><code>stat.S_IWGRP</code>: 组用户有写权限0o020</li><li><code>stat.S_IRGRP</code>: 组用户有读权限0o040</li><li><code>stat.S_IRWXG</code>: 组用户有全部权限(权限掩码)0o070</li><li><code>stat.S_IXUSR</code>: 拥有者具有执行权限0o100</li><li><code>stat.S_IWUSR</code>: 拥有者具有写权限0o200</li><li><code>stat.S_IRUSR</code>: 拥有者具有读权限0o400</li><li><code>stat.S_IRWXU</code>: 拥有者有全部权限(权限掩码)0o700</li><li><code>stat.S_ISVTX</code>: 目录里文件目录只有拥有者才可删除更改0o1000</li><li><code>stat.S_ISGID</code>: 执行此文件其进程有效组为文件所在组0o2000</li><li><code>stat.S_ISUID</code>: 执行此文件其进程有效用户为文件所有者0o4000</li><li><code>stat.S_IREAD</code>: windows下设为只读</li><li><code>stat.S_IWRITE</code>: windows下取消只读</li></ul></li></ul><p>返回值：返回新打开文件的描述符。</p><h3 id="os-close"><code>os.close()</code></h3><p>作用：关闭指定的文件描述符</p><p>语法格式：<code>os.close(fd)</code></p><p>参数：</p><ul><li><code>fd</code>：文件描述符</li></ul><h3 id="os-dup2"><code>os.dup2()</code></h3><p>作用：将指定文件描述符复制到指定文件描述符</p><p>语法格式：<code>os.dup2(fd1,fd2)</code></p><p>参数：</p><ul><li><code>fd1</code>：要被复制的文件描述符</li><li><code>fd2</code>：复制的文件描述符</li></ul><h3 id="os-rename"><code>os.rename()</code></h3><p>作用：重命名文件或目录</p><p>语法格式：<code>os.rename(src, dst)</code></p><p>参数：</p><ul><li><code>src</code>：要修改的目录名</li><li><code>dst</code>：修改后的目录名</li></ul><h3 id="os-path"><code>os.path</code></h3><p><code>os.path</code> 模块主要用于获取文件的路径，具有很多方法，详见 <a href="https://www.runoob.com/python/python-os-path.html">Python os.path() 模块 | 菜鸟教程 (runoob.com)</a>。</p><h3 id="os-walk"><code>os.walk()</code></h3><p>作用：<strong>迭代</strong>遍历目录，返回指定目录及其子目录下的文件名</p><p>语法格式：<code>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</code></p><p>参数：</p><ul><li><code>top</code>：要遍历的目录的地址</li><li><code>topdown</code>：默认为 <code>True</code>，优先遍历 <code>top</code> 目录，否则优先遍历子目录</li><li><code>onerror</code>：默认为 <code>None</code>，可填入 callable 对象以供 <code>walk()</code> 异常时调用</li><li><code>followlinks</code>：默认为 <code>False</code>；若为 <code>True</code>，则会遍历目录下的快捷方式（软连接）所指向的目录。</li></ul><p>返回值：返回一个生成器，是一个三元组 <code>(root, dirs, files)</code></p><ul><li><code>root</code>：当前正在遍历的这个文件夹本身的地址</li><li><code>dirs</code>：一个 <code>list</code>，内容是该文件夹中所有目录的名字（不包括子目录）</li><li><code>files</code>：一个 <code>list</code>，内容是该文件夹中所有的文件（不包括子目录）</li></ul><p><code>walk()</code> 与 <code>listdir()</code> 主要的不同点：<strong>迭代</strong>。即前者会访问子目录</p><h2 id="SYS-库">SYS 库</h2><p><code>sys</code> 库同样也是 Python 的内置库，下面介绍几个该库常见的方法或成员变量。</p><h3 id="sys-argv"><code>sys.argv</code></h3><p>获取脚本执行参数列表。一般来说 Python 程序执行参数的第一个参数（<code>sys.argv[0]</code>）是当前文件名。</p><h3 id="sys-path"><code>sys.path</code></h3><p>获取 Python 目录列表。列表中的这些目录供 Python 在其中查找安装的其他模块。在 Python 启动时，<code>sys.path</code> 根据内建规则和 <code>PYTHONPATH</code> 变量进行初始化。这个列表的第一个元素表示当前目录，在交互环境下通常是空字符串。</p><h3 id="sys-platform"><code>sys.platform</code></h3><p>获取当前运行的平台。如 <code>win32</code>、<code>linux</code>。</p><h3 id="sys-stdin"><code>sys.stdin</code></h3><p>Python 的标准输入通道，默认为键盘输入字符。可以将该属性的值改为文件，这样，调用标准输入的方法（如 <code>input()</code>）就会改为从文件读入。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">sys.stdin = f</span><br><span class="line">x = <span class="built_in">input</span>()</span><br><span class="line">    <span class="comment"># 随后屏幕不会提示输入内容，而是直接从文件读取第一行不包含换行符的内容</span></span><br></pre></td></tr></table></figure><h3 id="sys-stdout"><code>sys.stdout</code></h3><p>Python 的标准输出通道，默认为屏幕。也可以将该属性的值进行更改，调整输出流。</p><h3 id="sys-err"><code>sys.err</code></h3><p>Python 的标准错误输出流，默认为屏幕。</p><h2 id="实战">实战</h2><h3 id="使用-Python-打印命令行参数">使用 Python 打印命令行参数</h3><ol><li>在 <code>home/datawhale</code> 目录下，昵称文件夹中新建 <code>test5.py</code></li><li>脚本使用 <code>sys</code> 模块实现打印命令行参数功能</li></ol><p>实操：</p><ol><li><p>创建文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ touch test5.py</span><br></pre></td></tr></table></figure></li><li><p>编辑脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ vim test5.py</span><br></pre></td></tr></table></figure><p>脚本内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br></pre></td></tr></table></figure></li><li><p>脚本运行与结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ python test5.py argument1 argument2</span><br><span class="line">test5.py</span><br><span class="line">argument1</span><br><span class="line">argument2</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用-Python-扫描文件目录">使用 Python 扫描文件目录</h3><ol><li>在 <code>home/datawhale</code> 目录下，昵称文件夹中新建 <code>test5.py</code></li><li>脚本使用 <code>os</code> 模块实现打印 <code>/usr/bin</code> 路径下所有以 m 开头的文件</li></ol><p>实操：</p><ol><li><p>创建文件（略）</p></li><li><p>编辑脚本</p><p>脚本内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(<span class="string">&#x27;/usr/bin&#x27;</span>):</span><br><span class="line">    <span class="comment"># listdir 展示列表包含目录和文件，所以需要条件过滤</span></span><br><span class="line">    <span class="keyword">if</span> filename[<span class="number">0</span>] == <span class="string">&#x27;m&#x27;</span> <span class="keyword">and</span> os.path.isfile(<span class="string">&#x27;/usr/bin/&#x27;</span>+filename):</span><br><span class="line">        <span class="built_in">print</span>(filename)</span><br></pre></td></tr></table></figure></li><li><p>脚本运行与结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ python test5.py</span><br><span class="line">makedb</span><br><span class="line">make</span><br><span class="line">md5sum</span><br><span class="line">mkdir</span><br><span class="line">mkfifo</span><br><span class="line">mknod</span><br><span class="line">mktemp</span><br><span class="line">mv</span><br><span class="line">mesg</span><br><span class="line">mount</span><br><span class="line">msgattrib</span><br><span class="line">msgcat</span><br><span class="line">msgcmp</span><br><span class="line">msgcomm</span><br><span class="line">msgconv</span><br><span class="line">msgen</span><br><span class="line">msgexec</span><br><span class="line">msgfilter</span><br><span class="line">msgfmt</span><br><span class="line">msggrep</span><br><span class="line">msghack</span><br><span class="line">msginit</span><br><span class="line">msgmerge</span><br><span class="line">msgunfmt</span><br><span class="line">msguniq</span><br><span class="line">miniterm.py</span><br><span class="line">modutil</span><br><span class="line">mcookie</span><br><span class="line">more</span><br><span class="line">man</span><br><span class="line">mountpoint</span><br><span class="line">mkinitrd</span><br><span class="line">machinectl</span><br><span class="line">mapscrn</span><br><span class="line">mailq.postfix</span><br><span class="line">mailq</span><br><span class="line">manpath</span><br><span class="line">mandb</span><br></pre></td></tr></table></figure></li></ol><hr><h1>Python 模块化</h1><p>Python 模块是一个 Python 脚本文件，其中可包含自定义的对象、方法、变量等，供其他 Python 脚本使用。</p><h2 id="引入模块">引入模块</h2><h3 id="import-语句"><code>import</code> 语句</h3><p>Python 脚本文件的后缀是 <code>.py</code>，通过 <code>import</code> 语句，可以实现对 Python 模块的引入。</p><p>如之前提到的 <code>sys</code> 库，当我们 <code>import sys</code> 时，实际上就引入了 Python 标准库中的 <code>sys.py</code> 模块。引入之后就可以使用 <code>sys.*</code> 调用 <code>sys.py</code> 中的方法或变量。</p><p>也可以使用 <code>as</code> 子句将引入的模块重命名。<code>import sys as syst</code></p><h3 id="name-属性"><code>__name__</code> 属性</h3><p>**当一个模块被另一程序第一次引入时，其主程序将运行。**如果我们想在模块被引入时模块中的某一程序块不被执行，可以使用 <code>__name__</code> 属性来使该程序块仅在该模块自身运行时执行。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;程序自身在运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python using_name.py</span></span><br><span class="line">程序自身在运行</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import using_name</span></span><br><span class="line">我来自另一模块</span><br></pre></td></tr></table></figure><h3 id="from-import-语句"><code>from ... import ...</code> 语句</h3><p>使用该语句可以从模块中导入指定部分到当前命名空间，如我们仅仅想引入 <code>sys</code> 中的 <code>sys.argv</code>，可以使用 <code>from sys import argv</code>，后面可以直接使用 <code>argv</code> 变量（而不是使用 <code>sys.argv</code>）。</p><p>这里也支持引入某模块的所有子对象，即 <code>from [module_name] import *</code>，但是一般不这么做，因为在很多库中子对象较多，会占用较大命名空间，随后自其他来源创建或引入的命名可能会与之矛盾。</p><h2 id="包">包</h2><p>包是一种管理 Python 模块命名空间的形式，它是一个分层次的文件目录结构，定义了一个由模块及子包，和子包下的子包等组成的 Python 应用环境。</p><p>形如 <code>A.B</code> 的模块中，<code>A</code> 一般为包名，<code>B</code> 为包 <code>A</code> 的子模块。在文件系统中体现为名为 <code>A</code> 的文件夹下的 <code>B.py</code>。</p><p>为了避免非包文件夹被识别为包，只有目录下包含 <code>__init__.py</code> 的文件夹才会被识别为一个包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/Package_a/</span><br><span class="line">    |----    __init__.py</span><br><span class="line">    |----           B.py</span><br><span class="line">    |----    not_package_folder # 没有 init，不是包</span><br><span class="line">                  | -------    C.py</span><br></pre></td></tr></table></figure><h2 id="实战：在目录下创建包目录，并导入">实战：在目录下创建包目录，并导入</h2><ol><li><p>在 <code>home/datawhale</code> 目录下，昵称文件夹中新建 <code>affairs</code> 文件夹和 <code>test6.py</code> 文件，<code>affairs</code> 文件夹中新建 <code>affairs.py</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/home/datawhale/</span><br><span class="line">     MarioZZJ/</span><br><span class="line">     test6.py</span><br><span class="line">     affairs/</span><br><span class="line">     affairs.py</span><br></pre></td></tr></table></figure></li><li><p><code>affairs.py</code> 可完成 <a href="https://mirror.coggle.club/dataset/affairs.txt">https://mirror.coggle.club/dataset/affairs.txt</a> 的读取（<code>pandas.read_csv()</code>）</p></li><li><p><code>test6.py</code> 可以导入 <code>affairs.py</code> 代码，并进行命令行解析，输出 <code>affairs.txt</code> 的具体第几行内容（行数由命令行参数指定）</p></li></ol><p>实操：</p><ol><li><p>新建文件和文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ touch test6.py</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ mkdir affairs</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ cd affairs</span><br><span class="line">[I have no name!@i-ym8u2kyp affairs]$ touch affairs.py</span><br></pre></td></tr></table></figure></li><li><p>编辑 <code>affairs.py</code> 脚本，内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_line</span>(<span class="params">line_num</span>):</span><br><span class="line">        txt = pd.read_csv(<span class="string">&#x27;https://mirror.coggle.club/dataset/affairs.txt&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> line_num &gt; <span class="built_in">len</span>(txt):</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;Input line number exceeded lenth of file.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> txt.iloc[line_num]</span><br></pre></td></tr></table></figure><p>因为 <code>affairs.py</code> 模块在 <code>affairs</code> 文件夹中，而 <code>test6.py</code> 与 <code>affairs</code> 文件夹在同一层级，所以需要通过引入 <code>affairs</code> 包的子模块 <code>affairs</code> 实现模块引入，而目前 <code>affairs</code> 文件夹下没有 <code>__init__.py</code> ，该目录不能被识别为包，所以需要创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp affairs]$ touch __init__.py</span><br><span class="line">[I have no name!@i-ym8u2kyp affairs]$ ls</span><br><span class="line">affairs.py  __init__.py</span><br></pre></td></tr></table></figure></li><li><p>编辑 <code>test6.py</code> 脚本，内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ cat test6.py</span><br><span class="line"><span class="keyword">from</span> affairs <span class="keyword">import</span> affairs</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: <span class="comment"># 输入参数为字符串，需转换为整数。因为行数比索引值多 1，须加 1</span></span><br><span class="line"><span class="built_in">print</span>(affairs.parse_line(<span class="built_in">int</span>(sys.argv[<span class="number">1</span>]))+<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>运行 <code>test6.py</code> 脚本实现文件第 10 行的输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ python3 test6.py <span class="number">10</span></span><br><span class="line">rate_marriage     <span class="number">4.0</span></span><br><span class="line">age              <span class="number">23.0</span></span><br><span class="line">yrs_married       <span class="number">3.5</span></span><br><span class="line">children          <span class="number">1.0</span></span><br><span class="line">religious         <span class="number">3.0</span></span><br><span class="line">affairs           <span class="number">2.0</span></span><br><span class="line">Name: <span class="number">10</span>, dtype: float64</span><br></pre></td></tr></table></figure></li></ol><hr><h1>Linux 后台运行、关闭与查看后台任务</h1><h2 id=""><code>&amp;</code></h2><p>在命令的最后添加 <code>&amp;</code>，即可将该命令放到后台执行，此时交互终端可以进行其他操作，而不是默认打印当前命令的输出并等待到进程结束。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 test.py &amp;</span><br></pre></td></tr></table></figure><p>含 <code>&amp;</code> 的后台运行任务在后台执行，要求<strong>当前终端不能关闭</strong>。如果终端被关闭（除使用 <code>Ctrl+D</code> 关闭的方法外），执行的这条命令也会随之终止。</p><h2 id="nohup"><code>nohup</code></h2><p>在命令之前添加 <code>nohup</code>，可将该命令放到后台执行。与 <code>&amp;</code> 有所不同的是，使用 <code>nohup</code> 执行的后台任务在账户退出/终端关闭时仍然继续执行。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup python3 test.py</span><br><span class="line"><span class="comment"># 此时终端会提示：</span></span><br><span class="line">nohup: ignoring <span class="built_in">input</span> <span class="keyword">and</span> appending output to ‘nohup.out’</span><br></pre></td></tr></table></figure><p>如上，使用 <code>nohup</code> 后会提示忽略输入，输出日志将打印到工作目录下的 <code>nohup.out</code> 文件。此时如果关闭终端，命令仍然会在后台执行。如果不关闭终端，此时的终端是无法交互的。所以如果既要让命令在退出后仍可运行，又想继续和终端交互，可以将 <code>nohup</code> 和 <code>&amp;</code> 一起使用，即：<code>nohup [command] &amp;</code>。</p><p>如果想指定输出文件的位置（而不是 <code>nohup.out</code>），可以利用 Linux 的<strong>输出重定向</strong>符号 <code>&gt;</code>：<code>nohup [command] &gt; output.log &amp;</code></p><h2 id="Ctrl-Z"><code>Ctrl+Z</code></h2><p>在命令执行过程中，按下 <code>Ctrl+Z</code> 可以挂起进程，此时该进程处于<strong>暂停</strong>状态，即不继续执行进程且稍后可以恢复。</p><h2 id="jobs"><code>jobs</code></h2><p>使用 <code>jobs</code> 命令可以显示当前控制台创建的任务。 jobs 的状态可以是 <code>running</code>， <code>stopped</code>， <code>Terminated</code>。如使用 <code>jobs -l</code> 可以查看所有后台运行任务的 <code>pid</code>，这样可以根据 <code>pid</code> 操作对应进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ jobs -l</span><br><span class="line">[1]+ 18860 Running                 python3 test_temp.py &amp;</span><br></pre></td></tr></table></figure><p>（<code>[ ]</code> 内为进程 job 号，如这里为 1；后面为 <code>pid</code>，如这里为 18860）</p><h2 id="bg"><code>bg</code></h2><p>使用 <code>bg</code> 命令可以将后台<strong>暂停</strong>的命令变为在后台<strong>继续执行</strong>。（back go）</p><p>语法格式： <code>bg &lt;jobid&gt;</code></p><p>该命令可以和 <code>Ctrl+Z</code> 、<code>jobs</code> 较好配合使用。一般常用的做法如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ nohup python3 test_temp.py # 单独 nohup 执行命令</span><br><span class="line">nohup: ignoring input and appending output to ‘nohup.out’</span><br><span class="line">^Z # 使用 Ctrl + Z 挂起进程</span><br><span class="line">[1]+  Stopped                 nohup python3 test_temp.py # 进程的状态为 Stopped</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ jobs -l # jobs 查看所有后台进程，1 状态 stopped</span><br><span class="line">[1]+ 20145 Stopped                 nohup python3 test_temp.py</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ bg 1 # bg 让 1 在后台继续执行</span><br><span class="line">[1]+ nohup python3 test_temp.py &amp;</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ jobs -l # jobs 查看所有后台进程，1 状态 running</span><br><span class="line">[1]+ 20145 Running                 nohup python3 test_temp.py &amp;</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$</span><br></pre></td></tr></table></figure><h2 id="fg"><code>fg</code></h2><p>使用 <code>fg</code> 命令可以将后台命令变为在<strong>前台</strong>执行。（fore go）</p><p>语法格式：<code>fg [jobid]</code></p><h2 id="kill"><code>kill</code></h2><p>使用 <code>kill</code> 命令可以结束（kill）进程。</p><p>语法格式：</p><ol><li><code>kill %&lt;jobid&gt;</code></li><li><code>kill &lt;pid&gt;</code></li></ol><h2 id="tmux">tmux</h2><p><code>tmux</code> 是一个终端复用软件，使用 <code>tmux</code> 可以实现在一个终端登录远程主机，并在该终端窗口中运行多个终端对话，也可按需使终端会话运行于后台或是按需接入、断开会话。下面列出 tmux 的主要操作，更多详细操作可参见 <a href="https://www.cnblogs.com/wangqiguo/p/8905081.html">Tmux终端复用详解 (cnblogs.com)</a> 。</p><h3 id="安装">安装</h3><p>以我所使用的 CentOS 系统为例，需要先安装 <code>tmux</code> 才可使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y tmux</span><br></pre></td></tr></table></figure><h3 id="创建会话">创建会话</h3><p>使用 <code>tmux</code> 即可打开软件（单独使用 <code>tmux</code> 命令会创建一个会话，以数字命名），可以加上命令 <code>new -s</code> 对创建的会话进行命名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s name</span><br></pre></td></tr></table></figure><p><img src="https://download.mariozzj.cn/img/picgo/202112211127110.png" alt="tmux 界面"></p><h3 id="列出创建的所有会话">列出创建的所有会话</h3><p>添加命令 <code>ls</code> 即可列出创建的所有会话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ tmux ls</span><br><span class="line">0: 1 windows (created Tue Dec 21 11:13:19 2021) [120x34]</span><br><span class="line">name: 1 windows (created Tue Dec 21 11:25:02 2021) [88x15] (attached)</span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$</span><br></pre></td></tr></table></figure><h3 id="登录一个会话">登录一个会话</h3><p>添加命令 <code>attach</code> （或简写为 <code>a</code>）并附加参数 <code>-t &lt;会话名&gt;</code> 即可使用 tmux 登录一个已知会话。</p><h3 id="退出会话">退出会话</h3><ul><li>依次按 <code>Ctrl+b</code>、<code>d</code> 即可退出会话，但不关闭该会话。</li><li>按 <code>Ctrl+d</code> 退出并直接关闭该会话</li><li><code>tmux kill-session -t &lt;会话名&gt;</code> 可以销毁指定会话。</li></ul><h3 id="快捷键">快捷键</h3><p>进入 tmux 面板后，按 <code>Ctrl+b</code> 再按其他按键，即可进行一系列快捷操作：</p><table><thead><tr><th>Ctrl+b</th><th>按键</th><th>说明</th></tr></thead><tbody><tr><td><code>ctrl</code>+<code>b</code></td><td><code>?</code></td><td>显示快捷键帮助</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>[space]</code></td><td>采用下一个内置布局，这个很有意思，在多屏时，用这个就会将多有屏幕竖着展示</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>!</code></td><td>把当前窗口变为新窗口</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>&quot;</code></td><td>模向分隔窗口</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>%</code></td><td>纵向分隔窗口</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>q</code></td><td>显示分隔窗口的编号</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>o</code></td><td>跳到下一个分隔窗口。多屏之间的切换</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>↑</code>/<code>↓</code></td><td>上一个及下一个分隔窗口</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>C</code>+<code>↑</code>/<code>↓</code>/<code>←</code>/<code>→</code></td><td>调整分隔窗口大小</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>&amp;</code></td><td>确认后退出当前 tmux</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>[</code></td><td>复制模式，即将当前屏幕移到上一个的位置上，其他所有窗口都向前移动一个。</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>c</code></td><td>创建新窗口</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>n</code></td><td>选择下一个窗口</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>l</code></td><td>最后使用的窗口</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>p</code></td><td>选择前一个窗口</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>w</code></td><td>以菜单方式显示及选择窗口</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>s</code></td><td>以菜单方式显示和选择会话。这个常用到，可以选择进入哪个 tmux</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>t</code></td><td>显示时钟。然后按 <code>enter</code> 键后就会恢复到 shell 终端状态</td></tr><tr><td><code>ctrl</code>+<code>b</code></td><td><code>d</code></td><td>脱离当前会话；这样可以暂时返回 Shell 界面，输入 <code>tmux attach</code> 能够重新进入之前的会话</td></tr></tbody></table><h2 id="实战：在-Linux-系统后台运行应用程序，并打印日志">实战：在 Linux 系统后台运行应用程序，并打印日志</h2><ol><li>在 <code>home/datawhale</code> 目录下，昵称文件夹中新建 <code>sleep.py</code> 文件，该脚本能一直运行并每隔 10 秒输出当前时间</li><li>使用适当的命令能使该程序后台运行，并将输出结果写入 txt 文件。</li></ol><p>实操：</p><ol><li><p>创建脚本，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span>(time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,time.localtime()))</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p>利用 <code>nohup</code>、<code>&amp;</code> 命令和输出重定向实现后台运行，并查看日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ nohup python3 sleep.py &gt; output.log &amp; # 后台运行</span><br><span class="line">[1] 15563</span><br><span class="line">nohup: ignoring input and redirecting stderr to stdout</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ jobs -l # 查看 job，刚才的任务正在运行</span><br><span class="line">[1]+ 15563 Running                 nohup python3 sleep.py &gt; output.log &amp;</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ cat output.log # 查看输出内容，结果为空！！</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$</span><br></pre></td></tr></table></figure><p>出现问题：使用 <code>cat</code> 查看输出的日志内容，为空！</p><p>查询资料后发现原因：Python 的两个输出流 <code>stdout</code> 和 <code>stderr</code> 都是默认指向屏幕，我们的命令将其输出重定向到文件，但是二者机制不同。<code>stderr</code> 无缓存，程序每往 <code>stderr</code> 输出时都会立刻输出到指定的目标，而 <code>stdout</code> 有缓存，只有遇到需要清空缓存的情况才会向目标输出（如输出为屏幕时的换行，程序结束时的缓存清空等），为使运行过程中输出内容可以实时输出至日志，可以为 <code>python</code> 命令附加 <code>-u</code> 参数以取消缓存。</p><p>重新操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ nohup python3 -u sleep.py &gt; outlog.txt &amp;</span><br><span class="line">[1] 18442</span><br><span class="line">nohup: ignoring input and redirecting stderr to stdout</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ jobs -l</span><br><span class="line">[1]+ 18442 Running                 nohup python3 -u sleep.py &gt; outlog.txt &amp;</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ cat outlog.txt</span><br><span class="line">2021-12-21 15:29:44</span><br><span class="line">2021-12-21 15:29:54</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基础操作学习(1)：连接与文件操作</title>
      <link href="/posts/672ba085/"/>
      <url>/posts/672ba085/</url>
      
        <content type="html"><![CDATA[<h1>Windows 远程连接 Linux 环境</h1><p>我的 PC 是 Windows 11 操作系统，而我购置的服务器安装的是 Linux 环境（CentOS），如需用 PC 操作服务器，则需要建立 PC 和远程服务器的远程连接。</p><p>我这里使用到的工具是 Windows 自带的 Powershell，<code>Win</code>+<code>R</code> 输入 <code>powershell</code> 即可打开。</p><p>这里顺便推荐一波 Windows Terminal 作为默认终端程序打开 Powershell，非常美观！而且有很多配置可调。</p><p><img src="https://download.mariozzj.cn/img/picgo/202112131906030.png" alt="Powershell - Windows Terminal"></p><p>Powershell 自带支持 <code>ssh</code> 命令。直接输入 <code>ssh &#123;user&#125;@&#123;ip&#125;</code> 即可建立连接。</p><p><img src="https://download.mariozzj.cn/img/picgo/202112131910807.png" alt="ssh 连接"></p><p>最后一行 <code>[]</code> 内显示 <code>&#123;用户名&#125;@&#123;主机名&#125; &#123;目录&#125;</code> 时，说明已经进入 Linux 终端。</p><hr><h1>目录操作</h1><p>登录系统后输入 <code>ls /</code> 后即可查看<code>/</code>，即根目录下所有目录和文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ ls /</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><p>各个目录的功能可参见 <a href="https://www.runoob.com/linux/linux-system-contents.html">Linux 系统目录结构 | 菜鸟教程 (runoob.com)</a>。</p><p>Linux 系统的文件路径有 <strong>绝对路径</strong> 和 <strong>相对路径</strong> 两种写法：</p><ul><li><strong>绝对路径</strong> 由根目录（<code>/</code>）写起，如 <code>/usr/share/dic</code></li><li><strong>相对路径</strong> 由当前路径写起。在 Linux 文件系统中，<code>.</code> 代表当前目录（也可用 <code>./</code> 表示），<code>..</code> 代表上一层目录（也可用 <code>../</code> 表示）。如我们的当前目录绝对路径为 <code>/usr/share/doc</code> ，在当前目录用相对路径方式表示 <code>/usr/share/man</code> 的方法是 <code>../man</code>。</li></ul><p>另外需要注意，如果一个目录或文件名以 <code>.</code> 开始，如 <code>.bashrc</code>，说明该目录 / 文件为隐藏目录 / 文件，默认状态下不显示。</p><p>处理目录的常见命令</p><p>常见命令有：<code>ls</code>、<code>cd</code>、<code>pwd</code>、<code>mkdir</code>、<code>rmdir</code>、<code>cp</code>、<code>rm</code>、<code>mv</code>。可以通过 <code>man [命令]</code> 的方式来查看命令的使用文档。</p><h2 id="ls">ls</h2><p>列出目录及文件名（list files）</p><p>常用参数：</p><ul><li><code>-a</code>：连同隐藏文件一起展示所有文件</li><li><code>-d</code>：仅列出目录本身，而不是列出目录内的文件数据</li><li><code>-l</code>：长数据串列出详情</li></ul><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ ls -l / # 展示详情</span><br><span class="line">total 16</span><br><span class="line">lrwxrwxrwx.   1 0 root    7 Oct 30  2020 bin -&gt; usr/bin</span><br><span class="line">dr-xr-xr-x.   5 0 root 4096 Oct 30  2020 boot</span><br><span class="line">drwxr-xr-x   19 0 root 2820 Dec  1 16:41 dev</span><br><span class="line">drwxr-xr-x.  78 0 root 8192 Dec 11 17:41 etc</span><br><span class="line">drwxr-xr-x.   3 0 root   23 Dec  1 16:38 home</span><br><span class="line">lrwxrwxrwx.   1 0 root    7 Oct 30  2020 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.   1 0 root    9 Oct 30  2020 lib64 -&gt; usr/lib64</span><br><span class="line">drwxr-xr-x.   2 0 root    6 Apr 11  2018 media</span><br><span class="line">drwxr-xr-x.   2 0 root    6 Apr 11  2018 mnt</span><br><span class="line">drwxr-xr-x.   2 0 root    6 Apr 11  2018 opt</span><br><span class="line">dr-xr-xr-x  116 0 root    0 Dec  1 16:41 proc</span><br><span class="line">dr-xr-x---.   4 0 root  161 Dec  1 16:51 root</span><br><span class="line">drwxr-xr-x   21 0 root  660 Dec 11 17:41 run</span><br><span class="line">lrwxrwxrwx.   1 0 root    8 Oct 30  2020 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x.   2 0 root    6 Apr 11  2018 srv</span><br><span class="line">dr-xr-xr-x   13 0 root    0 Dec  8 11:36 sys</span><br><span class="line">drwxrwxrwt.   8 0 root  172 Dec 13 03:40 tmp</span><br><span class="line">drwxr-xr-x.  13 0 root  155 Oct 30  2020 usr</span><br><span class="line">drwxr-xr-x.  19 0 root  267 Feb  5  2021 var</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ ls -dl / # 展示当前目录详情</span><br><span class="line">dr-xr-xr-x. 17 0 root 244 May 31  2021 /</span><br></pre></td></tr></table></figure><h2 id="cd">cd</h2><p><code>cd [目录]</code></p><p>切换目录（change directory）</p><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ cd /dev # 切换到指定绝对路径</span><br><span class="line">[I have no name!@i-ym8u2kyp dev]$ cd ../media # 切换到指定相对路径</span><br><span class="line">[I have no name!@i-ym8u2kyp media]$</span><br></pre></td></tr></table></figure><h2 id="pwd">pwd</h2><p>显示当前所在的目录（print working directory）</p><p>常用参数</p><ul><li><code>-P</code>：显示确实路径，而非连结路径</li></ul><h2 id="mkdir">mkdir</h2><p><code>mkdir [目录名/路径]</code></p><p>创建新目录（make directory）</p><p>常用参数</p><ul><li><code>-m</code>：配置文件权限，忽略默认权限配置影响</li><li><code>-p</code>：可递归创建多级目录</li></ul><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ cd /tmp</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ mkdir test5</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ mkdir test6/test7/test8 # 默认创建多级目录会报错</span><br><span class="line">mkdir: cannot create directory ‘test6/test7/test8’: No such file or directory</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ mkdir -p test6/test7/test8</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp tmp]$ mkdir -m 711 test7 # 创建目录并配置权限</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ ls -l</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 1000 datawhale  6 Dec 15 16:22 test5</span><br><span class="line">drwxr-xr-x 3 1000 datawhale 19 Dec 15 16:23 test6</span><br><span class="line">drwx--x--x 2 1000 datawhale  6 Dec 15 16:25 test7 # 新创建目录配置权限与默认（755）不同</span><br></pre></td></tr></table></figure><p>关于文件权限，可以查看 <a href="https://www.runoob.com/linux/linux-file-attr-permission.html">Linux 文件基本属性 | 菜鸟教程 (runoob.com)</a></p><p><img src="https://download.mariozzj.cn/img/picgo/202112151646676.png" alt="文件权限表示"></p><h2 id="rmdir">rmdir</h2><p><code>rmdir [目录名/路径]</code></p><p>删除空目录（remove directory）</p><p>常用参数</p><ul><li><code>-p</code>：可递归删除多级目录</li></ul><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp tmp]$ rmdir test5</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ rmdir test6</span><br><span class="line">rmdir: failed to remove ‘test6’: Directory not empty</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ rmdir -p test6</span><br><span class="line">rmdir: failed to remove ‘test6’: Directory not empty</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ rmdir -p test6/test7/test8 # 删除多级目录，目录须为空</span><br></pre></td></tr></table></figure><p>如果要删除非空目录，可参见后续的 <code>rm</code> 命令</p><h2 id="cp">cp</h2><p><code>cp [源路径] [目标路径]</code></p><p>复制文件或目录（copy）</p><p>常用参数：</p><ul><li><code>-i</code>：若目标路径存在，覆盖前先询问动作</li><li><code>-p</code>：复制时联通属性复制</li><li><code>-r</code>：递归复制目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp tmp]$ mkdir test7</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ mkdir test9</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ mkdir test7/test8</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ cp test9 test7/test8 # 直接复制目录会失败</span><br><span class="line">cp: omitting directory ‘test9’</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ cp -r test9 test7/test8</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cp ~/.bashrc /tmp/bashrc</span><br><span class="line">[root@www ~]# cp -i ~/.bashrc /tmp/bashrc #n不覆盖，y为覆盖</span><br><span class="line">cp: overwrite `/tmp/bashrc&#x27;? n  </span><br></pre></td></tr></table></figure><h2 id="rm">rm</h2><p><code>rm [文件/目录路径]</code></p><p>移除文件或目录（remove）</p><p>常用参数：</p><ul><li><code>-f</code>：强制执行（force），忽略不存在的文件</li><li><code>-i</code>：互动模式（interactive），询问是否执行</li><li><code>-r</code>：递归删除，删除目录及子目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp tmp]$ rm -ri test7/test8/test9</span><br><span class="line">rm: remove directory ‘test7/test8/test9’? y</span><br></pre></td></tr></table></figure><h2 id="mv">mv</h2><p><code>mv [源路径] [目标路径]</code></p><p>移动文件或目录，或修改名称（remove）</p><p>常用参数：</p><ul><li><code>-f</code>：强制执行，如果目标文件已存在，不会询问而直接覆盖</li><li><code>-i</code>：若目标已存在，询问是否直接覆盖</li></ul><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp tmp]$ mv test9 test7/test8/test9</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ mv test7 test10 # 重命名</span><br></pre></td></tr></table></figure><h2 id="实战：在目录下创建文件夹、删除文件夹">实战：在目录下创建文件夹、删除文件夹</h2><ol><li>在 <code>/home/datawhale</code> 目录下，新建一个以英文昵称为名的文件夹 A</li><li>在文件夹 A 内部创建一个以 <code>datawhale</code> 命名的文件夹 B</li><li>在 B 文件夹内创建一个空的 txt 文件</li><li>删除上一步创建的文件</li><li>删除文件夹 B，然后删除文件夹 A</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ cd /home/datawhale</span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$ mkdir MarioZZJ # [1] 创建文件夹</span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$ cd MarioZZJ</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ mkdir datawhale # [2] 创建文件夹</span><br><span class="line">[I have no name!@i-ym8u2kyp MarioZZJ]$ cd datawhale</span><br><span class="line">[I have no name!@i-ym8u2kyp datawhale]$ touch empty.txt # [3] 创建文件</span><br><span class="line">[I have no name!@i-ym8u2kyp datawhale]$ rm empty.txt # [4] 删除文件</span><br><span class="line">[I have no name!@i-ym8u2kyp datawhale]$ cd ../../</span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$ rm -r ./MarioZZJ/datawhale # [5] 删除非空文件夹</span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$ rmdir ./MarioZZJ # [5] 删除空目录</span><br></pre></td></tr></table></figure><hr><h1>文件操作</h1><h2 id="wget">wget</h2><p><code>wget [目标文件URL] </code></p><p>下载文件的命令很多，如 <code>wget</code>、<code>apt-get</code> 等，这里以 <code>wget</code> 为例。我租赁的服务器安装的是 CentOS 系统，未预装 <code>wget</code>，使用该命令可能会提示 command not found。可以使用 <code>yum</code> 先安装 <code>wget</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li><code>-O [name]</code>：将下载的文件重命名</li><li><code>-c</code>：断点续传（重新启动下载中断的文件）</li><li><code>-b</code>：后台下载</li></ul><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp tmp]$ wget -O douban.png  https://img3.doubanio.com/f/frodo/144e6fb7d96701944e7dbb1a9bad51bdb1debe29/ # 下载并重命名</span><br><span class="line">pics/app/logo.png</span><br><span class="line">--2021-12-15 18:04:46--  https://img3.doubanio.com/f/frodo/144e6fb7d96701944e7dbb1a9bad51bdb1debe29/pics/app/logo.png</span><br><span class="line">Resolving img3.doubanio.com (img3.doubanio.com)... 60.28.216.240, 60.28.216.242, 60.28.216.244, ...</span><br><span class="line">Connecting to img3.doubanio.com (img3.doubanio.com)|60.28.216.240|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 24158 (24K) [image/png]</span><br><span class="line">Saving to: ‘douban.png’</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100%</span><span class="language-bash">[======================================================================================&gt;] 24,158      --.-K/s   <span class="keyword">in</span> 0s</span></span><br><span class="line"></span><br><span class="line">2021-12-15 18:04:46 (212 MB/s) - ‘douban.png’ saved [24158/24158]</span><br><span class="line"></span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$ wget -b -O douban.png https://img3.doubanio.com/f/frodo/144e6fb7d96701944e7dbb1a9bad51bdb1debe29/pics/app/logo.png # 下载重命名，不显示下载过程</span><br><span class="line">Continuing in background, pid 17703.</span><br><span class="line">Output will be written to ‘wget-log’.</span><br><span class="line">[I have no name!@i-ym8u2kyp tmp]$</span><br></pre></td></tr></table></figure><h2 id="cat">cat</h2><p><code>cat [文件路径]</code></p><p>从第一行开始显示文件内容（将文件连接到屏幕上，concatenate）</p><p>常用参数：</p><ul><li><code>-b</code>：列出非空白行行号</li><li><code>-n</code>：列出所有行行号</li><li><code>-v</code>：列出一些看不出来的特殊字符</li><li><code>-E</code>：将结尾的断行字节显示出来</li><li><code>-T</code>：将 <code>[tab]</code> 以 <code>^l</code> 展示出来</li><li><code>-A</code>：等同于 <code>-vET</code></li></ul><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ cat -b /etc/my.cnf</span><br><span class="line">     1  [mysqld]</span><br><span class="line">     2  datadir=/var/lib/mysql</span><br><span class="line">     3  socket=/var/lib/mysql/mysql.sock</span><br><span class="line">     4  # Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">     5  symbolic-links=0</span><br><span class="line">     6  # Settings user and group are ignored when systemd is used.</span><br><span class="line">     7  # If you need to run mysqld under a different user or group,</span><br><span class="line">     8  # customize your systemd unit file for mariadb according to the</span><br><span class="line">     9  # instructions in http://fedoraproject.org/wiki/Systemd</span><br><span class="line"></span><br><span class="line">    10  [mysqld_safe]</span><br><span class="line">    11  log-error=/var/log/mariadb/mariadb.log</span><br><span class="line">    12  pid-file=/var/run/mariadb/mariadb.pid</span><br><span class="line"></span><br><span class="line">    13  #</span><br><span class="line">    14  # include all files from the config directory</span><br><span class="line">    15  #</span><br><span class="line">    16  !includedir /etc/my.cnf.d</span><br><span class="line"></span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$</span><br></pre></td></tr></table></figure><h2 id="tac">tac</h2><p>从最后一行开始显示（正好是 <code>cat</code> 反过来）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ tac /etc/my.cnf</span><br><span class="line"></span><br><span class="line">!includedir /etc/my.cnf.d</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># include all files from the config directory</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">pid-file=/var/run/mariadb/mariadb.pid</span><br><span class="line">log-error=/var/log/mariadb/mariadb.log</span><br><span class="line">[mysqld_safe]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">instructions <span class="keyword">in</span> http://fedoraproject.org/wiki/Systemd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">customize your systemd unit file <span class="keyword">for</span> mariadb according to the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If you need to run mysqld under a different user or group,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Settings user and group are ignored when systemd is used.</span></span><br><span class="line">symbolic-links=0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">[mysqld]</span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$</span><br></pre></td></tr></table></figure><h2 id="head">head</h2><p><code>head [文件路径]</code></p><p>取出文件前几行（默认 10 行）</p><p>常用参数：</p><ul><li><code>-n [行数]</code>：指定显示的行数</li></ul><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ head -n 5 /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$</span><br></pre></td></tr></table></figure><h2 id="tail">tail</h2><p>与 <code>head</code> 相反，取出文件后几行。</p><h2 id="实战2：在目录下下载文件、阅读文件">实战2：在目录下下载文件、阅读文件</h2><ol><li>在 <code>/home/datawhale</code> 目录下，新建一个以英文昵称命名的文件夹 A</li><li>在文件夹 A 内创建一个以 <code>datawhale</code> 命名的文件夹 B</li><li>使用 <code>wget</code> 命令下载 <a href="https://mirror.coggle.club/dataset/affairs.txt%EF%BC%8C%E5%88%B0%E6%96%87%E4%BB%B6%E5%A4%B9">https://mirror.coggle.club/dataset/affairs.txt，到文件夹</a> B</li><li>使用 <code>cat</code>、<code>head</code>、<code>tail</code> 命令阅读下载的文件</li><li>在命令行使用 <code>ipython</code> 进入 Python3 环境，并使用 <code>pandas</code> 读取下载的文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">[I have no name!@i-ym8u2kyp ~]$ mkdir -p ./MarioZZJ/datawhale # [1,2] 创建文件夹</span><br><span class="line">[I have no name!@i-ym8u2kyp ~]$ cd ./MarioZZJ/datawhale</span><br><span class="line">[I have no name!@i-ym8u2kyp datawhale]$ wget  https://mirror.coggle.club/dataset/affairs.txt # [3] 下载文件到当前目录</span><br><span class="line">--2021-12-15 20:24:41--  https://mirror.coggle.club/dataset/affairs.txt</span><br><span class="line">Resolving mirror.coggle.club (mirror.coggle.club)... 60.221.23.1, 2408:8731:c001:2:3::3fb</span><br><span class="line">Connecting to mirror.coggle.club (mirror.coggle.club)|60.221.23.1|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 92161 (90K) [text/plain]</span><br><span class="line">Saving to: ‘affairs.txt’</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100%</span><span class="language-bash">[=======================================================================================&gt;] 92,161      --.-K/s   <span class="keyword">in</span> 0.02s</span></span><br><span class="line"></span><br><span class="line">2021-12-15 20:24:42 (3.88 MB/s) - ‘affairs.txt’ saved [92161/92161]</span><br><span class="line"></span><br><span class="line">[I have no name!@i-ym8u2kyp datawhale]$ cat ./affairs.txt</span><br><span class="line">rate_marriage,age,yrs_married,children,religious,affairs</span><br><span class="line">5,32,6,1,3,0</span><br><span class="line">4,22,2.5,0,2,0</span><br><span class="line">3,32,9,3,3,1</span><br><span class="line">3,27,13,3,1,1</span><br><span class="line">....... # [4] 使用 cat 阅读文件，文件整体很长，后续输出略去</span><br><span class="line">[I have no name!@i-ym8u2kyp datawhale]$ head -n 5 ./affairs.txt # [4] 使用 head 阅读文件前 5 行</span><br><span class="line">rate_marriage,age,yrs_married,children,religious,affairs</span><br><span class="line">5,32,6,1,3,0</span><br><span class="line">4,22,2.5,0,2,0</span><br><span class="line">3,32,9,3,3,1</span><br><span class="line">3,27,13,3,1,1</span><br><span class="line">[I have no name!@i-ym8u2kyp datawhale]$ tail -n 5 ./affairs.txt # [4] 使用 tail 阅读文件后 5 行</span><br><span class="line">4,22,2.5,0,3,0</span><br><span class="line">5,22,2.5,0,2,0</span><br><span class="line">5,32,13,2,3,0</span><br><span class="line">4,32,13,1,1,0</span><br><span class="line">5,22,2.5,0,2,0[I have no name!@i-ym8u2kyp datawhale]$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[I have no name!@i-ym8u2kyp datawhale]$ ipython # [5] 使用 ipython 打开交互式 python3</span><br><span class="line">Python 3.6.8 (default, Nov 16 2020, 16:55:22)</span><br><span class="line">Type &#x27;copyright&#x27;, &#x27;credits&#x27; or &#x27;license&#x27; for more information</span><br><span class="line">IPython 7.16.2 -- An enhanced Interactive Python. Type &#x27;?&#x27; for help.</span><br><span class="line"></span><br><span class="line">In [1]: !pwd ## 使用超级命令查看当前工作目录</span><br><span class="line">/home/datawhale/MarioZZJ/datawhale</span><br><span class="line"></span><br><span class="line">In [2]: import pandas as pd</span><br><span class="line"></span><br><span class="line">In [3]: data = pd.read_csv(&#x27;./affairs.txt&#x27;) ## 因为之前看过文件，确定是 csv，使用该方法读取</span><br><span class="line"></span><br><span class="line">In [4]: data.info()</span><br><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 6366 entries, 0 to 6365</span><br><span class="line">Data columns (total 6 columns):</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">  Column         Non-Null Count  Dtype</span></span><br><span class="line">---  ------         --------------  -----</span><br><span class="line"> 0   rate_marriage  6366 non-null   int64</span><br><span class="line"> 1   age            6366 non-null   float64</span><br><span class="line"> 2   yrs_married    6366 non-null   float64</span><br><span class="line"> 3   children       6366 non-null   float64</span><br><span class="line"> 4   religious      6366 non-null   int64</span><br><span class="line"> 5   affairs        6366 non-null   int64</span><br><span class="line">dtypes: float64(3), int64(3)</span><br><span class="line">memory usage: 298.5 KB</span><br><span class="line"></span><br><span class="line">In [5]: data.head(5)</span><br><span class="line">Out[5]:</span><br><span class="line">   rate_marriage   age  yrs_married  children  religious  affairs</span><br><span class="line">0              5  32.0          6.0       1.0          3        0</span><br><span class="line">1              4  22.0          2.5       0.0          2        0</span><br><span class="line">2              3  32.0          9.0       3.0          3        1</span><br><span class="line">3              3  27.0         13.0       3.0          1        1</span><br><span class="line">4              4  22.0          2.5       0.0          1        1</span><br><span class="line"></span><br><span class="line">In [6]: exit()</span><br><span class="line">[I have no name!@i-ym8u2kyp datawhale]$</span><br></pre></td></tr></table></figure><hr><h1>文件编辑：Vim</h1><h2 id="nano">nano</h2><p>nano 是 Linux 的一个基础编辑器，使用 <code>nano [文件路径]</code> 即可使用 nano 打开文件</p><p><img src="https://download.mariozzj.cn/img/picgo/202112152042360.png" alt="Nano 界面"></p><p>第一行反色部分指示 nano 版本和文件路径，随后下方显示出文件内容，我们在终端使用键盘上的方向键可以移动光标查看文件内容。在屏幕最底端展示的是快捷键，使用快捷键即可实现上述操作。以 Windows 操作的终端为例：</p><ul><li><code>^</code> 后接按键，代表该操作可以用 <code>Ctrl + [按键]</code> 的方式触发。例如要退出编辑器，可以按 <code>Ctrl+X</code>；以及屏幕上提示的其他操作</li><li><code>M-</code> 后接按键，代表该操作可以用 <code>Alt + [按键]</code> 的方式触发。例如<ul><li><code>Alt + M</code>：打开/关闭支持鼠标移动光标</li><li><code>Alt + R</code>：查找模式下输入正则表达式</li></ul></li></ul><h2 id="vim">vim</h2><p>vim 是知名的 Linux 内置文本编辑器，功能较为丰富，在程序员中被广泛使用。详细教程可参考 <a href="https://www.runoob.com/linux/linux-vim.html">Linux vi/vim | 菜鸟教程</a>。</p><p><img src="https://download.mariozzj.cn/img/picgo/202112152052427.gif" alt="Vim 键盘图"></p><p>vim 分为三种模式，分别是命令模式（command mode）、输入模式（insert mode）和底线命令模式（last line mode）</p><p><img src="https://download.mariozzj.cn/img/picgo/202112152057482.png" alt="Vim 工作模式切换"></p><h3 id="命令模式">命令模式</h3><p>使用命令 <code>vim [文件路径]</code> 即可使用 vim 编辑器打开文件。</p><p>默认进入的是命令模式，该模式下敲击键盘会被视作命令而非输入字符。命令模式支持的命令较少，使用更多命令可以按 <code>:</code> 进入底线命令模式。而如需输入则可以按 <code>i</code> 进入输入模式。</p><p><img src="https://download.mariozzj.cn/img/picgo/202112152106381.png" alt="Vim 命令模式"></p><p>一般模式支持很多按键功能，介绍几个常用的：</p><ul><li><code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>：作用与<code>←</code>、<code>↓</code>、<code>↑</code>、<code>→</code> 相同，可移动光标。</li><li><code>[行数]+h/j/k/l/←/↓/↑/→</code>：组合快速移动任意行/字符数</li><li><code>Ctrl + F/B</code>：（forward/backward）相当于 <code>Page Up / Page Down</code>。</li></ul><h3 id="输入模式">输入模式</h3><p>命令模式下，按 <code>i</code> 进入输入模式：</p><p><img src="https://download.mariozzj.cn/img/picgo/202112152111017.png" alt="Vim 输入模式"></p><p>在输入模式下部分按键的功能如下：</p><ul><li>字符按键，及其与 <code>Shift</code> 按键的组合：输入字符</li><li>回车 <code>[Enter]</code>：换行</li><li>退格 <code>[Backspace]</code>：删除光标前一个字符</li><li>删除 <code>[Del]</code>：删除光标后一个字符</li><li><code>Insert</code>：切换光标未输入/替换模式。光标分别为竖线/下划线。</li><li><code>Page Up/Down</code>：上下翻页</li><li><code>HOME/END</code>：移动光标到行首/行尾</li><li><code>ESC</code>：退出输入模式，切换到命令模式</li></ul><h3 id="底层命令模式">底层命令模式</h3><p>命令模式下，按 <code>:</code> 进入底层命令模式：</p><p><img src="https://download.mariozzj.cn/img/picgo/202112152115883.png" alt="Vim 底层命令模式"></p><p>在底线命令模式中，基本的命令有：</p><ul><li><code>q</code>：退出程序</li><li><code>w</code>：保存文件</li><li><code>q!</code>：强制离开而不保存</li><li><code>w [文件名]</code>：将编辑的数据存储为另一个档案</li><li><code>r [文件名]</code>：在编辑的数据中，将另一个文件的数据追加到游标后面</li><li><code>! [终端指令]</code>：暂时离开 vim，在指令中执行指令，并打印结果</li><li><code>set nu/set nonu</code>：显示/取消行号</li></ul><h2 id="实战4：在目录下使用-vi-或-vim-编辑文件">实战4：在目录下使用 vi 或 vim 编辑文件</h2><ol><li><p>使用 Nano 和 Vim 分别创建 <code>.py</code> 文件，并输入以下内容，并运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><p>实操：</p><p><img src="https://download.mariozzj.cn/img/picgo/202112152208600.gif" alt="Nano 操作过程"></p><p><img src="https://download.mariozzj.cn/img/picgo/202112152208254.gif" alt="Vim 操作过程"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实验：回归 | Leeml-2020-hw1</title>
      <link href="/posts/28d53052/"/>
      <url>/posts/28d53052/</url>
      
        <content type="html"><![CDATA[<h1>Overview</h1><p>实验已作为 Kaggle 竞赛发布，见 <a href="https://www.kaggle.com/c/ml2020spring-hw1/">Kaggle</a>。涉及的主要内容：</p><ul><li>通过完成一次时间序列预测任务，回顾回归相关知识</li><li>梯度下降的步骤，求解方法</li><li>学习率参数选择</li><li>特征缩放对学习效果的影响</li><li>最小二乘法直接求解回归问题</li></ul><h1>EDA</h1><blockquote><p>任务说明：训练集数据提供丰原气象站某年每月前 20 天每小时的 18 项指标数值。测试集给出余下天数的前 9 小时的所有指标数值，要求预测出第 10 小时的 PM2.5 数值。</p></blockquote><h2 id="load-data">load data</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TASK_DIR = ROOT_DIR + <span class="string">&#x27;ml2020spring-hw1/&#x27;</span></span><br><span class="line">data_train = pd.read_csv(TASK_DIR + <span class="string">&quot;train.csv&quot;</span>,encoding = <span class="string">&#x27;big5&#x27;</span>)</span><br><span class="line">data_test  = pd.read_csv(TASK_DIR + <span class="string">&quot;test.csv&quot;</span> ,encoding = <span class="string">&#x27;big5&#x27;</span>,names = [<span class="string">&#x27;日期&#x27;</span>, <span class="string">&#x27;測項&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_train.info()</span><br></pre></td></tr></table></figure><pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 4320 entries, 0 to 4319Data columns (total 27 columns): #   Column  Non-Null Count  Dtype ---  ------  --------------  -----  0   日期      4320 non-null   object 1   測站      4320 non-null   object 2   測項      4320 non-null   object 3   0       4320 non-null   object 4   1       4320 non-null   object 5   2       4320 non-null   object 6   3       4320 non-null   object 7   4       4320 non-null   object 8   5       4320 non-null   object 9   6       4320 non-null   object 10  7       4320 non-null   object 11  8       4320 non-null   object 12  9       4320 non-null   object 13  10      4320 non-null   object 14  11      4320 non-null   object 15  12      4320 non-null   object 16  13      4320 non-null   object 17  14      4320 non-null   object 18  15      4320 non-null   object 19  16      4320 non-null   object 20  17      4320 non-null   object 21  18      4320 non-null   object 22  19      4320 non-null   object 23  20      4320 non-null   object 24  21      4320 non-null   object 25  22      4320 non-null   object 26  23      4320 non-null   objectdtypes: object(27)memory usage: 911.4+ KB</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_train.head(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>日期</th>      <th>測站</th>      <th>測項</th>      <th>0</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th>6</th>      <th>...</th>      <th>14</th>      <th>15</th>      <th>16</th>      <th>17</th>      <th>18</th>      <th>19</th>      <th>20</th>      <th>21</th>      <th>22</th>      <th>23</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>AMB_TEMP</td>      <td>14</td>      <td>14</td>      <td>14</td>      <td>13</td>      <td>12</td>      <td>12</td>      <td>12</td>      <td>...</td>      <td>22</td>      <td>22</td>      <td>21</td>      <td>19</td>      <td>17</td>      <td>16</td>      <td>15</td>      <td>15</td>      <td>15</td>      <td>15</td>    </tr>    <tr>      <th>1</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>CH4</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>...</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>    </tr>    <tr>      <th>2</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>CO</td>      <td>0.51</td>      <td>0.41</td>      <td>0.39</td>      <td>0.37</td>      <td>0.35</td>      <td>0.3</td>      <td>0.37</td>      <td>...</td>      <td>0.37</td>      <td>0.37</td>      <td>0.47</td>      <td>0.69</td>      <td>0.56</td>      <td>0.45</td>      <td>0.38</td>      <td>0.35</td>      <td>0.36</td>      <td>0.32</td>    </tr>    <tr>      <th>3</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>NMHC</td>      <td>0.2</td>      <td>0.15</td>      <td>0.13</td>      <td>0.12</td>      <td>0.11</td>      <td>0.06</td>      <td>0.1</td>      <td>...</td>      <td>0.1</td>      <td>0.13</td>      <td>0.14</td>      <td>0.23</td>      <td>0.18</td>      <td>0.12</td>      <td>0.1</td>      <td>0.09</td>      <td>0.1</td>      <td>0.08</td>    </tr>    <tr>      <th>4</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>NO</td>      <td>0.9</td>      <td>0.6</td>      <td>0.5</td>      <td>1.7</td>      <td>1.8</td>      <td>1.5</td>      <td>1.9</td>      <td>...</td>      <td>2.5</td>      <td>2.2</td>      <td>2.5</td>      <td>2.3</td>      <td>2.1</td>      <td>1.9</td>      <td>1.5</td>      <td>1.6</td>      <td>1.8</td>      <td>1.5</td>    </tr>    <tr>      <th>5</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>NO2</td>      <td>16</td>      <td>9.2</td>      <td>8.2</td>      <td>6.9</td>      <td>6.8</td>      <td>3.8</td>      <td>6.9</td>      <td>...</td>      <td>11</td>      <td>11</td>      <td>22</td>      <td>28</td>      <td>19</td>      <td>12</td>      <td>8.1</td>      <td>7</td>      <td>6.9</td>      <td>6</td>    </tr>    <tr>      <th>6</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>NOx</td>      <td>17</td>      <td>9.8</td>      <td>8.7</td>      <td>8.6</td>      <td>8.5</td>      <td>5.3</td>      <td>8.8</td>      <td>...</td>      <td>14</td>      <td>13</td>      <td>25</td>      <td>30</td>      <td>21</td>      <td>13</td>      <td>9.7</td>      <td>8.6</td>      <td>8.7</td>      <td>7.5</td>    </tr>    <tr>      <th>7</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>O3</td>      <td>16</td>      <td>30</td>      <td>27</td>      <td>23</td>      <td>24</td>      <td>28</td>      <td>24</td>      <td>...</td>      <td>65</td>      <td>64</td>      <td>51</td>      <td>34</td>      <td>33</td>      <td>34</td>      <td>37</td>      <td>38</td>      <td>38</td>      <td>36</td>    </tr>    <tr>      <th>8</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>PM10</td>      <td>56</td>      <td>50</td>      <td>48</td>      <td>35</td>      <td>25</td>      <td>12</td>      <td>4</td>      <td>...</td>      <td>52</td>      <td>51</td>      <td>66</td>      <td>85</td>      <td>85</td>      <td>63</td>      <td>46</td>      <td>36</td>      <td>42</td>      <td>42</td>    </tr>    <tr>      <th>9</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>PM2.5</td>      <td>26</td>      <td>39</td>      <td>36</td>      <td>35</td>      <td>31</td>      <td>28</td>      <td>25</td>      <td>...</td>      <td>36</td>      <td>45</td>      <td>42</td>      <td>49</td>      <td>45</td>      <td>44</td>      <td>41</td>      <td>30</td>      <td>24</td>      <td>13</td>    </tr>    <tr>      <th>10</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>RAINFALL</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>...</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>      <td>NR</td>    </tr>    <tr>      <th>11</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>RH</td>      <td>77</td>      <td>68</td>      <td>67</td>      <td>74</td>      <td>72</td>      <td>73</td>      <td>74</td>      <td>...</td>      <td>47</td>      <td>49</td>      <td>56</td>      <td>67</td>      <td>72</td>      <td>69</td>      <td>70</td>      <td>70</td>      <td>70</td>      <td>69</td>    </tr>    <tr>      <th>12</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>SO2</td>      <td>1.8</td>      <td>2</td>      <td>1.7</td>      <td>1.6</td>      <td>1.9</td>      <td>1.4</td>      <td>1.5</td>      <td>...</td>      <td>3.9</td>      <td>4.4</td>      <td>9.9</td>      <td>5.1</td>      <td>3.4</td>      <td>2.3</td>      <td>2</td>      <td>1.9</td>      <td>1.9</td>      <td>1.9</td>    </tr>    <tr>      <th>13</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>THC</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td>1.9</td>      <td>1.9</td>      <td>1.8</td>      <td>1.9</td>      <td>...</td>      <td>1.9</td>      <td>1.9</td>      <td>1.9</td>      <td>2.1</td>      <td>2</td>      <td>1.9</td>      <td>1.9</td>      <td>1.9</td>      <td>1.9</td>      <td>1.9</td>    </tr>    <tr>      <th>14</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>WD_HR</td>      <td>37</td>      <td>80</td>      <td>57</td>      <td>76</td>      <td>110</td>      <td>106</td>      <td>101</td>      <td>...</td>      <td>307</td>      <td>304</td>      <td>307</td>      <td>124</td>      <td>118</td>      <td>121</td>      <td>113</td>      <td>112</td>      <td>106</td>      <td>110</td>    </tr>    <tr>      <th>15</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>WIND_DIREC</td>      <td>35</td>      <td>79</td>      <td>2.4</td>      <td>55</td>      <td>94</td>      <td>116</td>      <td>106</td>      <td>...</td>      <td>313</td>      <td>305</td>      <td>291</td>      <td>124</td>      <td>119</td>      <td>118</td>      <td>114</td>      <td>108</td>      <td>102</td>      <td>111</td>    </tr>    <tr>      <th>16</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>WIND_SPEED</td>      <td>1.4</td>      <td>1.8</td>      <td>1</td>      <td>0.6</td>      <td>1.7</td>      <td>2.5</td>      <td>2.5</td>      <td>...</td>      <td>2.5</td>      <td>2.2</td>      <td>1.4</td>      <td>2.2</td>      <td>2.8</td>      <td>3</td>      <td>2.6</td>      <td>2.7</td>      <td>2.1</td>      <td>2.1</td>    </tr>    <tr>      <th>17</th>      <td>2014/1/1</td>      <td>豐原</td>      <td>WS_HR</td>      <td>0.5</td>      <td>0.9</td>      <td>0.6</td>      <td>0.3</td>      <td>0.6</td>      <td>1.9</td>      <td>2</td>      <td>...</td>      <td>2.1</td>      <td>2.1</td>      <td>1.9</td>      <td>1</td>      <td>2.5</td>      <td>2.5</td>      <td>2.8</td>      <td>2.6</td>      <td>2.4</td>      <td>2.3</td>    </tr>    <tr>      <th>18</th>      <td>2014/1/2</td>      <td>豐原</td>      <td>AMB_TEMP</td>      <td>16</td>      <td>15</td>      <td>15</td>      <td>14</td>      <td>14</td>      <td>15</td>      <td>16</td>      <td>...</td>      <td>24</td>      <td>24</td>      <td>23</td>      <td>21</td>      <td>20</td>      <td>19</td>      <td>18</td>      <td>18</td>      <td>18</td>      <td>18</td>    </tr>    <tr>      <th>19</th>      <td>2014/1/2</td>      <td>豐原</td>      <td>CH4</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>...</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>    </tr>  </tbody></table><p>20 rows × 27 columns</p></div><p>训练集由每月前 20 天每小时的 18 项观测指标组成，除 <code>RAINFALL</code> 观测指标外其余指标均为数值型。下载观测整个数据集发现，<code>RAINFALL</code> 指标值不为 <code>NR</code> 时，以数值型记录了该小时的降雨量，所以<strong>需要对 <code>NR</code> 值进行处理，将其改为 0</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_test</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>日期</th>      <th>測項</th>      <th>0</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th>6</th>      <th>7</th>      <th>8</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>id_0</td>      <td>AMB_TEMP</td>      <td>21</td>      <td>21</td>      <td>20</td>      <td>20</td>      <td>19</td>      <td>19</td>      <td>19</td>      <td>18</td>      <td>17</td>    </tr>    <tr>      <th>1</th>      <td>id_0</td>      <td>CH4</td>      <td>1.7</td>      <td>1.7</td>      <td>1.7</td>      <td>1.7</td>      <td>1.7</td>      <td>1.7</td>      <td>1.7</td>      <td>1.7</td>      <td>1.8</td>    </tr>    <tr>      <th>2</th>      <td>id_0</td>      <td>CO</td>      <td>0.39</td>      <td>0.36</td>      <td>0.36</td>      <td>0.4</td>      <td>0.53</td>      <td>0.55</td>      <td>0.34</td>      <td>0.31</td>      <td>0.23</td>    </tr>    <tr>      <th>3</th>      <td>id_0</td>      <td>NMHC</td>      <td>0.16</td>      <td>0.24</td>      <td>0.22</td>      <td>0.27</td>      <td>0.27</td>      <td>0.26</td>      <td>0.27</td>      <td>0.29</td>      <td>0.1</td>    </tr>    <tr>      <th>4</th>      <td>id_0</td>      <td>NO</td>      <td>1.3</td>      <td>1.3</td>      <td>1.3</td>      <td>1.3</td>      <td>1.4</td>      <td>1.6</td>      <td>1.2</td>      <td>1.1</td>      <td>0.9</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>4315</th>      <td>id_239</td>      <td>THC</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.8</td>      <td>1.7</td>      <td>1.7</td>      <td>1.7</td>      <td>1.7</td>      <td>1.7</td>    </tr>    <tr>      <th>4316</th>      <td>id_239</td>      <td>WD_HR</td>      <td>80</td>      <td>92</td>      <td>95</td>      <td>95</td>      <td>96</td>      <td>97</td>      <td>96</td>      <td>96</td>      <td>84</td>    </tr>    <tr>      <th>4317</th>      <td>id_239</td>      <td>WIND_DIREC</td>      <td>76</td>      <td>99</td>      <td>93</td>      <td>97</td>      <td>93</td>      <td>94</td>      <td>98</td>      <td>97</td>      <td>65</td>    </tr>    <tr>      <th>4318</th>      <td>id_239</td>      <td>WIND_SPEED</td>      <td>2.2</td>      <td>3.2</td>      <td>2.5</td>      <td>3.6</td>      <td>5</td>      <td>4.2</td>      <td>5.7</td>      <td>4.9</td>      <td>3.6</td>    </tr>    <tr>      <th>4319</th>      <td>id_239</td>      <td>WS_HR</td>      <td>1.7</td>      <td>2.8</td>      <td>2.6</td>      <td>3.3</td>      <td>3.5</td>      <td>5</td>      <td>4.9</td>      <td>5.2</td>      <td>3.6</td>    </tr>  </tbody></table><p>4320 rows × 11 columns</p></div><p>根据任务描述，训练集记录的是每月前 20 天的数据，那么每月余下的数据便打乱后包含于测试集，同时只保留前 9 小时的数据，目标是根据这 9 个小时的数据预测出第 10 个小时的 PM 2.5 值。同理，<strong>测试集的 <code>NR</code> 稍后也需处理为 0</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_train = data_train.replace(<span class="string">&#x27;NR&#x27;</span>,<span class="number">0.0</span>)</span><br><span class="line">data_test  = data_test.replace(<span class="string">&#x27;NR&#x27;</span>,<span class="number">0.0</span>)</span><br></pre></td></tr></table></figure><p>我们的任务是：根据训练集数据，使用回归的方法，对模型进行训练，使得模型能够根据测试集中前 9 小时的数据预测出第 10 小时的 <code>PM2.5</code> 值。</p><p>由于涉及的项较多，为简化任务，本次实验的<strong>模型均采用线性模型</strong>，那么考虑模型复杂程度可以分为以下两种模型：</p><ol><li>仅考虑 <code>PM2.5</code> 指标，根据前 9 小时的 <code>PM2.5</code> 指标预测第 10 小时的值；</li><li>考虑所有指标对 <code>PM2.5</code> 的影响，根据前 9 小时所有指标预测第 10 小时的值。</li></ol><p>测试集中，前 9 小时的数据是连续的 9 小时，所以可以从训练集中提取连续的 9 小时作为训练样本，之后的 1 小时的 <code>PM2.5</code> 观测值作为标签，获得训练集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_train.iloc[:,<span class="number">3</span>:] = data_train.iloc[:,<span class="number">3</span>:].astype(<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X_train = []</span><br><span class="line">y_train = []</span><br><span class="line">x_train_pm25 = []</span><br><span class="line"><span class="keyword">for</span> date <span class="keyword">in</span> data_train.日期.unique():</span><br><span class="line">    data_daily = data_train[data_train[<span class="string">&#x27;日期&#x27;</span>]==date]</span><br><span class="line"><span class="comment">#     display(data_daily)</span></span><br><span class="line">    properties = data_daily.測項</span><br><span class="line"><span class="comment">#     display(properties)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>+<span class="number">3</span>,<span class="number">16</span>+<span class="number">3</span>):</span><br><span class="line">        X_train.append(data_daily.iloc[:,i:(i+<span class="number">9</span>)].values)</span><br><span class="line">        x_train_pm25.append(data_daily.iloc[<span class="number">9</span>,i:(i+<span class="number">9</span>)].values)</span><br><span class="line">        y_train.append(data_daily[data_daily[<span class="string">&#x27;測項&#x27;</span>]==<span class="string">&#x27;PM2.5&#x27;</span>].iloc[:,(i+<span class="number">8</span>)].values[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>就这样，我们获取到了基础的训练数据集，可以开始后续的模型训练。</p><h1>Regression - Model1 : Simple Linear Model</h1><h2 id="Definition">Definition</h2><p>上面的分析已经提到，我们的模型为线性模型。以最简单的模型 1 为例，最后的模型应为如下形式：</p><p>$$<br>f(\boldsymbol{x}) = w_1 \cdot x_1 + w_2 \cdot x_2 + \cdots + w_9 \cdot x_9 + b<br>$$</p><p>其中 $y$ 为第 10 小时 PM2.5 预测值，$x_1,x_2,\cdots,x_9$ 为前 9 小时的 PM2.5 观测值。</p><p>为了后续讨论方便，尽可能将模型的元素使用向量或矩阵的形式表示，原模型可写为：</p><p>$$<br>f(\boldsymbol{x}) = \boldsymbol{w}^T\boldsymbol{x}+b<br>$$</p><p>为便于后续讨论，将模型进一步简化表示，将偏置 $b$ 收入向量形式 $\boldsymbol{\hat{w}}=(\boldsymbol{w},b)$。全体数据集表示为一个矩阵，行列数量对应样本数、属性值数+1，其中每行对应一个样本，最后一个元素恒置为 1：</p><p>$$<br>\boldsymbol{X} = \left(\begin{matrix}<br>x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d} &amp; 1 \<br>x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d} &amp; 1 \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \<br>x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{md} &amp; 1<br>\end{matrix}\right)<br>= \left(\begin{matrix}<br>\boldsymbol{x}_1^T &amp; 1 \<br>\boldsymbol{x}_2^T &amp; 1 \<br>\vdots &amp; \vdots \<br>\boldsymbol{x}_m^T &amp; 1 \<br>\end{matrix}\right)<br>$$</p><p>其中 $d=9$。</p><p>我们的目标是，学习得到 $f(\boldsymbol{x}_i)$ 使得 $f(\boldsymbol{x}_i)\simeq y_i$</p><h2 id="Loss-Function">Loss Function</h2><p>模型在不断优化的过程中，需要对模型效果进行评估。在回归任务中，均方误差（MSE）是最常见的性能度量。</p><p>采用均方误差作为损失函数，我们原来学习函数的问题转化为求取所有样本点到我们拟合的模型曲线上的欧式距离之和，并迭代优化模型使之最小。</p><p>为了方便表示，将样本点标签（label，即我们预测的第 10 小时 PM2.5 值）也写成向量形式：$\boldsymbol{y} = (y_1;y_2;\cdots;y_m)$，损失函数可以表示为：</p><p>$$<br>L = \dfrac{1}{m}(\boldsymbol{y} - \boldsymbol{X\hat{w}})^T(\boldsymbol{y} - \boldsymbol{X\hat{w}})<br>$$</p><h2 id="Gradient-Descent">Gradient Descent</h2><p>随机下降过程是利用样本学习参数的过程，将参数向梯度下降方向（损失函数值在某一点减少的方向）移动。</p><p>梯度下降可以分为以下步骤：</p><ol><li>随机选取一个初始点 $\boldsymbol{\hat{w}}^0$ ；</li><li>计算在该处参数 $\boldsymbol{\hat{w}}$ 对损失函数 $L$ 的（偏）微分 $\dfrac{\partial L}{\partial \boldsymbol{\hat{w}}}|_{\boldsymbol{\hat{w}}=\boldsymbol{\hat{w}}^i}$；</li><li>更新 $\boldsymbol{\hat{w}}^i$：$\boldsymbol{\hat{w}}^{i+1} \leftarrow \boldsymbol{\hat{w}}^i - \eta\dfrac{\partial L}{\partial \boldsymbol{\hat{w}}}|_{\boldsymbol{\hat{w}}=\boldsymbol{\hat{w}}^i}$。其中 $\eta$ 为学习率，微分值为负则增加参数，若微分值为正则减少参数。重复步骤2-3，直至微分值为 $0$，得到 $\boldsymbol{\hat{w}}$ 的最优值 $\boldsymbol{\hat{w}}^\star$ 。</li></ol><p>梯度下降较为关键的步骤就是梯度（损失函数偏微分）的计算和参数更新，计算梯度的方法与损失函数的选择相关，前面我们选择了 MSE 作为损失函数。$L$ 对 $\boldsymbol{\hat{w}}$ 求偏导得：</p><p>$$<br>\dfrac{\partial L}{\partial \boldsymbol{\hat{w}}} = \dfrac{2}{m} \boldsymbol{X}^T(\boldsymbol{X}\boldsymbol{\hat{w}}-\boldsymbol{y})<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">grad_descent</span>(<span class="params">X,Y,epoch=<span class="number">20</span>,eta=<span class="number">0.0001</span>,w_old=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        X: 输入数据集, Numpy 数组 (Sample_count, Attr_count)</span></span><br><span class="line"><span class="string">        Y: 预测标签, Numpy 数组 (Sample_count, 1)</span></span><br><span class="line"><span class="string">        epoch: 迭代轮数</span></span><br><span class="line"><span class="string">        eta: 学习率</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    X = np.column_stack((X,np.ones(X.shape[<span class="number">0</span>])))</span><br><span class="line">    Y = Y.reshape((Y.shape[<span class="number">0</span>],<span class="number">1</span>))</span><br><span class="line">    w = w_old <span class="keyword">if</span> w_old <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> np.random.random(size=(X.shape[<span class="number">1</span>],<span class="number">1</span>)) <span class="comment"># 随机初始化参数 w（Step 1）</span></span><br><span class="line">    loss = []</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">iter</span> <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\r&#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">iter</span>+<span class="number">1</span>,epoch),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        gradient = <span class="number">2</span> * X.T.dot(X.dot(w)-Y) / X.shape[<span class="number">0</span>]                       <span class="comment"># 计算 L 对 w 的偏微分，即梯度。（Step 2）</span></span><br><span class="line">        w = w - eta * gradient                                                <span class="comment"># 更新参数 w （Step 3）</span></span><br><span class="line">        loss.append((Y-X.dot(w)).T.dot(Y-X.dot(w)).reshape(-<span class="number">1</span>)/ X.shape[<span class="number">0</span>])   <span class="comment"># 计算损失 L</span></span><br><span class="line">    <span class="keyword">return</span> w, loss</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w,loss = grad_descent(np.array(x_train_pm25,dtype=<span class="built_in">float</span>),np.array(y_train,dtype=<span class="built_in">float</span>))</span><br></pre></td></tr></table></figure><pre><code>20/20</code></pre><p>通过迭代我们学习得到了模型参数 $\boldsymbol{\hat{w}}$ 和每一轮函数的损失值，我们可以通过可视化的方式直观展现函数损失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_loss</span>(<span class="params">loss,title=<span class="string">&quot;Loss Value per Iter&quot;</span></span>):</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot()</span><br><span class="line">    ax.set_title(title)</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;iteration&quot;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&quot;Loss/MSE&quot;</span>)</span><br><span class="line">    ax.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(loss)),np.array(loss).reshape(-<span class="number">1</span>))</span><br><span class="line">plot_loss(loss)</span><br><span class="line"><span class="built_in">print</span>(loss[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>[26.05574238]</code></pre><p><img src="https://download.mariozzj.cn/img/picgo/202112051944500.png" alt="plt"></p><p>可以看到，随着训练轮数的增加，损失值在不断下降，说明我们的模型在不断学习，向数据逼近。</p><h2 id="参数调整：训练轮数-epoch">参数调整：训练轮数 epoch</h2><p>如果我们进一步增加训练轮数，可以使得损失函数进一步收敛：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w,loss = grad_descent(np.array(x_train_pm25,dtype=<span class="built_in">float</span>),np.array(y_train,dtype=<span class="built_in">float</span>),epoch=<span class="number">80</span>,w_old=w)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">plot_loss(loss)</span><br><span class="line"><span class="built_in">print</span>(loss[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>80/80[4.08627535]</code></pre><p><img src="https://download.mariozzj.cn/img/picgo/202112051945527.png" alt="plt"></p><p>函数收敛的速度不断降低，所以如果无限度增大训练轮数确实可以使得损失函数较小，但是有可能带来过拟合现象。所以调整训练轮数在适当值即可。</p><h2 id="参数调整：学习率-eta">参数调整：学习率 eta</h2><p>学习率能够控制参数更新速度，过大的学习率可能导致损失函数错过全局最优，甚至无法收敛；而较小的学习率可能导致损失函数下降较慢</p><p><img src="https://download.mariozzj.cn/img/picgo/202111192335868.png" alt="image-20211119233528788"></p><p>由于我们的参数矩阵是随机生成，为便于对比不同学习率的效果，我们控制每一次的初始参数都相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w = np.random.random(size=(<span class="built_in">len</span>(x_train_pm25[<span class="number">0</span>])+<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">w1,loss1 = grad_descent(np.array(x_train_pm25,dtype=<span class="built_in">float</span>),np.array(y_train,dtype=<span class="built_in">float</span>),epoch=<span class="number">50</span>,eta=<span class="number">0.0001</span>,w_old=w)</span><br><span class="line">w2,loss2 = grad_descent(np.array(x_train_pm25,dtype=<span class="built_in">float</span>),np.array(y_train,dtype=<span class="built_in">float</span>),epoch=<span class="number">50</span>,eta=<span class="number">0.001</span>,w_old=w)</span><br><span class="line">w3,loss3 = grad_descent(np.array(x_train_pm25,dtype=<span class="built_in">float</span>),np.array(y_train,dtype=<span class="built_in">float</span>),epoch=<span class="number">50</span>,eta=<span class="number">0.00001</span>,w_old=w)</span><br></pre></td></tr></table></figure><pre><code>50/50</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plot_loss(loss1,title=<span class="string">&quot;Loss per Iter: $\eta=10^&#123;-4&#125;$&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(loss1[-<span class="number">1</span>])</span><br><span class="line">plot_loss(loss2,title=<span class="string">&quot;Loss per Iter: $\eta=10^&#123;-3&#125;$&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(loss2[-<span class="number">1</span>])</span><br><span class="line">plot_loss(loss3,title=<span class="string">&quot;Loss per Iter: $\eta=10^&#123;-6&#125;$&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(loss3[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>[11.36702501][8.90902162e+109][37.52494183]</code></pre><p><img src="https://download.mariozzj.cn/img/picgo/202112051945756.png" alt="plt"></p><p><img src="https://download.mariozzj.cn/img/picgo/202112051945668.png" alt="plt"></p><p><img src="https://download.mariozzj.cn/img/picgo/202112051945836.png" alt="plt"></p><p>可以看到，当 $\eta=0.001$ 时，损失函数最终飙升，无法收敛，此时学习率过大；当 $\eta=0.000001$ 时，损失函数最初的收敛速度明显不如 $\eta=0.0001$ 时，且经过同样较大的迭代轮数后，损失函数值的收敛效果不如后者，学习率较小。</p><p>所以，需要经过多次测试，比较模型在不同学习率下的表现，方能获得较好的学习效果。</p><h2 id="模型预测">模型预测</h2><p>通过参数调整测试，我们已经确定了较好的参数，这样就可以获取最终的模型，对目标数据进行预测。</p><p>$$<br>f(\boldsymbol{X}) = \boldsymbol{\hat{w}X}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w,loss = grad_descent(np.array(x_train_pm25,dtype=<span class="built_in">float</span>),np.array(y_train,dtype=<span class="built_in">float</span>),eta=<span class="number">0.00013</span>,epoch=<span class="number">300</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Final Loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(loss[-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><pre><code>300/300Final Loss: [0.639463]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X_test_pm25 = data_test[data_test[<span class="string">&#x27;測項&#x27;</span>]==<span class="string">&#x27;PM2.5&#x27;</span>].iloc[:,<span class="number">2</span>:].values.astype(<span class="built_in">float</span>)</span><br><span class="line">X = np.column_stack((X_test_pm25,np.ones(X_test_pm25.shape[<span class="number">0</span>])))</span><br><span class="line">Y = X.dot(w)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = pd.merge(data_test[data_test[<span class="string">&#x27;測項&#x27;</span>]==<span class="string">&#x27;PM2.5&#x27;</span>].iloc[:,<span class="number">0</span>].reset_index(drop=<span class="literal">True</span>),pd.DataFrame(Y),left_index=<span class="literal">True</span>,right_index=<span class="literal">True</span>,how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">result.columns = [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">result.to_csv(OUT_DIR + <span class="string">&quot;submission.csv&quot;</span>,index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h2 id="结果">结果</h2><p><strong>最终的 Public Score 是 6.28859（击败 Simple Baseline: 6.55912），Private Score 是 8.53027（击败 Simple Baseline: 8.73773）</strong></p><h1>Regression - Model2 : Take more feature into consideration</h1><h2 id="模型构建">模型构建</h2><p>模型方面其实没有变化，但是这一步中，我们将考虑数据中给出的所有特征，并不局限于 PM 2.5 数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">grad_descent</span>(<span class="params">X,Y,epoch=<span class="number">20</span>,eta=<span class="number">0.0001</span>,w_old=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        X: 输入数据集, Numpy 矩阵 (Sample_count, Attr_count)</span></span><br><span class="line"><span class="string">        Y: 预测标签, Numpy 矩阵 (Sample_count, 1)</span></span><br><span class="line"><span class="string">        epoch: 迭代轮数</span></span><br><span class="line"><span class="string">        eta: 学习率</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    X = np.column_stack((X,np.ones(X.shape[<span class="number">0</span>])))</span><br><span class="line">    Y = Y.reshape((Y.shape[<span class="number">0</span>],<span class="number">1</span>))</span><br><span class="line">    w = w_old <span class="keyword">if</span> w_old <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> np.random.random(size=(X.shape[<span class="number">1</span>],<span class="number">1</span>)) <span class="comment"># 随机初始化参数 w（Step 1）</span></span><br><span class="line">    loss = []</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">iter</span> <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\r&#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">iter</span>+<span class="number">1</span>,epoch),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        gradient = <span class="number">2</span> * X.T.dot(X.dot(w)-Y) / X.shape[<span class="number">0</span>]                       <span class="comment"># 计算 L 对 w 的偏微分，即梯度。（Step 2）</span></span><br><span class="line">        w = w - eta * gradient                                                <span class="comment"># 更新参数 w （Step 3）</span></span><br><span class="line">        loss.append((Y-X.dot(w)).T.dot(Y-X.dot(w)).reshape(-<span class="number">1</span>)/ X.shape[<span class="number">0</span>])   <span class="comment"># 计算损失 L</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> w, loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_loss</span>(<span class="params">loss,title=<span class="string">&quot;Loss Value per Iter&quot;</span></span>):</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot()</span><br><span class="line">    ax.set_title(title)</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;iteration&quot;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&quot;Loss/MSE&quot;</span>)</span><br><span class="line">    ax.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(loss)),np.array(loss).reshape(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w,loss = grad_descent(np.array(X_train,dtype=<span class="built_in">float</span>).reshape(<span class="built_in">len</span>(X_train),-<span class="number">1</span>),np.array(y_train,dtype=<span class="built_in">float</span>),epoch=<span class="number">300</span>,eta=<span class="number">0.0000014</span>)</span><br></pre></td></tr></table></figure><pre><code>300/300</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_loss(loss)</span><br></pre></td></tr></table></figure><p><img src="https://download.mariozzj.cn/img/picgo/202112051945774.png" alt="plt"></p><p>在这部分，我们略去 Model1 中已经涉及的参数调节过程，直接选取我多次实验后选取的最优参数，随后直接进行预测。</p><h2 id="模型预测-2">模型预测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X_test = data_test.iloc[:,<span class="number">2</span>:].values.astype(<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">id</span> = data_test.日期.unique()</span><br><span class="line">X_test = X_test.reshape(<span class="built_in">len</span>(<span class="built_in">id</span>),-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X = np.column_stack((X_test,np.ones(X_test.shape[<span class="number">0</span>])))</span><br><span class="line">Y = X.dot(w)</span><br><span class="line">result = pd.merge(pd.DataFrame(<span class="built_in">id</span>),pd.DataFrame(Y),left_index=<span class="literal">True</span>,right_index=<span class="literal">True</span>,how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">result.columns = [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">result.to_csv(OUT_DIR + <span class="string">&quot;submission.csv&quot;</span>,index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h2 id="结果-2">结果</h2><p>确定 $\eta = 1.4 \times 10^{-6}$ 是学习率的最优参数后，在 Kaggle 上进行了多次提交，发现设定迭代次数在 50000 次以内时，结果得分在 10 ~ 30；而设定迭代次数到 100000 次时， <strong>取得了 Public Score 为 6.406，Private Score 为 8.477，表现优于 Model1</strong> ，但是显然出现了 <strong>参数收敛较慢</strong> 的问题。</p><p>考虑更多指标，本质上是增加了模型的复杂度，因为 Model2 的表示能力是大于且包含 Model1 的表示能力的（因为 Model1 的 9 个参数均是 Model2 的参数），所以 Model2 的理论性能是一定要高于 Model1 的。</p><p>如果提升学习率，会使得损失函数无法收敛，所以在其他方面对模型还有优化空间。</p><h1>Regression - Model3 : Normalize the Feature</h1><p>在 Model2 中考虑了更多指标，提升了模型表现，但是带来了另一个问题：<strong>参数收敛较慢</strong>，造成该现象的原因可能是，我们引入了新的参数，而新的参数与 Model1 的特征的量纲完全不同，即我们只考虑 PM2.5 指标值，它的范围可能是 0 - 200，而如果考虑 WIND_DIRECTION，它的范围则是 0 ~ 360。对于不同范围的特征，参数的敏感程度是不同的，就可能带来不同参数收敛速度不同，造成整体参数收敛速度较慢。而如果将所有参数都标准化，就可以在一定程度上提升参数的收敛速度。</p><p><img src="https://download.mariozzj.cn/img/picgo/202112052001819.png" alt="avatar"></p><h2 id="Normalizaiton">Normalizaiton</h2><p>我们将采用 Min-Max Normalization，需要获取各参数的最大值、最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X_large = np.array(X_train[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train)):</span><br><span class="line">    X_large = np.column_stack((X_large,X_train[i]))</span><br><span class="line">X_max = np.<span class="built_in">max</span>(X_large,axis=<span class="number">1</span>)</span><br><span class="line">X_min = np.<span class="built_in">min</span>(X_large,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>随后，对数据中的每一个元素都进行标准化操作。Min-Max Normalization 的方法是：</p><p>$$<br>x^\star = \dfrac{x-\min{\boldsymbol({x})}}{\max{\boldsymbol({x})}-\min{\boldsymbol({x})}}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X_norm = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train)):</span><br><span class="line">    X_norm.append(((X_train[i].T-X_min)/(X_max-X_min)).T)</span><br></pre></td></tr></table></figure><h2 id="模型构建-2">模型构建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w,loss = grad_descent(np.array(X_norm,dtype=<span class="built_in">float</span>).reshape(<span class="built_in">len</span>(X_norm),-<span class="number">1</span>),np.array(y_train,dtype=<span class="built_in">float</span>),epoch=<span class="number">1000</span>,eta=<span class="number">0.035</span>)</span><br></pre></td></tr></table></figure><pre><code>1000/1000</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot_loss(loss)</span><br><span class="line"><span class="built_in">print</span>(loss[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>[20.63629716]</code></pre><p><img src="https://download.mariozzj.cn/img/picgo/202112051945718.png" alt="plt"></p><p>可以看到，对数据进行标准化操作后，参数收敛的速度没有比上一轮快，但是损失值远远比不标准化特征还要低，这可能是因为特征值被放缩导致欧式距离减小导致的。但是相比而言，损失值比不放缩数据更早收敛。</p><h2 id="模型预测-3">模型预测</h2><p>由于我们对训练集输入进行了标准化，那么我们对测试集输入也需要进行相同的操作，而这里标准化的最大值、最小值并不是取决于测试集，而是取决于训练集，这样才能<strong>使得两个数据集具有对等的放缩映射，模型参数才能生效</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X_test = data_test.iloc[:,<span class="number">2</span>:].values.astype(<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">id</span> = data_test.日期.unique()</span><br><span class="line">attr_count = <span class="built_in">int</span>(X_test.shape[<span class="number">0</span>]/<span class="built_in">len</span>(<span class="built_in">id</span>))</span><br><span class="line">X_test_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(X_test.shape[<span class="number">0</span>]/attr_count)):</span><br><span class="line">    X_i = X_test[i*attr_count:(i+<span class="number">1</span>)*attr_count]</span><br><span class="line">    X_test_list.append(((X_i.T-X_min)/(X_max-X_min)).T)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X_test = np.array(X_test_list).reshape(<span class="built_in">int</span>(X_test.shape[<span class="number">0</span>]/attr_count),-<span class="number">1</span>)</span><br><span class="line">X = np.column_stack((X_test,np.ones(X_test.shape[<span class="number">0</span>])))</span><br><span class="line">Y = X.dot(w)</span><br><span class="line">result = pd.merge(pd.DataFrame(<span class="built_in">id</span>),pd.DataFrame(Y),left_index=<span class="literal">True</span>,right_index=<span class="literal">True</span>,how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">result.columns = [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">result.to_csv(OUT_DIR + <span class="string">&quot;submission.csv&quot;</span>,index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h2 id="结果-3">结果</h2><p>迭代同样次数情况下，取得 <strong>Public Score 6.286，Private Score 8.221 成绩</strong>。</p><h1>Regression - Model4 : Ordinary Least Squares</h1><p>如果数据量较大，能够实现输入矩阵求逆，就可以不使用梯度下降的方法逐次迭代寻找最优，而是利用最小二乘法直接求取最优值。</p><h2 id="模型构建-3">模型构建</h2><p>前面我们已经得到<br>$$<br>\dfrac{\partial L}{\partial \boldsymbol{\hat{w}}} = \dfrac{2}{m} \boldsymbol{X}^T(\boldsymbol{X}\boldsymbol{\hat{w}}-\boldsymbol{y})<br>$$<br>我们可以令 $\dfrac{\partial L}{\partial \boldsymbol{\hat{w}}}=0$ ，即可得到最优解<br>$$<br>\boldsymbol{\hat{w}}^\star = (\boldsymbol{X}^T\boldsymbol{X})^{-1}\boldsymbol{X}^T\boldsymbol{y}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ols</span>(<span class="params">X,Y</span>):</span><br><span class="line">    X = np.column_stack((X,np.ones(X.shape[<span class="number">0</span>])))</span><br><span class="line">    Y = Y.reshape((Y.shape[<span class="number">0</span>],<span class="number">1</span>))</span><br><span class="line">    w = np.linalg.inv(X.T.dot(X)).dot(X.T.dot(Y))</span><br><span class="line">    <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = ols(np.array(X_norm,dtype=<span class="built_in">float</span>).reshape(<span class="built_in">len</span>(X_norm),-<span class="number">1</span>),np.array(y_train,dtype=<span class="built_in">float</span>))</span><br></pre></td></tr></table></figure><h2 id="模型预测-4">模型预测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Y = X.dot(w)</span><br><span class="line">result = pd.merge(pd.DataFrame(<span class="built_in">id</span>),pd.DataFrame(Y),left_index=<span class="literal">True</span>,right_index=<span class="literal">True</span>,how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">result.columns = [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">result.to_csv(OUT_DIR + <span class="string">&quot;submission.csv&quot;</span>,index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h2 id="结果-4">结果</h2><p>采用最小二乘法直接求取闭式解的结果是：Public Score 6.290，Private Score 8.221，表现均比 Model2、3 好。</p><h1>Summary</h1><h2 id="Results">Results</h2><p>本次竞赛就丰原站气象数据进行了回归预测，对模型进行了优化，最终表现总结如下表：</p><table><thead><tr><th style="text-align:right">Model</th><th style="text-align:center">iteration</th><th style="text-align:center">parameters &amp; Description</th><th style="text-align:right">PubScore</th><th style="text-align:right">PrivScore</th></tr></thead><tbody><tr><td style="text-align:right">GD Model 1</td><td style="text-align:center">$10^2$</td><td style="text-align:center">$\eta = 1.5 \times 10^{-4}$ ，仅考虑 PM2.5 指标</td><td style="text-align:right">6.289</td><td style="text-align:right">8.530</td></tr><tr><td style="text-align:right">GD Model 2</td><td style="text-align:center">$10^5$</td><td style="text-align:center">$\eta = 1.4 \times 10^{-6}$ ，考虑所有提供的指标</td><td style="text-align:right">6.406</td><td style="text-align:right">8.422</td></tr><tr><td style="text-align:right">GD Model 3</td><td style="text-align:center">$10^5$</td><td style="text-align:center">$\eta = 3.5 \times 10^{-2}$ ，对所有指标标准化</td><td style="text-align:right">6.286</td><td style="text-align:right">8.221</td></tr><tr><td style="text-align:right">OLS Model</td><td style="text-align:center">1</td><td style="text-align:center">直接求解</td><td style="text-align:right">6.290</td><td style="text-align:right">8.220</td></tr><tr><td style="text-align:right">Simple Baseline</td><td style="text-align:center">Unknown</td><td style="text-align:center">Unknown</td><td style="text-align:right">6.559</td><td style="text-align:right">8.738</td></tr><tr><td style="text-align:right">Strong Baseline</td><td style="text-align:center">Unknown</td><td style="text-align:center">Unknown</td><td style="text-align:right">5.560</td><td style="text-align:right">7.142</td></tr></tbody></table><p>尝试的所有模型均突破了 Simple Baseline，但是距离 Strong Baseline 仍然还有一定距离。</p><h2 id="Highlights">Highlights</h2><ul><li>相比于大部分他人做法，我<strong>采样获得的样本较多</strong>，获取了大多数连续的 8 小时作为样本，总计 3 840 样本。</li><li>考虑了学习率、迭代轮数、特征选择、特征放缩等因素优化模型。</li></ul><h2 id="Lowlights">Lowlights</h2><ul><li>可以使用交叉验证进行模型选择</li><li>没有进行本地测试准确率评估性能，仅参考 Loss</li><li>考虑的样本、特征过多可能带来了噪声，可以考虑进行降维或进一步特征选择</li><li>可以将学习率优化为自适应</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数科知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> Regression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Town of Salem 板子(1)：Classic</title>
      <link href="/posts/2b373355/"/>
      <url>/posts/2b373355/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：如果不太了解本文的说明方法，可以先查看下面的说明，否则可以直接进入下一章</p></blockquote><h2 id="游戏介绍">游戏介绍</h2><p>如果你还不熟悉这个游戏，可以先看看这个游戏的 <a href="https://blog.mariozzj.cn/posts/2b373354/">简单介绍</a>。</p><h2 id="角色属性">角色属性</h2><p>在介绍角色时，会依次介绍其属性，各属性的解释如下：</p><ul><li><p>攻击力（Attack）：攻击力是该角色攻击能力的度量，可分为以下四个级别：</p><ul><li>无（None）：该角色不能直接攻击其他角色</li><li>基础（Basic）：该角色能够攻击防御力为无（None）的角色</li><li>强力（Powerful）：该角色能够攻击防御力在基础（Basic）及以下的角色</li><li>无敌（Unstoppable）：该角色能够攻击防御力在强力（Powerful）及以下的角色</li></ul></li><li><p>防御力（Defense）：防御力是该角色防御能力的度量，可分为以下四个级别：</p><ul><li>无（None）：会因为任何级别的攻击死亡</li><li>基础（Basic）：能够免于攻击力为基础（Basic）角色带来的伤害</li><li>强力（Powerful）：该角色能够免于攻击力不大于强力（Powerful）角色带来的伤害</li><li>无敌（Invincible）：该角色能够免于攻击力不大于无敌（Unstoppable）角色带来的伤害</li></ul></li><li><p>阵营（属性）：代表角色所属的阵营，可分为</p><ul><li>村民（Town）</li><li>黑手党（Mafia）</li><li>中立（Neutral）</li><li>女巫团（Coven，仅 Coven 模式）</li></ul><p>后面的括号体现该角色的属性，可分为</p><ul><li>保护（Protective）</li><li>支持（Support）</li><li>调查（Investigate）</li><li>杀戮（Killing）</li><li>欺骗（Deception）</li><li>无害（Benign）</li><li>邪恶（Evil）</li><li>混乱（Chaos）</li></ul><p>如小丑（Jester）的阵营为：中立（邪恶）</p></li><li><p>目标：取得胜利的目标</p></li><li><p>能力：该角色的技能</p></li><li><p>其他说明：除了上述部分外，还需要解释的特殊情况</p></li></ul><h1>Classic 游戏基本属性</h1><ul><li>人数：15 人</li><li>流程：白天-黑夜</li><li>涉及阵营：村民、黑手党、中立</li><li>游戏属性：明牌、屠城</li></ul><p>在在线 Town of Salem 中，该模式是最基础的模式，角色构成相对简单，0 基础玩家在该模式完成 50 局游戏之后才可进入排位模式。一般单局游戏时长在 10 - 30 分钟不等。</p><h1>Classic 游戏角色配置</h1><h2 id="村民阵营（Town）">村民阵营（Town）</h2><h3 id="警官（Sheriff）">警官（Sheriff）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112032226316.png" alt="Sheriff"></p><ul><li><p>攻击力：无</p></li><li><p>防御力：无</p></li><li><p>阵营：村民（调查）</p></li><li><p>目标：处决所有的罪犯和作恶者</p></li><li><p>技能：每天夜晚选定一名玩家进行调查，夜晚结算时得知该玩家是可疑的（Suspicious）还是无辜的（Innocent）。</p></li><li><p>其他说明：</p><ul><li>调查的结果会根据调查对象的角色而决定</li><li>除教父（GodFather）以外的黑手党阵营角色都是可疑的</li><li>连环杀手（Serial Killer）是可疑的</li><li>被诬陷者（Framer）诬陷的对象是可疑的</li><li>在本模式中的其他情况，对象是无辜的</li></ul></li></ul><h3 id="监哨（Lookout）">监哨（Lookout）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112032232485.png" alt="Lookout"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：村民（调查）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：选定一位玩家，夜晚结算时得知哪些玩家在当晚拜访了该玩家</li></ul><h3 id="侦察员（Investigator）">侦察员（Investigator）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112032235833.png" alt="Investigator"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：村民（调查）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：选定一位玩家，在夜晚结算时得知和这位玩家角色有关的提示</li><li>其他说明：一般提示的形式是：“你的目标可能是 A / B / C”，其中可能有本局游戏中不包含的角色</li></ul><h3 id="狱卒（Jailor）">狱卒（Jailor）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112032239859.png" alt="Jailor"></p><ul><li>攻击力：无敌</li><li>防御力：无</li><li>阵营：村民（杀戮）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：在白天选定一位玩家，晚上将该玩家投入监狱，在夜晚可以选择处决该玩家</li><li>其他说明：<ul><li>在夜晚，狱卒和被投入监狱的玩家可以对话，其中被囚者不知道狱卒的身份</li><li>被囚者不能使用其夜晚技能，不能与同阵营玩家对话，同阵营玩家可能得知该玩家被囚信息</li><li>如果在晚上处决了一名村民阵营玩家，将永久失去技能</li></ul></li></ul><h3 id="医生（Doctor）">医生（Doctor）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112032243782.png" alt="Doctor"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：村民（保护）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：每天晚上选择治疗一名玩家，该玩家当晚具有无敌（Powerful）免疫力</li><li>其他说明：<ul><li>整局游戏你只能治疗自己一次</li><li>夜晚结算时你可以得知你的目标当晚是否被袭击</li></ul></li></ul><h3 id="陪酒（Escort）">陪酒（Escort）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112032246838.png" alt="Escort"></p><ul><li><p>攻击力：无</p></li><li><p>防御力：无</p></li><li><p>阵营：村民（支持）</p></li><li><p>目标：处决所有的罪犯和作恶者</p></li><li><p>技能：每晚可以魅惑一名玩家</p></li><li><p>其他说明：</p><ul><li>被魅惑的玩家当晚的技能失效，在夜晚结算时被魅惑的玩家可以得知自己被魅惑</li><li>你不能被魅惑</li></ul></li></ul><h3 id="灵媒（Medium）">灵媒（Medium）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112032249831.png" alt="Medium"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：村民（支持）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：<ul><li>每晚可以和已死亡的所有玩家交流（死亡的玩家并不知道灵媒的具体身份）</li><li>死亡后可以指定和一位存活玩家交流（整局游戏限一次）</li></ul></li></ul><h3 id="随机杀戮属性村民（Town-Killing）">随机杀戮属性村民（Town Killing）</h3><p>为增强游戏随机性，本模式除以上角色外，还会随机配置一位村民（杀戮）角色进入身份堆。</p><h4 id="狱卒（Jailor）-2">狱卒（Jailor）</h4><h4 id="老兵（Veteran）">老兵（Veteran）</h4><p><img src="https://download.mariozzj.cn/img/picgo/202112032254802.png" alt="Veteran"></p><ul><li>攻击力：无敌</li><li>防御力：无</li><li>阵营：村民（杀戮）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：<ul><li>每晚决定当晚是否保持警觉，保持警觉的夜晚所有来访者都会被你袭击</li></ul></li><li>其他说明：<ul><li>警觉时，当晚具有基本（Basic）防御力</li><li>整局游戏你只能保持警觉 3 次</li><li>你不能被魅惑</li></ul></li></ul><h4 id="义务警员（Vigilante）">义务警员（Vigilante）</h4><p><img src="https://download.mariozzj.cn/img/picgo/202112032258280.png" alt="Vigilante"></p><ul><li>攻击力：基本</li><li>防御力：无</li><li>阵营：村民（杀戮）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：每晚可以决定袭击一位玩家</li><li>其他说明：<ul><li>如果你射杀了一位村民阵营的玩家，你在接下来的那个晚上会射杀自己</li><li>你的枪里只有 3 枚子弹（只能袭击其他玩家三次）</li></ul></li></ul><h3 id="随机村民（Town-Random）">随机村民（Town Random）</h3><p>随机村民不限制村民的属性，可能是</p><ul><li>村民（保护）：保镖、十字军战士、医生、陷阱人</li><li>村民（支持）：陪酒、市长、灵媒、报应者、交换者</li><li>村民（调查）：调查员、监哨、警官、密探、通灵师、追踪者</li><li>村民（杀戮）：狱卒、老兵、义务警员</li></ul><h4 id="保镖（Bodyguard）">保镖（Bodyguard）</h4><p><img src="https://download.mariozzj.cn/img/picgo/202112032302717.png" alt="Bodyguard"></p><ul><li>攻击力：无敌</li><li>防御力：无</li><li>阵营：村民（保护）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：每晚可以选择保护一位玩家，你和当晚袭击该玩家的角色决斗</li><li>其他说明：<ul><li>如果你成功保护了一名玩家，你可以被治疗</li></ul></li></ul><h4 id="十字军战士（Crusader）">十字军战士（Crusader）</h4><p><img src="https://download.mariozzj.cn/img/picgo/202112032307563.png" alt="Crusader"></p><ul><li>攻击力：基本</li><li>防御力：无</li><li>阵营：村民（保护）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：每晚可以选择保护一名玩家，该玩家当晚具有无敌防御力，你和当晚袭击该玩家的角色决斗</li><li>其他说明：<ul><li>你可以得知你保护的目标是否被袭击</li></ul></li></ul><h4 id="医生（Doctor）-2">医生（Doctor）</h4><h4 id="陪酒（Escort）-2">陪酒（Escort）</h4><h4 id="侦察员（Investigator）-2">侦察员（Investigator）</h4><h4 id="狱卒（Jailor）-3">狱卒（Jailor）</h4><h4 id="监哨（Lookout）-2">监哨（Lookout）</h4><h4 id="市长（Mayor）">市长（Mayor）</h4><p><img src="https://download.mariozzj.cn/img/picgo/202112032312672.png" alt="Mayor"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：村民（支持）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：你可以在白天选择明牌；明牌后你的 1 票记作 3 票</li><li>其他说明：<ul><li>你明牌后不能被治疗</li><li>你明牌后不能向他人发送密语；你明牌后他人不能想你发送密语</li></ul></li></ul><h4 id="灵媒（Medium）-2">灵媒（Medium）</h4><h4 id="通灵师（Psychic）">通灵师（Psychic）</h4><p><img src="https://download.mariozzj.cn/img/picgo/202112032319081.png" alt="Psychic"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：村民（调查）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：每晚得到关于其他玩家身份的线索<ul><li>奇数夜晚你会获知 3 位玩家，其中至少 1 位是罪恶的</li><li>偶数夜晚你会获知 2 位玩家，其中至少 1 位是善良的</li></ul></li></ul><h4 id="报应者（Retributionist）">报应者（Retributionist）</h4><p><img src="https://download.mariozzj.cn/img/picgo/202112032327444.png" alt="Retributionist"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：村民（支持）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：每晚可以选择使用一名已死亡玩家的技能</li><li>其他说明：<ul><li>每位死亡玩家的技能只能被使用一次</li></ul></li></ul><h4 id="警官（Sheriff）-2">警官（Sheriff）</h4><h4 id="密探（Spy）">密探（Spy）</h4><p><img src="https://download.mariozzj.cn/img/picgo/202112032331695.png" alt="Spy"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：村民（调查）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：每晚选择一名玩家，得知当晚拜访该玩家的信息（具体到事件）</li><li>其他说明：相比于监哨只知道哪些玩家拜访了目标，密探知道拜访玩家的具体目的</li></ul><h4 id="追踪者（Tracker）">追踪者（Tracker）</h4><p><img src="https://download.mariozzj.cn/img/picgo/202112032334058.png" alt="Tracker"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：村民（调查）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：每晚选择一名玩家，得知他们当晚拜访了哪位玩家</li></ul><h4 id="交换者（Transporter）">交换者（Transporter）</h4><p><img src="https://download.mariozzj.cn/img/picgo/202112032336750.png" alt="Transporter"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：村民（支持）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：选择两位玩家，当晚发生在这两位玩家身上的事都会交换</li><li>其他说明：<ul><li>你可以交换你自己</li><li>你的目标在夜晚结算时知道他当晚是否被交换</li></ul></li></ul><h4 id="陷阱人（Trapper）">陷阱人（Trapper）</h4><p><img src="https://download.mariozzj.cn/img/picgo/202112032340628.png" alt="Trapper"></p><ul><li>攻击力：无敌</li><li>防御力：无</li><li>阵营：村民（保护）</li><li>目标：处决所有的罪犯和作恶者</li><li>技能：白天可以在其他玩家的门前设置一个陷阱</li><li>其他说明：<ul><li>所有拜访门前有陷阱的玩家的玩家都会知道他踩到了陷阱，但是只有那些袭击这位玩家的玩家会被伤害</li><li>踩到陷阱的玩家会知道你是陷阱人</li><li>在晚上你可以在晚上选择自己，当晚让陷阱收回</li><li>你至多只能设置 1 个陷阱</li></ul></li></ul><h4 id="老兵（Veteran）-2">老兵（Veteran）</h4><h4 id="义务警员（Vigilante）-2">义务警员（Vigilante）</h4><h2 id="黑手党阵营（Mafia）">黑手党阵营（Mafia）</h2><h3 id="教父（GodFather）">教父（GodFather）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112032347341.png" alt="GodFather"></p><ul><li>攻击力：基本</li><li>防御力：基本</li><li>阵营：黑手党（杀戮）</li><li>目标：杀死那些不屈从于黑手党的人</li><li>技能：每晚可选择袭击一位目标</li><li>其他说明：<ul><li>如果黑手党成员存活，他会替你袭击你选择的目标（即不会出现你拜访目标的记录）</li><li>警官查验你为无辜的</li></ul></li></ul><h3 id="诬陷者（Framer）">诬陷者（Framer）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112032349263.png" alt="Framer"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：黑手党（欺骗）</li><li>目标：杀死那些不屈从于黑手党的人</li><li>技能：选择一位目标，该目标当晚被诬陷</li><li>其他说明：<ul><li>你会拜访该目标；该目标如果被查验，结果为可疑的</li><li>如果场上没有其他可以袭击村民的黑手党角色，你会变为黑手党成员</li></ul></li></ul><h3 id="黑手党成员（Mafioso）">黑手党成员（Mafioso）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112032353613.png" alt="Mafioso"></p><ul><li>攻击力：基本</li><li>防御力：无</li><li>阵营：黑手党（杀戮）</li><li>目标：杀死那些不屈从于黑手党的人</li><li>技能：每晚可以选择袭击一位目标</li><li>其他说明：<ul><li>如果教父存活，你袭击教父指定的目标；如果他没有指定目标，你袭击你选择的目标</li><li>如果教父死亡，你变为教父</li></ul></li></ul><h2 id="中立角色（Neutral）">中立角色（Neutral）</h2><h3 id="连环杀手（Serial-Killer）">连环杀手（Serial Killer）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112032355359.png" alt="Serial Killer"></p><ul><li>攻击力：基本</li><li>防御力：基本</li><li>阵营：中立（杀戮）</li><li>目标：杀死那些反抗你的人（所有人）</li><li>技能：每晚选择袭击一名目标</li><li>其他说明：<ul><li>如果你被屏蔽（魅惑），你还将杀死魅惑你的人，魅惑你的人的遗嘱会浸染鲜血，不可被阅读；你也可以选择保持谨慎，不杀死魅惑你的人</li></ul></li></ul><h3 id="刽子手（Executioner）">刽子手（Executioner）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112040000499.png" alt="Executioner"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：中立（邪恶）</li><li>目标：不惜任何代价，让你的目标白天被处决</li><li>技能：无</li><li>其他说明：<ul><li>在游戏开始时你会得知你的目标是哪位玩家</li><li>如果你的目标死于夜晚，你会变为小丑（Jester）</li></ul></li></ul><h3 id="小丑（Jester）">小丑（Jester）</h3><p><img src="https://download.mariozzj.cn/img/picgo/202112040002952.png" alt="image-20211204000259859"></p><ul><li>攻击力：无</li><li>防御力：无</li><li>阵营：中立（邪恶）</li><li>目标：不惜任何代价，让你自己白天被处决</li><li>技能：无</li><li>其他说明：<ul><li>如果你被处决，在下一个夜晚，你可以从最终表决中表态有罪（Guilty），或不表态（Abstain）的人中选择一个目标，当晚他将受到来自你的无敌（Unstoppable）攻击。</li></ul></li></ul><h1>常见玩法</h1><h2 id="狱卒带队">狱卒带队</h2><p>第一天狱卒表明身份，要求所有玩家密语告诉狱卒他的身份（当然，第一天时间很短，不是所有玩家都来得及密语），狱卒从那些可疑的或不说话的人中选择 1 人当晚入狱审问。为了尽可能保全狱卒，医生尽量每晚都去治疗狱卒。狱卒也要防止小丑等角色的袭击</p><h2 id="快乐二选一">快乐二选一</h2><p>白天让所有角色表明身份（role call），如果出现对立的发言（cc，Counter Claim，可以是相同的角色，或者考虑随机杀戮村民TK/TownKilling、随机村民RT/RandomTown的角色数量矛盾），则选择处决一名较可疑的玩家，如果该玩家是好人（真实身份），当晚由狱卒处决另一名玩家或下一个白天处决该玩家</p><h2 id="故意CC">故意CC</h2><p>故意 Counter Claim，小丑可以选择装坏人，或者故意表明一个重复的矛盾的身份，使得自己被处决；刽子手也可以假装查验自己的目标为可疑的，将其推下水。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桌面游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Town of Salem 游戏简介</title>
      <link href="/posts/2b373354/"/>
      <url>/posts/2b373354/</url>
      
        <content type="html"><![CDATA[<h1>游戏简介</h1><p>塞勒姆小镇（Town of Salem）是独立游戏开发商 BlankMediaGames 开发和运行的游戏，于 2014 年 12 月 15 日发布，目前在 PC、浏览器、iOS、Android 端均可游玩。</p><p><img src="https://download.mariozzj.cn/img/picgo/202112032101984.jpeg" alt="Town of Salem"></p><p>这款游戏的灵感来自 Werewolf（狼人） / Mafia（黑手党/杀手），其游戏流程和阵营设置也与我们熟知的狼人游戏极为相似：玩家分为好人、坏人、中立等阵营，分配拥有不同能力的角色，在白天进行讨论并公投处决一名玩家，在晚上拥有能力的玩家进行操作，获取对应的信息。</p><iframe src="//player.bilibili.com/player.html?aid=714232396&bvid=BV1rX4y157Wc&cid=454008208&page=5" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="400px"> </iframe><p>我认为这款游戏设置的角色非常丰富，与狼人杀不同，这款游戏没有“平民”，每一位玩家都有其可操作的技能和目标，也没有“屠边”规则，玩家在死亡后一般公开身份和死因，同时一般会公开该玩家的“遗嘱”——在游戏过程中记录自己了解的信息，便于推理，死亡的玩家也可以参与讨论并通过特定角色向存活玩家传递信息，整体而言玩家参与感和可玩性非常高。</p><h1>游戏流程</h1><p>游戏从第一天白天（Day 1）开始，随后是第一天夜晚（Night 1），随后昼夜交替。所有玩家在游戏全程可以编辑自己的遗嘱（will）内容。</p><h2 id="白天：公布死讯">白天：公布死讯</h2><p><img src="https://download.mariozzj.cn/img/picgo/202112032110498.png" alt="公布死讯"></p><p>所有玩家睁眼集合，宣布昨天晚上死亡的玩家的讯息，其中包括：</p><ul><li>死亡玩家的死因（其中，在晚上离线的玩家立即死亡，死因为自杀 : commit suiside）</li><li>死亡玩SS家的遗嘱（will）</li><li>死亡笔记（Death Note），由凶手留下、</li><li>死亡玩家的角色</li></ul><h2 id="白天：自由讨论">白天：自由讨论</h2><p><img src="https://download.mariozzj.cn/img/picgo/202112032111078.png" alt="自由讨论"></p><p>随后所有玩家进行交流讨论。在网络端游戏时，所有玩家采用文字形式进行讨论，白天发出的消息可以被所有人看到。玩家也可以选择对指定玩家发送密语（whisper），公共聊天区仅展示玩家 A 向玩家 B 发送了密语，但密语内容只有 A、B 可见。密语可以在白天的任意阶段发送，不限于自由讨论阶段。</p><p>玩家交流时，可以快速将自己的遗嘱全部发出（post the will）。</p><h2 id="白天：处决公投">白天：处决公投</h2><p><img src="https://download.mariozzj.cn/img/picgo/202112032111813.png" alt="处决公投"></p><p>讨论环节结束后，所有玩家可以进行投票，投票不能指定自己为目标。</p><p>公投有时间限制（如 20s），在时间限制内玩家均可投票、取消、改票，其他玩家可以立即看到投票者和投票内容，或相应的投票操作。</p><p>当某名玩家头上的选票数超过一定数值（由存活玩家数决定），则立即进入该玩家的辩词和处决阶段。</p><p>只要当天白天没有玩家被处决且未超过处决公投时间限制，则可继续发起投票。</p><p>当公投时间完全用尽且没有玩家被处决时，当天不处决玩家，直接进入天黑。（It is too late to continue the vote.）</p><h2 id="白天：辩词与处决">白天：辩词与处决</h2><p><img src="https://download.mariozzj.cn/img/picgo/202112032114771.png" alt="辩词与处决"></p><p>进入某玩家的辩词与处决阶段，该名玩家具有一段时间的辩解时间（defense），在这段时间内其他玩家不能公开发送消息，只有该玩家可以发言。</p><p>这段时间结束后，所有玩家可以自由发言，并且需要做出表态：有罪（guilty）或无辜（innocent），也可以不选择（abscent），在处决阶段，玩家可以变更自己的选择，直到限定时间结束。</p><p>如果做出有罪表态的玩家数量多于无辜表态的玩家数量，则处决该名玩家，其具有最后 5 秒的遗言时间（last word），随后公布该玩家的遗嘱、角色；</p><p>如果做出有罪表态的玩家数量不多于无辜表态的玩家数量，则不处决该名玩家，玩家返回讨论区，继续消耗处决公投阶段的时间。</p><h2 id="夜晚：行动">夜晚：行动</h2><p><img src="https://download.mariozzj.cn/img/picgo/202112032109802.png" alt="夜晚行动"></p><p>夜晚各位玩家采取行动，村民（Town）和中立（Neutral）阵营角色之间一般不能交流，黑手党（Mafia）阵营角色之间可以交流。部分玩家根据其技能可以与特定玩家进行交流。</p><p>所有玩家需要根据自己的技能描述执行行动。</p><h2 id="夜晚：结算">夜晚：结算</h2><p><img src="https://download.mariozzj.cn/img/picgo/202112032112600.png" alt="夜晚结算"></p><p>所有玩家在夜晚结束时可以看到自己当晚被袭击、治疗、魅惑、处决等信息。根据技能，部分玩家在夜晚结束时可以看到自己的技能执行结果。</p><p>结算在瞬间完成，如果玩家在当晚死亡，白天展示的遗嘱（will）仅限于结算之前保存的内容。</p><p>结算完成后，进入白天流程。</p><h1>游戏结算</h1><p>一般来说，村民（Town）阵营的目标是处决每一位罪犯和作恶者（Lynch every criminal and evildoer），当场上不存在黑手党（Mafia）和部分中立（Neutral）阵营角色（如连环杀手 Serial Killer）时，游戏结束，村民阵营获胜。</p><p>一般来说，黑手党（Mafia）阵营的目标是杀死所有不向黑手党屈服的玩家（submit to the Mafia），当场上没有村民阵营角色存活时，游戏结束，黑手党阵营获胜。</p><p>中立（Neutral）阵营玩家一般具有特定的胜利条件，如果满足该条件结算时记为获胜，但是不会结束游戏，所以一般中立阵营玩家是与村民阵营或黑手党阵营玩家共同获胜的。</p><p>更多详情可以关注后续板子介绍文章，逐一介绍角色。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桌面游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>igraph 上手教程——使用 Python 开展社会网络分析和可视化</title>
      <link href="/posts/52d95125/"/>
      <url>/posts/52d95125/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址： <a href="https://blog.mariozzj.cn/posts/52d95125/">https://blog.mariozzj.cn/posts/52d95125/</a></p><p>国内镜像： <a href="https://cnblog.mariozzj.cn/posts/52d95125/">https://cnblog.mariozzj.cn/posts/52d95125/</a></p><p>原官方教程（英文）：<a href="https://igraph.org/python/tutorial/0.9.7/tutorial.html">https://igraph.org/python/tutorial/0.9.7/tutorial.html</a></p></blockquote><hr><h1>igraph</h1><p>igraph 是一个开源免费网络分析工具集合，在效率和便捷性上表现较好。之前所学和网络上的教程大多基于 R 语言，而实际上 igraph 为 R、Python、Mathematica 和 C/C++ 均有支持，可以前往 [igraph 官网](<a href="https://igraph.org/">igraph – Network analysis software</a>) 了解。</p><p>之前使用过 R 包的 igraph，但是我的 R 语言实在学艺不精，之后也没怎么用到过。在我的数据分析场景下，Python 可能相对于熟悉一些，且可以联动实现数据处理和分析，感觉非常方便。</p><p>igraph 的 Python 包的使用文档正在完善中，网络上几经查找并没有完全完整的中文版本手册，所以我本着学习这个程序包的目的顺便将其最新（0.9.7）的英文版本操作手册的概览教程翻译下来，主要来源于 <a href="https://igraph.org/python/tutorial/0.9.7/tutorial.html">Tutorial (igraph.org)</a> ，如有翻译不地道的地方也请各位指正！整体阅读下来感觉手册写的还是比较简明、全面的。</p><h1>安装 igraph</h1><p>使用 <code>pip</code> 安装 <code>igraph</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-igraph</span><br></pre></td></tr></table></figure><p>可以继续安装 <code>pycairo</code> 用于支持网络的可视化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycairo</span><br></pre></td></tr></table></figure><p>启动 Python 运行如下代码，检查是否安装成功：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> igraph <span class="keyword">as</span> ig</span><br><span class="line">petersen = ig.Graph.Famous(<span class="string">&quot;petersen&quot;</span>)</span><br><span class="line">ig.plot(petersen)</span><br></pre></td></tr></table></figure><p><img src="https://download.mariozzj.cn/img/picgo/202110261128175.png" alt="案例 - Petersen 网络图"></p><p>如安装无误，展示的是著名的 Petersen 图。</p><h1>igraph 使用教程</h1><h2 id="从零搭建图">从零搭建图</h2><p>引入 <code>igraph</code> 包后，可以自行创建一个图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ig.Graph()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;igraph.Graph at <span class="number">0x294fbc389a0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(g)</span><br><span class="line">IGRAPH U--- <span class="number">0</span> <span class="number">0</span> --</span><br></pre></td></tr></table></figure><p>在这里，<code>g</code> 是一个 Graph 实例。打印出来的结果中的两个数字是节点数和连边数。如果我们打印上一节的 Petersen 图，会这么返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(petersen)</span><br><span class="line">IGRAPH U--- <span class="number">10</span> <span class="number">15</span> --</span><br><span class="line">+ edges:</span><br><span class="line"> <span class="number">0</span> --  <span class="number">1</span>  <span class="number">4</span>  <span class="number">5</span>    <span class="number">3</span> --  <span class="number">2</span>  <span class="number">4</span>  <span class="number">8</span>    <span class="number">6</span> --  <span class="number">1</span>  <span class="number">8</span>  <span class="number">9</span>    <span class="number">9</span> --  <span class="number">4</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"> <span class="number">1</span> --  <span class="number">0</span>  <span class="number">2</span>  <span class="number">6</span>    <span class="number">4</span> --  <span class="number">0</span>  <span class="number">3</span>  <span class="number">9</span>    <span class="number">7</span> --  <span class="number">2</span>  <span class="number">5</span>  <span class="number">9</span></span><br><span class="line"> <span class="number">2</span> --  <span class="number">1</span>  <span class="number">3</span>  <span class="number">7</span>    <span class="number">5</span> --  <span class="number">0</span>  <span class="number">7</span>  <span class="number">8</span>    <span class="number">8</span> --  <span class="number">3</span>  <span class="number">5</span>  <span class="number">6</span></span><br></pre></td></tr></table></figure><p>这里还给出了具体的连边信息，Petersen 图中有 10 个节点和 15 条连边，每个节点都与三个节点相连。</p><p>我们可以调用 <code>add_vertices(num)</code> 方法为我们创建的图增加 num 个节点，使用 <code>add_edges([pairs])</code> 方法增加连边。<code>pairs</code> 为两个节点编号组成的元组，可以输入一至多个，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_vertices(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_edges([(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">5</span>), (<span class="number">5</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(g)</span><br><span class="line">IGRAPH U--- <span class="number">6</span> <span class="number">7</span> --</span><br><span class="line">+ edges:</span><br><span class="line"><span class="number">0</span>--<span class="number">1</span> <span class="number">1</span>--<span class="number">2</span> <span class="number">0</span>--<span class="number">2</span> <span class="number">2</span>--<span class="number">3</span> <span class="number">3</span>--<span class="number">4</span> <span class="number">4</span>--<span class="number">5</span> <span class="number">3</span>--<span class="number">5</span></span><br></pre></td></tr></table></figure><p>目前的这个网络中有 6 个节点和 7 条连边。在构建的网络中，节点 ID 是由 0 开始的连续整数，添加连边时的编号对就对应着这些 ID。而连边其实也是有 ID 的，也是由 0 开始的连续整数。节点和连边 ID 的连续性不会改变，所以如果我们删除节点和连边，可能会造成部分节点和连边 ID 的变化。</p><p>如果两个节点之间存在连边，我们可以使用 <code>get_eid()</code>方法获取他们的连边的编号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.get_eid(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>可以使用 <code>delete_vertices()</code> 方法删除图中的节点，可以使用 <code>delete_edges()</code> 删除图中的连边，括号内的参数为一至多个节点/连边的 ID。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.delete_edges(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ig.summary(g)</span><br><span class="line">IGRAPH U--- <span class="number">6</span> <span class="number">6</span> -- </span><br></pre></td></tr></table></figure><p><code>summary()</code> 方法可以只展示图的基本信息，相比于 <code>print()</code> 可以避免大图中大量连边占用输出。</p><h2 id="生成图">生成图</h2><p><code>igraph</code> 包中有多种图生成器，大体上可以分为两种：确定性（Deterministic）和随机性（Stochastic）图生成器。如果调用时输入相同的参数，确定性图生成器创建出来的图是完全相同的，而随机性图生成器则会生成不同的图。</p><p><strong>确定性图生成器</strong>包括创建树图、正则格（Regular Lattice）、环（Ring）、扩展弦环（Extended Chordal Ring）等著名图。如<code>Graph.Tree()</code> 方法可以创建树图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ig.Graph.Tree(<span class="number">127</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ig.summary(g)</span><br><span class="line">IGRAPH U--- <span class="number">127</span> <span class="number">126</span> --</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2 = ig.Graph.Tree(<span class="number">127</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2.get_edgelist() == g.get_edgelist()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2.get_edgelist()[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><p>创建了树图 <code>g</code>，共计 127 个节点，除叶子节点外每个节点都有 2 个孩子节点，所以共有 126 条连边。后面使用相同参数创建 <code>g2</code>，可发现 <code>g</code> 和 <code>g2</code> 连边完全相同。这里用到的 <code>get_edgelist()</code> 方法会返回连边元组组成的列表。</p><p>随机性图生成器可以创建 ER 随机图（Erdős-Rényi Random Network）、Barabási-Albert 网络模型、随机几何图形（Geometric Random graphs）等。如<code>Graph.GRG()</code> 方法可以创建随机几何图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ig.Graph.GRG(<span class="number">100</span>, <span class="number">0.2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ig.summary(g)</span><br><span class="line">IGRAPH U---- <span class="number">100</span> <span class="number">516</span> --</span><br><span class="line">+ attr: x (v), y (v)</span><br></pre></td></tr></table></figure><p>在创建随机几何图 <code>GRG(n,d)</code> 的两个参数中，<code>n</code> 指定了节点数量，<code>d</code> 则为连边距离阈值，所有点在单元空间中随机分布，距离小于 <code>d</code> 的则建立连边，这样一种建图规则会导致即使给出相同的参数，创建出来的图也是不一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2 = ig.Graph.GRG(<span class="number">100</span>, <span class="number">0.2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.get_edgelist() == g2.get_edgelist()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.isomorphic(g2)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>同样参数创建的 <code>g2</code> 与 <code>g</code> 的边-节点 ID 关系不同。使用<code>isomorphic()</code> 方法能够判定两个图是否同构（isomorphic），很显然从结果看，这次实验中二者也不是同构的。</p><p>在 GRG 的 summary 中，我们看到了图的参数（attr）被打印出来，接下来将继续介绍。</p><h2 id="设置与获取属性">设置与获取属性</h2><p><code>igraph</code> 使用 ID 区分不同的节点和连边，之前提到过这些 ID 是由 0 开始的连续的整数，当我们删除节点和连边时这种连续性不会被破坏，所以执行删除操作时可能涉及到其他节点/连边 ID 的变化。</p><p>假设我们使用 <code>igraph</code> 做社会网络分析，节点代表人，连边代表人之间的社会联系，一种可能的建立节点 ID 和人物名对应关系的方法是创建一个 Python 列表将 ID 和姓名对应起来，这种方式的缺陷是这个列表需要随网络的调整而同步调整，这样或许有些麻烦。</p><p><code>igraph</code> 支持为节点、连边、图对象添加属性。首先，我们创建一个简单的社会网络：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ig.Graph([(<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">2</span>), (<span class="number">2</span>,<span class="number">3</span>), (<span class="number">3</span>,<span class="number">4</span>), (<span class="number">4</span>,<span class="number">2</span>), (<span class="number">2</span>,<span class="number">5</span>), (<span class="number">5</span>,<span class="number">0</span>), (<span class="number">6</span>,<span class="number">3</span>), (<span class="number">5</span>,<span class="number">6</span>)])</span><br></pre></td></tr></table></figure><p>假设我们要为节点（人）添加姓名、年龄、性别属性，同时对于连边（社会联系）添加是否为正式联系的标注属性。对于 <code>igraph</code> 包中的每个 <code>Graph</code> 对象，可以调用其成员变量 <code>vs</code> 和 <code>es</code> ，即节点序列 <code>VertexSeq</code>（Vertice Sequence）和连边序列 <code>EdgeSeq</code>（Edge Sequence），可以将其当作 Python 中的字典（dict）对象使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs</span><br><span class="line">&lt;igraph.VertexSeq <span class="built_in">object</span> at <span class="number">0x1b23b90</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs[<span class="string">&quot;name&quot;</span>] = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Claire&quot;</span>, <span class="string">&quot;Dennis&quot;</span>, <span class="string">&quot;Esther&quot;</span>, <span class="string">&quot;Frank&quot;</span>, <span class="string">&quot;George&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs[<span class="string">&quot;age&quot;</span>] = [<span class="number">25</span>, <span class="number">31</span>, <span class="number">18</span>, <span class="number">47</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">50</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs[<span class="string">&quot;gender&quot;</span>] = [<span class="string">&quot;f&quot;</span>, <span class="string">&quot;m&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;m&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;m&quot;</span>, <span class="string">&quot;m&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.es[<span class="string">&quot;is_formal&quot;</span>] = [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>]</span><br></pre></td></tr></table></figure><p>当你将 <code>vs</code>/<code>es</code> 当作字典使用时，就是将属性值分配给图中的所有节点/连边。当然我们也可以将 <code>vs</code>/<code>es</code> 当作 Python 的列表（list）使用，给出索引值获取特定节点/连边，对于获取到的节点/连边，也可以（像字典一样使用）修改它的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.es[<span class="number">0</span>]</span><br><span class="line">igraph.Edge(&lt;igraph.Graph <span class="built_in">object</span> at <span class="number">0x4c87a0</span>&gt;,<span class="number">0</span>,&#123;<span class="string">&#x27;is_formal&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.es[<span class="number">0</span>].attributes()</span><br><span class="line">&#123;<span class="string">&#x27;is_formal&#x27;</span>: <span class="literal">False</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.es[<span class="number">0</span>][<span class="string">&quot;is_formal&quot;</span>] = <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.es[<span class="number">0</span>]</span><br><span class="line">igraph.Edge(&lt;igraph.Graph <span class="built_in">object</span> at <span class="number">0x4c87a0</span>&gt;,<span class="number">0</span>,&#123;<span class="string">&#x27;is_formal&#x27;</span>: <span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure><p>从示例可以看出，<code>es</code> 对象是边序列，其中的每一个元素都是 <code>Edge</code> 对象，打印出来的值是该边所属的图、边 ID、和属性组成的字典。<code>Edge</code> 对象有一些有用的属性，如：<code>source</code>，展示边的源节点；<code>target</code>，展示边的目标节点；<code>index</code>，获得边 ID；<code>tuple</code>，获得源节点和目标节点组成的元组；以及这里用到的 <code>attributes()</code> ，获得有边的所有属性及值组成的字典。</p><p><code>Graph.es</code> 对象一般是一个图中所有边的集合，索引值 i 一般都会返回 ID 为 i 的边，对 <code>Graph.vs</code> 也同理。但是需要注意，并不是所有的边序列对象都是某个图的所有边的集合，对节点序列对象也是如此，在后文会介绍特例。</p><p>之前提到过，不仅对于节点和边，图对象也可以设置参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g[<span class="string">&quot;date&quot;</span>] = <span class="string">&quot;2009-01-10&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(g[<span class="string">&quot;date&quot;</span>])</span><br><span class="line"><span class="number">2009</span>-01-<span class="number">10</span></span><br></pre></td></tr></table></figure><p>最后，如果需要删除属性，可以使用 Python 关键字 <code>del</code>，像删除字典中键值对一样删除属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs[<span class="number">3</span>][<span class="string">&quot;foo&quot;</span>] = <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs[<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">[<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> g.vs[<span class="string">&quot;foo&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs[<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">25</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;Attribute does not exist&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="图的结构性指标计算">图的结构性指标计算</h2><p><code>igraph</code> 提供许多计算图的结构性指标的方法，本节仅选取部分进行介绍，将继续沿用上一节我们建立的图。</p><p>大多数人能想到的最简单的指标就是节点的度数。节点的度等于与该节点建立连边的节点数，在有向图中度还分入度（指向该节点的连边数）和出度（由该节点发出的连边数），这些指标 <code>igraph</code> 都可以计算，例如要计算度，可以使用 <code>degree()</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.degree()</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>如果要在有向图中计算入度和出度，只需调用时添加 <code>mode</code> 参数，如 <code>g.degree(mode=&quot;in&quot;)</code>，<code>g.degree(mode=&quot;out&quot;)</code>。也可以添加一个或多个节点 ID，以获取特定节点的度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.degree(<span class="number">6</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.degree([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>这样一种填入一个或多个节点 ID 的方式适用于大多数 <code>igraph</code> 中结构性指标的计算方法。除了填入 ID，当然还可以填入 <code>VertexSeq</code> 和 <code>EdgeSeq</code> 实例，下一篇文章会予以介绍。有一些指标相比于使用整个图，使用部分节点和连边计算的结果是没有意义的，这种情况下可能就不支持这样的输入，但是可以对结果进行索引来获取部分结果（如 <code>Graph.evcent()</code> ）</p><p>除了度数，<code>igraph</code> 还可以计算中心性指标，包括节点和边的中介中心性（方法：<code>Graph.betweenness()</code>、<code>Graph.edge_betweenness()</code> ）或者 Google 的 PageRank （<code>Graph.pagerank()</code>）等。这里介绍边中介中心性的计算。边中介中心性是网络中所有最短路径中经过该边的路径的数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.edge_betweenness()</span><br><span class="line">[<span class="number">6.0</span>, <span class="number">6.0</span>, <span class="number">4.0</span>, <span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">3.0</span>. <span class="number">4.0</span>]</span><br></pre></td></tr></table></figure><p>计算得到所有边的中介中心性，然后我们可以综合运用之前的方法，找到那些中介中心性较高的边：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ebs = g.edge_betweenness()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max_eb = <span class="built_in">max</span>(ebs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[g.es[idx].<span class="built_in">tuple</span> <span class="keyword">for</span> idx, eb <span class="keyword">in</span> <span class="built_in">enumerate</span>(ebs) <span class="keyword">if</span> eb == max_eb]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><p>大多数结构性指标计算可以就部分节点/连边得出，即可以用 <code>VertexSeq</code>，<code>EdgeSeq</code>，<code>Vertex</code>，<code>Edge</code> 对象计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs.degree()</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.es.edge_betweenness()</span><br><span class="line">[<span class="number">6.0</span>, <span class="number">6.0</span>, <span class="number">4.0</span>, <span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">3.0</span>. <span class="number">4.0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs[<span class="number">2</span>].degree()</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="使用参数查找特定节点和连边">使用参数查找特定节点和连边</h2><h3 id="选择节点和连边">选择节点和连边</h3><p>假设在某个社会网络中，你需要找出具有最大点度或中介中心度的人，除了使用之前给出的方式结合一些你可能掌握的 Python 方法，<code>igraph</code> 提供了更简单的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs.select(_degree=g.maxdegree())[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">[<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>]</span><br></pre></td></tr></table></figure><p>这种表达乍一看有些奇怪，我们可以一步步拆解来理解。<code>select()</code> 是 <code>VertexSeq</code> 的一个方法，它的唯一目标是通过节点的指标来过滤节点集合，通过添加位置参数或关键字参数可以实现。一般来说位置参数没有显式定义的名称（如<code>_degree</code>），在关键字参数前读取。</p><ul><li><p>如果首个位置参数为 <code>None</code>，会返回一个空序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = g.vs.select(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(seq)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>如果首个位置参数为可调用对象（如函数、绑定方法等），这个对象会逐一被节点序列 <code>vs</code> 中的节点调用。若函数返回结果为 <code>True</code>，当前节点会被包含在结果中，否则被排除在结果之外。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>graph = Graph.Full(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>only_odd_vertices = graph.vs.select(<span class="keyword">lambda</span> vertex: vertex.index % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(only_odd_vertices)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>如果首个位置参数是可迭代的对象（如列表、生成器等），该对象的返回值必须为整数，且这些整数会作为当前节点序列（并不一定是整个图的所有节点）的索引值使用，仅有处于这些索引值位置的节点会进入结果集。返回值中的浮点数、字符串和无效的节点 ID 值会被忽略：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = graph.vs.select([<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(seq)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[v.index <span class="keyword">for</span> v <span class="keyword">in</span> seq]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = seq.select([<span class="number">0</span>, <span class="number">2</span>])         <span class="comment"># filtering an existing vertex set</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[v.index <span class="keyword">for</span> v <span class="keyword">in</span> seq]</span><br><span class="line">[<span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = graph.vs.select([<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="string">&quot;foo&quot;</span>, <span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(seq)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>如果首个位置参数为整数，所有余下的位置参数都应是整数，这些参数被当作索引值使用，处于这些索引值位置的节点会进入结果集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = graph.vs.select(<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(seq)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><p>除了位置参数之外，<code>select()</code> 方法支持一系列关键字参数（具有显式定义的参数名）：</p><table><thead><tr><th>关键字参数</th><th>含义</th></tr></thead><tbody><tr><td><code>name_eq</code></td><td>参数/属性必须等于给出的参数值</td></tr><tr><td><code>name_ne</code></td><td>参数/属性必须不等于给出的参数值</td></tr><tr><td><code>name_lt</code></td><td>参数/属性必须小于给出的参数值</td></tr><tr><td><code>name_le</code></td><td>参数/属性必须小于等于给出的参数值</td></tr><tr><td><code>name_gt</code></td><td>参数/属性必须大于给出的参数值</td></tr><tr><td><code>name_ge</code></td><td>参数/属性必须大于等于给出的参数值</td></tr><tr><td><code>name_in</code></td><td>参数/属性必须在给出的参数值之中，参数值须为序列</td></tr><tr><td><code>name_notin</code></td><td>参数/属性必须不在给出的参数值之中，参数值须为序列</td></tr></tbody></table><p>例如，下面这一行代码能返回 <code>vs</code> 中 <code>age</code> 小于 30 的记录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs.select(age_lt=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>当然，<code>select()</code> 也可以以简略形式调用，下面这行与上面那行等价：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs(age_lt=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><blockquote><p>不能写作 <code>g.vs(age &lt; 30)</code> ，因为参数列表中只有 <code>=</code> 是被允许的。</p></blockquote><p>有时可能会出现已定义属性与结构指标值名相同的情况，如点度（degree）和你定义的 <code>degree</code> 属性，为解决歧义问题，如需将结构指标名用于筛选节点，必须在指标名前加 <code>_</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs(_degree_gt=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>除了度以外，还有一些特殊的结构指标名用于筛选节点：</p><ul><li><p>使用 <code>_source</code> 或 <code>_from</code> 用于边筛选，筛选那些来源节点为特定节点的边，如筛选来源为 ID 为 2 的边：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.es.select(_source=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>_target</code> 或 <code>_to</code> 用于边筛选，筛选那些目标节点为特定节点的边，用法同上。</p></li><li><p><code>_within</code> 参数传入 <code>VertexSeq</code> 或索引值序列（列表或集合），选取包含在给出的节点（索引）序列中的节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.es.select(_within=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.es.select(_within=g.vs[<span class="number">2</span>:<span class="number">5</span>])</span><br></pre></td></tr></table></figure></li><li><p><code>_between</code> 参数传入两个由 <code>VertexSeq</code> 或包含索引值的列表，或 <code>Vertex</code> 对象组成的元组，选取那些从一组的节点发出，指向另一组的节点的边集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>men = g.vs.select(gender=<span class="string">&quot;m&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>women = g.vs.select(gender=<span class="string">&quot;f&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.es.select(_between=(men,women))</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用某些属性寻找单一节点或连边">使用某些属性寻找单一节点或连边</h3><p>有时我们会用许多属性限定在图中寻找某一个特定的节点或连边。如果这样的条件下有多个结果返回，我们可能不关心返回哪一个结果，或者我们预先知道这样的条件下只会返回一个结果，比如我们用 <code>name</code> 属性查找某个姓名为指定值的节点。</p><p><code>VertexSeq</code> 和 <code>EdgeSeq</code> 对象提供 <code>find()</code> 方法供以上场景使用。与 <code>select()</code> 不同的是，<code>find()</code> 仅返回结果集的第一个结果（如果没有结果则报错）。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">claire = g.vs.find(name=<span class="string">&quot;Claire&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(claire)</span><br><span class="line">igraph.Vertex</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>claire.index</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>如果没有这样的结果则会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs.find(name=<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: no such vertex</span><br></pre></td></tr></table></figure><h3 id="使用-name-找节点">使用 <code>name</code> 找节点</h3><p>相比于 ID，节点的名字似乎更容易被记忆。<code>igraph</code> 对 <code>name</code> 属性做了特殊处理，将其设置为“索引”，这样用 <code>name</code> 也可以快速地查找到节点，而且为了让使用更简单，<code>name</code> 可以作为“索引”在所有 ID 可以出现的地方出现，包含列表等情况。</p><p>比如计算某一节点的度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.degree(<span class="string">&quot;Dennis&quot;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs.find(<span class="string">&quot;Dennis&quot;</span>).degree()</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>igraph</code> 在后台维持着 ID 和 <code>name</code> 的对应关系，当图改变时这个对应关系也会对应调整。和 ID 不同，<code>igraph</code> 允许重复的 <code>name</code> ，但是当你在使用 <code>name</code> 寻找某个 <code>name</code> 与其他节点重复的节点时，<code>igraph</code> 只会返回他们之中的一个，如果要寻找其他的节点可能只能用其他办法了。</p><h2 id="图与邻接矩阵">图与邻接矩阵</h2><p>邻接矩阵是表示图的一种方式，在邻接矩阵中，行列均为节点编号，对应的值表明节点之间是否有连边。如矩阵中的第 i 行第 j 列的值表明节点 i 和节点 j 是否有连边。要获取图的邻接矩阵，可以使用 <code>get_adjacency()</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.get_adjacency()</span><br><span class="line">Matrix([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(g.get_adjacency())</span><br><span class="line">[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p>从输出可以看出，ID 为 2 的节点（ [1, 0, 0, 1, 1, 1, 0] ）和 ID 为 0、3、4、5 的节点相连，而和 ID 为 1、6 的节点之间没有连边。</p><h2 id="布局与绘图">布局与绘图</h2><p>之前的介绍中，图是一个相对抽象的数学概念，我们没有将其映射至 2D 或 3D 空间。如果我们想将图可视化，我们首先需要将节点对应到二维或三维空间内。图绘制（Graph Drawing）——图理论的一个分支，尝试运用多种图布局算法解决这个映射问题。<code>igraph</code> 引入了部分布局算法，并且可以结合 Cairo 包（本文开始时安装过）将其绘制为 PDF、PNG、SVG 等形式。</p><h3 id="布局算法">布局算法</h3><p>布局方法是 <code>Graph</code> 对象的成员方法，一般都以 <code>layout_</code> 起头：</p><table><thead><tr><th style="text-align:center">方法全名</th><th>简称</th><th>算法描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>layout_circle</code></td><td><code>circle</code> , <code>circular</code></td><td>将节点放在一个圆环上</td></tr><tr><td style="text-align:center"><code>layout_drl</code></td><td><code>drl</code></td><td>常用于大图，分散递归布局</td></tr><tr><td style="text-align:center"><code>layout_fruchterman_reingold</code></td><td><code>fr</code></td><td>Fruchterman-Reingold 力导向布局</td></tr><tr><td style="text-align:center"><code>layout_fruchterman_reingold_3d</code></td><td><code>fr3d</code> , <code>fr_3d</code></td><td>Fruchterman-Reingold 力导向布局（3D版）</td></tr><tr><td style="text-align:center"><code>layout_kamada_kawai</code></td><td><code>kk</code></td><td>Kamda-Kawai 力导向布局</td></tr><tr><td style="text-align:center"><code>layout_kamada_kawai_3d</code></td><td><code>kk3d</code> , <code>kk_3d</code></td><td>Kamda-Kawai 力导向布局（3D版）</td></tr><tr><td style="text-align:center"><code>layout_lgl</code></td><td><code>large</code> , <code>lgl</code> , <code>large_graph</code></td><td>常用于大图，大图布局</td></tr><tr><td style="text-align:center"><code>layout_random</code></td><td><code>random</code></td><td>将节点完全随机放置</td></tr><tr><td style="text-align:center"><code>layout_random_3d</code></td><td><code>random_3d</code></td><td>将节点完全随机放置在三维空间</td></tr><tr><td style="text-align:center"><code>layout_reingold_tilford</code></td><td><code>rt</code> , <code>tree</code></td><td>Reingold-Tilford 树状布局，对类树状图有用</td></tr><tr><td style="text-align:center"><code>layout_reingold_tilford_circular</code></td><td><code>rt_citcular</code> , <code>tree</code></td><td>极坐标转换后Reingold-Tilford 树状布局，对类树状图有用</td></tr><tr><td style="text-align:center"><code>layout_sphere</code></td><td><code>sphere</code> , <code>spherical</code> , <code>circular_3d</code></td><td>将节点放在球面</td></tr></tbody></table><p>布局方法可以直接被调用，也可以使用通用的 <code>layout()</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>layout = g.layout_kamada_kawai()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>layout = g.layout(<span class="string">&quot;kamada_kawai&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>layout()</code> 方法的首个参数必须为布局算法的简称（如上表），余下的位置参数和关键字参数都为布局算法使用，例如下面两行等价语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>layout = g.layout_reingold_tilford(root=[<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>layout = g.layout(<span class="string">&quot;rt&quot;</span>, [<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>布局方法返回 <code>Layout</code> 对象，这个对象像一个列表组成的列表，每个列表对应着节点在 2D 或 3D 空间中的位置坐标。<code>Layout</code> 对象包含一些有用的方法，可以批量转换、缩放、旋转坐标。当然，其主要的作用还是将数据传递给 <code>plot()</code> 方法，获得 2D 图绘制。</p><h3 id="使用布局绘图">使用布局绘图</h3><p>我们可以用之前的社会网络绘图，采用 Kamada-Kawai 布局：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>layout = g.layout(<span class="string">&quot;kk&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ig.plot(g, layout=layout)</span><br></pre></td></tr></table></figure><p>这将绘制出和下图近似的网络图（实际展现出的样子会随机变化）：</p><p><img src="https://igraph.org/python/tutorial/0.9.7/_images/tutorial_social_network_1.png" alt="Kamada-Kawai 布局社会网络图"></p><p>如果想使用 <code>matplotlib</code> 作为绘图引擎，需要使用 <code>target</code> 参数创建轴：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fig, ax = plt.subplots()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ig.plot(g, layout=layout, target=ax)</span><br></pre></td></tr></table></figure><p>目前还不是很美观，我们可以将人名标注在节点附近，将节点按照性别上色。图中的节点标签默认来源于 <code>label</code> 参数，节点的颜色由 <code>color</code> 标签决定，所以可以调整后重新绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs[<span class="string">&quot;label&quot;</span>] = g.vs[<span class="string">&quot;name&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color_dict = &#123;<span class="string">&quot;m&quot;</span>: <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;f&quot;</span>: <span class="string">&quot;pink&quot;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.vs[<span class="string">&quot;color&quot;</span>] = [color_dict[gender] <span class="keyword">for</span> gender <span class="keyword">in</span> g.vs[<span class="string">&quot;gender&quot;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ig.plot(g, layout=layout, bbox=(<span class="number">300</span>, <span class="number">300</span>), margin=<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># ig.plot(g, layout=layout, bbox=(300, 300), margin=20, target=ax) # matplotlib 版本</span></span><br></pre></td></tr></table></figure><p><img src="https://igraph.org/python/tutorial/0.9.7/_images/tutorial_social_network_2.png" alt="美化 - Kamada-Kawai 布局社会网络图"></p><p>我们重用了之前的布局对象，但是我们也注明了我们需要一个较小的画布（300 × 300 像素）和 20 像素的边距使得标签能够完全展示。</p><p>除了在节点和连边的属性中设置，你当然也可以在 <code>plot()</code> 时传入参数达到相同效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color_dict = &#123;<span class="string">&quot;m&quot;</span>: <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;f&quot;</span>: <span class="string">&quot;pink&quot;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plot(g, layout=layout, vertex_color=[color_dict[gender] <span class="keyword">for</span> gender <span class="keyword">in</span> g.vs[<span class="string">&quot;gender&quot;</span>]])</span><br></pre></td></tr></table></figure><p>如果我们想将节点属性数据和绘图完全分离开来，这是一种推荐的方式。当然，我们也可以完全用一个字典来存储上述布局参数，最后使用 <code>**</code> 操作符将样式参数一并传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>visual_style = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>visual_style[<span class="string">&quot;vertex_size&quot;</span>] = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>visual_style[<span class="string">&quot;vertex_color&quot;</span>] = [color_dict[gender] <span class="keyword">for</span> gender <span class="keyword">in</span> g.vs[<span class="string">&quot;gender&quot;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>visual_style[<span class="string">&quot;vertex_label&quot;</span>] = g.vs[<span class="string">&quot;name&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>visual_style[<span class="string">&quot;edge_width&quot;</span>] = [<span class="number">1</span> + <span class="number">2</span> * <span class="built_in">int</span>(is_formal) <span class="keyword">for</span> is_formal <span class="keyword">in</span> g.es[<span class="string">&quot;is_formal&quot;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>visual_style[<span class="string">&quot;layout&quot;</span>] = layout</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>visual_style[<span class="string">&quot;bbox&quot;</span>] = (<span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>visual_style[<span class="string">&quot;margin&quot;</span>] = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plot(g, **visual_style)</span><br></pre></td></tr></table></figure><p><img src="https://igraph.org/python/tutorial/0.9.7/_images/tutorial_social_network_3.png" alt="美化2 - Kamada-Kawai 布局社会网络图"></p><h3 id="节点和边的绘图布局参数">节点和边的绘图布局参数</h3><p>上一节看到了很多节点和边的布局参数，传入这些参数能够覆盖 <code>igraph</code> 绘图的默认设置参数。实际上，有大量的参数可以用于调整布局：</p><h4 id="节点绘图布局参数">节点绘图布局参数</h4><table><thead><tr><th>参数名</th><th>关键参数</th><th>用处</th></tr></thead><tbody><tr><td><code>color</code></td><td><code>vertex_color</code></td><td>节点的颜色</td></tr><tr><td><code>font</code></td><td><code>vertex_font</code></td><td>节点字体</td></tr><tr><td><code>label</code></td><td><code>vertex_label</code></td><td>节点标签</td></tr><tr><td><code>label_angel</code></td><td><code>vertex_label_angle</code></td><td>节点标签摆放在节点的相对方向角度，例如 0 度时是正右方</td></tr><tr><td><code>label_color</code></td><td><code>vertex_label_color</code></td><td>节点标签的颜色</td></tr><tr><td><code>label_dist</code></td><td><code>vertex_label_dist</code></td><td>节点标签距离节点的距离，与节点大小相关</td></tr><tr><td><code>label_size</code></td><td><code>vertex_label_size</code></td><td>节点标签的字体大小</td></tr><tr><td><code>order</code></td><td><code>vertex_order</code></td><td>绘制节点的顺序；序号较小的节点会被优先绘制</td></tr><tr><td><code>shape</code></td><td><code>vertex_shape</code></td><td>节点的形状；可用形状有：<code>rectangle</code>（正方形）、<code>circle</code>（圆形）、<code>hidden</code>（隐藏）、<code>triangle-up</code>（三角形）、<code>triangle-down</code>（倒三角），可以查看 <code>drawing_shapes</code> 获取更多形状</td></tr><tr><td><code>size</code></td><td><code>vertex_size</code></td><td>节点的大小（单位：像素）</td></tr></tbody></table><h4 id="连边绘图布局参数">连边绘图布局参数</h4><table><thead><tr><th>参数名</th><th>关键参数</th><th>用处</th></tr></thead><tbody><tr><td><code>color</code></td><td><code>edge_color</code></td><td>边的颜色</td></tr><tr><td><code>curved</code></td><td><code>edge_curved</code></td><td>边的曲率；0 代表直边，负数时边向顺时针方向弯曲，正数时边向逆时针方向弯曲，<code>True</code> 视为 0.5，<code>False</code> 视为 0；使用该参数可以让多条边不互相遮挡，可以查看 <code>plot()</code> 的 <code>autocurve</code> 参数</td></tr><tr><td><code>font</code></td><td><code>edge_font</code></td><td>边的字体</td></tr><tr><td><code>arrow_size</code></td><td><code>edge_arrow_size</code></td><td>有向图中，边的箭头的大小（相对于 15 像素）</td></tr><tr><td><code>arrow_width</code></td><td><code>edge_arrow_width</code></td><td>有向图中，边的箭头的宽度（相对于 10 像素）</td></tr><tr><td><code>width</code></td><td><code>edge_width</code></td><td>边的宽度（单位：像素）</td></tr></tbody></table><h4 id="plot-的通用关键字参数"><code>plot()</code> 的通用关键字参数</h4><p>用于 <code>plot()</code> 的关键字参数如下：</p><table><thead><tr><th>关键字参数</th><th>用处</th></tr></thead><tbody><tr><td><code>autocurve</code></td><td>决定绘图时多边是否自动弯曲；10 000 条以下边的情况默认为 <code>True</code>，其余为 <code>False</code></td></tr><tr><td><code>bbox</code></td><td>画布的边界框（Bounding BOX）大小，须为指定宽度和高度的元组；默认为 <code>(600,600)</code></td></tr><tr><td><code>layout</code></td><td>采用的布局。可以是 <code>Layout</code> 实例，包含坐标元组的列表，或者是布局算法的名称；默认为 <code>auto</code>，根据图的大小和连接程度自动决定布局</td></tr><tr><td><code>margin</code></td><td>画布的 上/右/下/左 边距，须为数组或列表；如果填写的元素少于 4 个，其中的元素会被重复使用</td></tr></tbody></table><h3 id="绘图时指定颜色">绘图时指定颜色</h3><p><code>igraph</code> 可以用以下方式指定颜色（用于边、节点、标签参数）</p><h4 id="X11-颜色名">X11 颜色名</h4><p>可以查看维基百科中的 <a href="http://en.wikipedia.org/wiki/X11_color_names">X11颜色名</a> 获得完整列表，或者查看 <code>igraph.drawing.colors.knows_colors</code> 字典的键，在这里不是大小写敏感，所以填入 <code>DarkBlue</code> 与 <code>darkblue</code> 效果相同。</p><h4 id="CSS-样式颜色字符串">CSS 样式颜色字符串</h4><p>可按以下样式形成字符串填入（RGB分别代表红、绿、蓝）</p><ul><li><code>#RRGGBB</code>，六位十六进制，每种颜色从 0 至 255（16 × 16）。如 <code>#0088ff</code> 。</li><li><code>#RGB</code> ，三位十六进制，每种颜色从 0 至 15，如 <code>#08f</code> 。</li><li><code>rgb(R, G, B)</code>，可填入 0 至 255 的十进制整数或百分比。如 <code>rgb(0, 127, 255)</code> 或 <code>rgb(0%, 50%, 100%)</code>。</li></ul><h4 id="RGB-列表">RGB 列表</h4><p>样例：<code>[255, 128, 0]</code>，<code>(255, 128, 0)</code>，<code>&quot;255, 128, 0&quot;</code>。</p><h3 id="保存绘图">保存绘图</h3><p><code>igraph</code> 可以将绘图保存为文件，这样可以用于诸如出版等场景。方法也很简单，只需要将目标文件名作为附加参数附在图对象后面即可。支持的格式由扩展引擎决定，<code>igraph</code> 可以保存 Cairo 支持的所有格式，如 SVG，PDF和 PNG 等。SVG 和 PDF 文件可以被转换为 <code>.ps</code> 和 <code>.eps</code> 格式，PNG 可以被转换为 <code>.tif</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ig.plot(g, <span class="string">&quot;social_network.pdf&quot;</span>, **visual_style)</span><br></pre></td></tr></table></figure><h2 id="igraph-与外部包联动"><code>igraph</code> 与外部包联动</h2><p><code>igraph</code> 提供许多方法从外部读取图和保存图：</p><table><thead><tr><th>格式</th><th>简称</th><th>读取方法</th><th>写入方法</th></tr></thead><tbody><tr><td>邻接列表/LGL</td><td><code>lgl</code></td><td><code>Graph.Read_Lgl()</code></td><td><code>Graph.write_lgl()</code></td></tr><tr><td>邻接矩阵</td><td><code>adajacency</code></td><td><code>Graph.Read_Adjacency()</code></td><td><code>Graph.write_adjacency()</code></td></tr><tr><td>DL</td><td><code>dl</code></td><td><code>Graph.Read_DL()</code></td><td>暂无</td></tr><tr><td>边列表</td><td><code>edgelist</code>，<code>edges</code>，<code>edge</code></td><td><code>Graph.Read_Edgelist()</code></td><td><code>Graph.write_edgelist()</code></td></tr><tr><td>GraphViz</td><td><code>graphviz</code>，<code>dot</code></td><td>暂无</td><td><code>Graph.write_dot()</code></td></tr><tr><td>GML</td><td><code>gml</code></td><td><code>Graph.Read_GML()</code></td><td><code>Graph.write_gml</code></td></tr><tr><td>GraphML</td><td><code>graphml</code></td><td><code>Graph.Read_GraphML()</code></td><td><code>Graph.write_graphml()</code></td></tr><tr><td>Gzipped GraphML</td><td><code>graphmlz</code></td><td><code>Graph.Read_GraphMLz()</code></td><td><code>Graph.write_graphmlz()</code></td></tr><tr><td>LEDA</td><td><code>leda</code></td><td>暂无</td><td><code>Graph.write_leda()</code></td></tr><tr><td>标记边列表/NCOL</td><td><code>ncol</code></td><td><code>Graph.Read_Ncol()</code></td><td><code>Graph.write_ncol()</code></td></tr><tr><td>Pajek 格式</td><td><code>pajek</code>，<code>net</code></td><td><code>Graph.Read_Pajek()</code></td><td><code>Graph.write_pajek()</code></td></tr><tr><td>压制图</td><td><code>pickle</code></td><td><code>Graph.Read_Pickle()</code></td><td><code>Graph.write_pickle()</code></td></tr></tbody></table><p>例如，可以下载著名的 <a href="http://nexus.igraph.org/api/dataset?id=1&amp;format=GraphML">扎卡里空手道俱乐部问题</a> 的 <a href="https://igraph.org/python/tutorial/0.9.7/_downloads/181f2c166825b410a01506e5bd30d7a4/zachary.zip">案例图文件</a>，解压后将其加载至 <code>igraph</code>。因为它是 GraphML 文件，需要使用对应的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>karate = ig.Graph.Read_GraphML(<span class="string">&quot;zachary.graphml&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ig.summary(karate)</span><br><span class="line">IGRAPH UNW- <span class="number">34</span> <span class="number">78</span> -- Zachary<span class="string">&#x27;s karate club network</span></span><br></pre></td></tr></table></figure><p>如果想要将其转换为其他格式，比如 Pajek 支持的格式，可以继续转化保存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>karate.write_pajek(<span class="string">&quot;zachary.net&quot;</span>)</span><br></pre></td></tr></table></figure><p>需要注意，不同的格式均有其限制，比如有的格式不支持存储参数。最佳的存储 <code>igraph</code> 图的格式可能是 GraphML、GML，或者如果你没有参数，NCOL 和边列表也可以（NCOL 支持节点名和边权重）。如果你只是想暂时保存图，之后还要在 <code>igraph</code> 中使用，可以使用 <code>pickle</code> 格式保证获得相同的图表。</p><p>还有两个帮助方法：<code>load()</code> 是一个通用的读取方法，能够尝试从文件类型扩展中自动识别对应类型并读取；<code>Graph.save()</code> 能以文件类型扩展中默认指定格式保存图片，当然也可以用 <code>format</code> 参数填入简称覆盖默认保存类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>karate = load(<span class="string">&quot;zachary.graphml&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>karate.save(<span class="string">&quot;zachary.net&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>karate.save(<span class="string">&quot;zachary.my_extension&quot;</span>, <span class="built_in">format</span>=<span class="string">&quot;gml&quot;</span>)</span><br></pre></td></tr></table></figure><h1>结语</h1><p>本篇仅仅从表面介绍了 <code>igraph</code> 包的一些功能，作者将继续完善完整的操作手册。可以查看 <a href="https://igraph.org/python/doc/api/index.html">API 手册</a> 以获取完整的 <code>igraph</code> 类、函数、方法使用信息。 <code>Graph</code> 类是一个好的开始，如果遇到难懂的部分，可以在 <a href="https://igraph.discourse.group/">讨论组</a> 中寻求帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 工具干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SNA </tag>
            
            <tag> igraph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neo4J 基本教程 —— 一切基于关系，而不受关系限制</title>
      <link href="/posts/aba3bc4e/"/>
      <url>/posts/aba3bc4e/</url>
      
        <content type="html"><![CDATA[<h1>关于 NoSQL</h1><p>Neo4J 属于 NoSQL 非关系型数据库的范畴。</p><h2 id="基本概念理解">基本概念理解</h2><p>SQL 是结构化查询语言（Structured Query Language）的缩写，是一种编程语言，其应用场景一般是关系型数据库。而 NoSQL 是一种概念，全称为“Not Only SQL”，一般代表非关系型数据库，或称文档型数据库。</p><h2 id="为什么要用-NoSQL？">为什么要用 NoSQL？</h2><p>在关系型数据库中，一般一张表可以代表实体或联系，数据和关系都存放在表中，在使用时需要预先定义好表的结构，即预定义的模式。而有时如果根据业务需要，我们需要对实体/关系的属性做调整时，这就必须涉及到对表结构的调整，且新增数据可能还涉及历史数据的补足，显得不够灵活。也就是说，我们的行动可能会被表结构所约束，如果在最初设计数据库时没有考虑完整实体的业务属性，可能会给之后的维护带来麻烦。</p><p>而以 Neo4J 为例的非关系型数据库，在字段约束上就显得没有那么严谨，在 Neo4J 数据库中仅有节点和关系两类需要我们考虑的实例，而对于节点和关系，我们可以为其自由增减属性，在部分应用场景中显得比较灵活。</p><p>举个例子，我们正在开发一个文献信息系统，使用关系型数据库做好了基本的数据库设计，包含了文献的基本信息，而甲方在验收时突然加需求说要在文献详情页展示文献的参考文献和引证文献、相关推荐文献，这可能就需要对数据库进行不小的调整，因为引入了两个一对多关系。（而且如果改进不当，有可能大幅增加数据库存储）</p><p>而如果我们使用的是 Neo4J 数据库，上述操作就很简单了，只需要建立两种关系（Relation）——引用关系和推荐关系即可，不需对节点本身做批量的修改。前台需要获取参考、引证、推荐时，只需查询这两种关系，并返回对应的节点即可</p><p>所以，我使用 NoSQL 的理由可能就归结于——<strong>灵活，不受限于预定义关系模式</strong>。</p><h1>安装使用 Neo4J</h1><h2 id="下载安装">下载安装</h2><p>前往 <a href="https://neo4j.com/download-center/#community">Neo4j Download Center - Neo4j Graph Database Platform</a> 即可下载，选择社区版本（Community Server）即可。</p><p>以 Windows 为例，下载完成后会得到一个 zip 压缩包，将其全部内容解压到某个目录下即可。例如 <code>C:\Program Files\neo4j</code></p><p>对于 Linux 系统，可以选择用 yum 方式下载 Neo4J RPM，可以参考 <a href="https://yum.neo4j.com/">https://yum.neo4j.com/</a> 。使用这种方式安装系统会帮助检查环境和依赖，所以可以跳过下面的两节（2.2 ＆ 2.3）。</p><h2 id="基础环境检查：Java">基础环境检查：Java</h2><p>Neo4J 是基于 Java 的图数据库，运行需要 Java 环境。可以在命令行中输入以下命令以检查是否有该环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="http://download.mariozzj.cn/img/picgo/20210902205954.png" alt="image-20210902205954029"></p><p>如果不存在，可以去 <a href="http://www.java.com">Java 官网</a> 下载，如果使用 <code>neo4j version 3</code> 下载 <code>JDK 8</code> 版本即可；如果使用 <code>neo4j version 4</code> 建议下载 <code>JDK 11</code>。</p><h2 id="基础环境检查：环境变量">基础环境检查：环境变量</h2><p>以 Windows 为例，右击此电脑-属性-高级系统设置- [高级] 选项卡-环境变量处可设置环境变量。</p><h3 id="Java-环境变量">Java 环境变量</h3><ul><li>查看系统变量里是否有名为 <code>JAVA_HOME</code> 的变量，如无则创建。地址为 Java 的安装目录（安装目录下的 /bin 文件夹有 java.exe）。</li><li>在系统变量的 <code>Path</code> 变量中添加 <code>%JAVA_HOME%\bin</code>;<code>%JAVA_HOME%\jre\bin</code>;</li></ul><h3 id="Neo4J-环境变量">Neo4J 环境变量</h3><ul><li>在系统中新建变量，变量名为 <code>Neo4J</code> ，变量值为 Neo4J 的安装目录。</li><li>在系统变量的 <code>Path</code> 变量中添加 <code>%NEO4J_HOME%\bin</code> 。</li></ul><h2 id="命令安装启动">命令安装启动</h2><p>终端键入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j install-service</span><br></pre></td></tr></table></figure><p>即可完成安装。安装完成后，键入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j start</span><br></pre></td></tr></table></figure><p>即可启动 Neo4J 服务。在浏览器中输入终端提示的 url（默认为 <a href="http://localhost:7474">http://localhost:7474</a>）即可进入 Neo4J 的浏览器页面。</p><p>默认的账号密码配置为:</p><ul><li>账号：neo4j</li><li>密码：neo4j</li></ul><p>后续可根据页面提示，进入向导。</p><p><img src="https://download.mariozzj.cn/img/picgo/202110251113311.png" alt="Neo4J 浏览器界面"></p><p>键入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j stop</span><br></pre></td></tr></table></figure><p>可以停止服务。</p><h2 id="数据备份与迁移">数据备份与迁移</h2><p>有时我们可能需要将数据库中的数据进行迁移，如将本地数据库中的数据部署到在线服务器上，就需要进行数据迁移。数据迁移涉及到数据安全等问题，需要使用 <code>neo4j-admin</code> 命令进行，可以在终端输入 <code>neo4j-admin help</code>  查看是否在安装时已配好环境变量，如果无有效响应，可以切换至 <code>%NEO4J_HOME%\bin</code> 下，启动 <code>neo4j-admin</code></p><h3 id="数据备份到文件">数据备份到文件</h3><p>终端键入如下命令即可完成备份。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j-admin dump --database=&lt;database_name&gt; --to=&lt;file_directory&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;database_name&gt;</code> 为 Neo4J 数据库名，<code>&lt;file_directory&gt;</code> 为保存的目标地址。</p><h3 id="文件加载至数据库">文件加载至数据库</h3><p>终端键入如下命令即可将备份文件加载到数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j-admin load --from=&lt;file_directory&gt; --database=&lt;database_name&gt; [--force]</span><br></pre></td></tr></table></figure><p>参数含义同上。这里尾部添加 <code>force</code> 参数可以忽略上载时的错误，强制执行。</p><h1>Cypher 语言</h1><p>在 MySQL 中，我们会使用 SQL 语言对数据库进行操作；而在 Neo4J 中，操作数据库的主语言为 CQL （Cypher Query Language）Cypher 的语法提供了一种类 SQL 方式来匹配图中的节点和关系，即模式。如若具备 SQL 的基础，那么学习起 Cypher 就能变得更加容易。</p><h2 id="操作目标">操作目标</h2><p>使用 Cypher 语言，我们可以操作<strong>节点</strong>、<strong>关系</strong>、<strong>模式</strong>三种对象，这三种对象具有不同的表示形式。</p><h3 id="节点">节点</h3><p>在 Cypher 语言中，节点一般使用小括号表示：<code>()</code></p><p>小括号中填写变量名，如<code>(a)</code>，获取到 a 后可以对 a 进行后续操作。</p><p>我们也可以对节点补充更多细节，一般可以限定其类型和属性值。</p><ul><li>限定节点标签：使用冒号 <code>:</code> ，如 <code>(a:Author)</code>，<code>(a:Author:Person)</code>。</li><li>限定节点属性：使用花括号 <code>&#123;&#125;</code> 补充键值对。如<code>(a:Author &#123;age:21,sex:'男'&#125;)</code>。</li></ul><p>如果动作不关心节点是什么，括号内可留空，仅有括号，表示这是一个节点。</p><h3 id="关系">关系</h3><p>在 Cypher 语言中，关系一般使用中括号表示：<code>[]</code></p><p>关系的括号内如节点一样，可以添加变量名、类型、属性键值对。</p><p>已知，关系需要由两个节点组成（包括自环），用中括号连接两个节点表示关系。</p><ul><li>如果不需要强调关系的方向，节点与关系之间使用一根短横线连接：<code>()-[rel:FRIENDS]-()</code></li><li>如果需要强调关系的方向，则在终止节点前使用尖括号表示箭头：<code>()-[relation:KNOWS]-&gt;()</code></li></ul><p>关系括号内也可以留空。</p><h3 id="模式">模式</h3><p>模式组成的基本要素就是节点和关系的表示方法。在模式中，可以添加逗号，函数等实现更复杂的查询。</p><p>如我们需要查询文献中的互引行为（由两组关系组成），可以使用逗号连接两组关系。（下面的示例用到了 <code>MATCH</code> <code>RETURN</code> 关键词，后面会介绍）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH pattern=(a:Paper)-[:reference]-&gt;(b:Paper),(b:Paper)-[:reference]-&gt;(a:Paper) RETURN p</span><br></pre></td></tr></table></figure><p><img src="https://download.mariozzj.cn/img/picgo/202110251244268.png" alt="示例-互引查询"></p><p>查找模式时，默认会返回模式中涉及的所有对象，在 Neo4J 数据库的浏览器页面查询模式，可以返回节点和关系，并用图的形式可视化。如执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH pattern=(a:Paper)-[r:reference]-&gt;(b) RETURN pattern</span><br></pre></td></tr></table></figure><p>和执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (a:Paper)-[r:reference]-&gt;(b) RETURN a,r,b</span><br></pre></td></tr></table></figure><p>都可以触发 Neo4J 浏览器端的可视化。</p><p><img src="https://download.mariozzj.cn/img/picgo/202110251241640.png" alt="模式可视化"></p><h2 id="操作命令">操作命令</h2><h3 id="MATCH">MATCH</h3><p><code>MATCH</code> 命令起匹配作用，后接节点、关系、模式等。<code>MATCH</code> 需要和其他命令一起使用。</p><h3 id="RETURN">RETURN</h3><p><code>RETURN</code> 命令一般和 <code>MATCH</code> 命令搭配使用，返回之前匹配的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (node:Author) RETURN node //匹配节点</span><br><span class="line">MATCH ()-[r:KNOWS]-&gt;() RETURN r //匹配关系</span><br></pre></td></tr></table></figure><h3 id="CREATE">CREATE</h3><p><code>CREATE</code> 命令可用于创建节点和关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE (node:Author &#123;name:&#x27;John&#x27;&#125;) //创建节点</span><br><span class="line">CREATE (node:Author &#123;name:&#x27;John&#x27;&#125;)-[r:KNOWS]-&gt;(node2:Author &#123;name:&#x27;Lennon&#x27;&#125;) //创建节点和关系</span><br></pre></td></tr></table></figure><h3 id="DELETE">DELETE</h3><p><code>DELETE</code> 命令一般和 <code>MATCH</code> 命令搭配使用，当 <code>MATCH</code> 匹配到符合条件的节点/关系后，可以将其删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (node:Author) DELETE node //删除节点</span><br><span class="line">MATCH (n) DELETE n //删除库中所有节点</span><br></pre></td></tr></table></figure><h3 id="WHERE">WHERE</h3><p>除了表示节点时，限定其标签和属性之外，使用 <code>WHERE</code> 可以以逻辑表达式的形式添加更多匹配条件来过滤结果。<code>WHERE</code> 放在 <code>MATCH</code> 之后，<code>RETURN</code> 之前。</p><p>支持如下比较运算符：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>&lt;；&lt;=</td><td>小于；小于等于</td></tr><tr><td>&gt;；&gt;=</td><td>大于；大于等于</td></tr></tbody></table><p>支持如下逻辑运算符：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>AND</td><td>与</td></tr><tr><td>OR</td><td>或</td></tr><tr><td>NOT</td><td>非</td></tr><tr><td>XOR</td><td>异或</td></tr></tbody></table><p>支持包含关系 IN，IS NULL 判断等。</p><p>举例应用：</p><ol><li><p>用于获取节点时，过滤匹配条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH a=(p:Paper)-[r:reference]-&gt;(q:Paper) WHERE p.year - q.year &gt; 30 AND q.year IN [2000,2001,2002,2003] RETURN a </span><br><span class="line">// 获取所有的引用年限差大于 30 年,且被引文献发表年份在2000-2003年的所有引用模式.</span><br></pre></td></tr></table></figure></li><li><p>用于现有节点的关系建立</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Paper),(q:Paper)</span><br><span class="line">WHERE p.id = &#x27;1001&#x27; AND q.id = &#x27;4001&#x27;</span><br><span class="line">CREATE (p)-[r:reference &#123;value:10&#125;]-&gt;(q)</span><br><span class="line">RETURN r// 建立id为1001,4001的节点之间的关系,并返回该关系</span><br></pre></td></tr></table></figure></li></ol><h3 id="ORDER-BY">ORDER BY</h3><p><code>ORDER BY</code> 可使返回的记录按照指定的字段排序，可以是升序或降序（关键字 <code>ASC</code>/<code>DESC</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (node:Author) RETURN node ORDER BY node.year DESC</span><br></pre></td></tr></table></figure><h3 id="LIMIT-SKIP">LIMIT &amp; SKIP</h3><p><code>LIMIT</code> 可以限制结果返回的条数，<code>SKIP</code> 类似于 Hive SQL 中的 <code>OFFSET</code>，可以控制跳过多少条记录，二者可以组合使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (node:Author) RETURN node SKIP 10 LIMIT 10</span><br></pre></td></tr></table></figure><h3 id="SET">SET</h3><p><code>SET</code> 可用于属性的增加/修改，匹配到符合条件的节点/关系后直接对相应属性更改即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Paper) WHERE p.year &lt; 2000 SET p.century = &#x27;20th&#x27;</span><br></pre></td></tr></table></figure><h3 id="REMOVE">REMOVE</h3><p><code>REMOVE</code> 可用于删除节点/关系的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Paper) WHERE p.year &lt; 2000 REMOVE p.century</span><br></pre></td></tr></table></figure><h3 id="聚合函数">聚合函数</h3><p>Cypher 支持如下聚合函数（含义与 SQL 几乎相同）：</p><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td>COUNT()</td><td>计数</td></tr><tr><td>MAX()</td><td>最大值</td></tr><tr><td>MIN()</td><td>最小值</td></tr><tr><td>SUM()</td><td>求和</td></tr><tr><td>AVG()</td><td>平均值</td></tr></tbody></table><p>举例：计算符合条件的节点数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (n:Author) WHERE n.sex=&#x27;M&#x27; RETURN COUNT(n)</span><br></pre></td></tr></table></figure><h1>高级语言支持</h1><p>Neo4J 是一个数据库，并不是一个可视化工具，虽然它内置的浏览器交互界面非常好用，但是不要低估了 Neo4J 广阔的应用场景。</p><p><code>Python</code> 有 <code>Py2Neo</code> 包可以直接操纵 Neo4J 数据库。详细的使用，可以查看官方文档，<a href="https://py2neo.org/">Py2Neo Handbook</a>，注意版本与本地对应。</p><p><code>Java</code> Spring 框架 也对此有支持，可以查看 <a href="https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/">Spring Data Neo4j</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 工具干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Neo4J </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter——轻量级数据处理分析利器</title>
      <link href="/posts/16cc73c/"/>
      <url>/posts/16cc73c/</url>
      
        <content type="html"><![CDATA[<p>之前初学Python时，老师推荐的是Jetbrains出品的PyCharm作为IDE，对初学者而言感觉PyCharm非常实用，但是随着学习的深入也逐渐能感觉到使用PyCharm的一些缺陷：</p><ol><li>不为项目创建虚拟环境的话，开启项目需要花费较多时间导入包；而创建虚拟环境又需要花时间安装包，且徒占内存。</li><li>脚本文件是一次性全部运行的。虽然可以使用debug功能打断点，但是如果发现一小部分出错还是需要重新全部运行。在模型训练等过程中这种情况可能是致命的。</li><li>仅在科学模式下能实时预览matplotlib等可视化库绘制的图片，比较麻烦。</li><li>代码注释仅有<code>#</code>和<code>'''</code>两种形式，且不能富文本编辑，难以辅助代码扩展和可理解。</li></ol><p>因此，需要一款能够解决上述问题的IDE来加快数据科学学习和应用过程——Jupyter Notebook。</p><h1>Jupyter Notebook</h1><h2 id="Jupyter-Notebook简介">Jupyter Notebook简介</h2><blockquote><p>Jupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。</p><p>——<a href="https://jupyter-notebook.readthedocs.io/">JupyterNotebook文档</a></p></blockquote><p><img src="https://download.mariozzj.cn/img/picgo/202110091020979.jpeg" alt="Jupyter Notebook"></p><p>与PyCharm不同，Jupyter Notebook没有独立的GUI界面和桌面应用程序，是通过浏览器来使用的。Jupyter Notebook既可以安装在本机电脑上通过本地服务器访问，也可以安装在远程服务器上远程使用。</p><p>Jupyter Notebook解析的文件后缀名为<code>.ipynb</code>。该类文件是以json形式书写，但在Jupyter Notebook页面内主要解析为三种类型的块（cell）：代码块（code）、文档块（markdown）、纯文本（Raw NBConvert）。</p><ul><li><p><strong>代码块</strong>包含代码片和输出片。Jupyter Notebook原名IPython Notebook，对Python语言提供支持，书写的Python代码支持代码高亮，支持注释、缩进、Tab补全等基础功能。输出部分，相比于Pycharm等接近cmd只支持文字输出，Jupyter在浏览器中可以渲染出DataFrame表格、可交互的PyeCharts图形、Matplotlib图片等基于html、svg、png等格式的输出。</p><p><img src="https://download.mariozzj.cn/img/picgo/202110091020560.jpeg" alt="Code Cell"></p></li><li><p><strong>文档块</strong>原生支持Markdown语法，可以进行简单的富文本编辑和多媒体插入，同时也支持Latex语法的解析，可以输入数学说明。</p><p><img src="https://download.mariozzj.cn/img/picgo/202110091020806.jpeg" alt="Markdown Cell"></p></li></ul><p>用户可以自由控制插入代码块和文档块，形成交错易于解释说明，同时也可自由控制代码运行顺序，环境启动后运行的代码块中保留的变量不会被删除，可以跨代码块在其他块中使用。</p><p>您可以访问Jupyter官网，在线<a href="https://jupyter.org/try">试用</a>JupyterNotebook。</p><h2 id="安装与启动">安装与启动</h2><p><a href="https://jupyter.org/install.html">Jupyter官网</a>也给出了安装教程，摘录如下：</p><p>如果您已经安装了<code>conda</code>，可以使用conda进行安装。在CMD/Terminal输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge notebook</span><br></pre></td></tr></table></figure><p>或者，如果您想使用<code>pip</code>安装，在安装好pip之后可以在CMD/Terminal输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install notebook</span><br></pre></td></tr></table></figure><p>安装完成后，在CMD/Terminal中输入如下命令即可启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>一般而言，系统会帮您在默认浏览器打开Jupyter Notebook主界面（文件系统），如果没有自动打开，您也可以参照命令行输出在浏览器自行进入。</p><h1>简单使用</h1><h2 id="基础操作">基础操作</h2><h3 id="文件列表页面">文件列表页面</h3><p><img src="https://download.mariozzj.cn/img/picgo/202110091021795.jpeg" alt="Notebook 文件列表"></p><p>在目录页面，用户可以新建空脚本文件进行编辑，也可以新建终端以Shell操作目录（因此，可以进行包的安装）。Jupyter Notebook会对ipynb脚本文件进行渲染，但同时也能够以纯文本打开其他文件。在此页面选中文件可以选择终止运行、复制、重命名、打开、下载、删除等操作。</p><h3 id="脚本页面">脚本页面</h3><p><img src="https://download.mariozzj.cn/img/picgo/202110091021998.jpeg" alt="Jupyter Notebook 脚本页面"></p><p>脚本页面，用户可以点击文件名进行文件的重命名，可以通过菜单栏和功能区进行一些操作。就基础操作而言，用户可以使用功能区的<code>+</code>按钮添加单元格，使用运行按钮执行代码块或渲染文档块，使用下拉栏调整块的类型。</p><p>当然，也可以通过单击代码块旁的运行键来执行代码块。</p><h2 id="基础快捷键">基础快捷键</h2><p>Jupyter Notebook的快捷键较多，这里按单元格的两种模式分别归纳。单元格模式可分为命令模式和编辑模式，主要区别在单元格框线的颜色以及内容是否可编辑，如图。</p><p><img src="https://download.mariozzj.cn/img/picgo/202110091022481.jpeg" alt="Jupyter Notebook 单元格模式"></p><h3 id="命令模式">命令模式</h3><ul><li><p><code>Enter</code>：转为编辑模式</p></li><li><p><code>Shift</code>+<code>Enter</code>：运行本单元格并选中下个单元格</p></li><li><p><code>Ctrl</code>+<code>Enter</code>：运行本单元格</p></li><li><p><code>Alt</code>+<code>Enter</code>：运行本单元格并在下方插入新单元格</p></li><li><p><code>Y</code>：单元格变为代码状态</p></li><li><p><code>M</code>：单元格变为文档状态</p></li><li><p><code>↑</code> / <code>K</code>：选中上方单元格</p></li><li><p><code>↓</code> / <code>J</code>：选中下方单元格</p></li><li><p><code>A</code>：在上方插入新单元格</p></li><li><p><code>B</code>：在下方插入新单元格</p></li><li><p><code>C</code> / <code>X</code> / <code>V</code> ：复制 / 剪切 / 粘贴单元格</p></li><li><p><code>D</code>：删除单元格</p></li><li><p>长按<code>Shift</code>可连续选中</p><p>仅列举部分常用快捷键。如需获取<strong>全部快捷键</strong>，可以在命令模式下按<code>H</code>进入<strong>快捷键帮助</strong>查看所有的快捷键。</p></li></ul><h3 id="编辑模式">编辑模式</h3><ul><li><code>Esc</code>：进入命令模式</li><li><code>Shift</code>+<code>Enter</code>：运行本单元格并选中下个单元格</li><li><code>Ctrl</code>+<code>Enter</code>：运行本单元格</li><li><code>Alt</code>+<code>Enter</code>：运行本单元格并在下方插入新单元格</li><li><code>Tab</code>：缩进 / 代码补全</li><li><code>Shift</code>+<code>Tab</code>：查看工具提示</li><li><code>Ctrl</code>+<code>]</code>：缩进</li><li><code>Ctrl</code>+<code>[</code>：取消缩进</li><li><code>Ctrl</code>+<code>/</code>：注释当前行 / 选中内容</li><li><code>Ctrl</code>+<code>Z</code>：撤销</li><li><code>Ctrl</code>+<code>Y</code>：重做</li><li><code>Ctrl</code>+<code>A</code>：全选</li><li><code>Ctrl</code>+<code>S</code>：保存</li></ul><h3 id="文件操作">文件操作</h3><p><img src="https://download.mariozzj.cn/img/picgo/202110091023354.jpeg" alt="Notebook 脚本下载"></p><p>可以在菜单栏的Files菜单中选择各类文件操作，如新建、打开、保存等。</p><p>您可以给脚本设置检查点，便于版本回溯和重置。</p><p>同时也可以将其下载或导出为其他格式，便于分享、打印、发布等操作。在之后的进阶操作中还会再提及。</p><h1>进阶技巧</h1><h2 id="启动命令参数">启动命令参数</h2><p>在<a href="##%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8">安装与启动</a>中已经介绍过在CMD/Terminal中的启动方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>执行命令后，终端会显示一系列服务器信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> jupyter notebook</span><br><span class="line">[<span class="type">I</span> <span class="number">08</span>:<span class="number">58</span>:<span class="number">24.417</span> <span class="type">NotebookApp</span>] Serving notebooks from local directory: /Users/catherine</span><br><span class="line">[<span class="type">I</span> <span class="number">08</span>:<span class="number">58</span>:<span class="number">24.417</span> <span class="type">NotebookApp</span>] <span class="number">0</span> active kernels</span><br><span class="line">[<span class="type">I</span> <span class="number">08</span>:<span class="number">58</span>:<span class="number">24.417</span> <span class="type">NotebookApp</span>] The Jupyter Notebook is running at: http://localhost:<span class="number">8888</span>/</span><br><span class="line">[<span class="type">I</span> <span class="number">08</span>:<span class="number">58</span>:<span class="number">24.417</span> <span class="type">NotebookApp</span>] Use Control<span class="literal">-C</span> to stop this server and shut down all kernels (twice to skip confirmation).</span><br></pre></td></tr></table></figure><p>出现以上信息表示服务开启成功，浏览器会自动打开窗口进入主界面。</p><h3 id="端口">端口</h3><p>默认情况下一个Jupyter Notebook进程会占用一个端口，默认从8888开始，如果端口被占用则选用邻近端口如8889、8890等。我们可以在启动时指定端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --port &lt;port_number&gt;</span><br></pre></td></tr></table></figure><p>其中<code>&lt;port_number&gt;</code>为指定的端口号。</p><h3 id="文件目录">文件目录</h3><p>一般而言打开Jupyter Notebook会进入默认的文件路径，有的时候我们想要打开不再默认路径下的脚本文件，就可以选择指定目录启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook &lt;dir&gt;</span><br></pre></td></tr></table></figure><p>其中<code>&lt;dir&gt;</code>为需要打开的目录，可以是相对路径也可以是绝对路径。</p><p>例如，在Windows下，我们可以在文件资源管理器的地址栏输入cmd来快速启动命令行，随后仅需键入<code>jupyter notebook ./</code>即可在Jupyter Notebook中打开当前目录。</p><p><img src="https://download.mariozzj.cn/img/picgo/202110091024858.gif" alt="启动操作"></p><p>或者，如果需要直接更改默认文件目录，只需要进行配置文件的修改。方法如下：</p><ol><li><p>首先，在命令行输入命令得到jupyter notebook的安装地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jupyter notebook --generate-config</span><br><span class="line"></span><br><span class="line">Overwrite C:\Users\PM\.jupyter\jupyter_notebook_config.py with default config? [y/N]y</span><br><span class="line">Writing default config to: C:\Users\PM\.jupyter\jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p>可以看到返回中给出了jupyter notebook的安装地址，配置文件在此目录下。</p></li><li><p>前往该目录，使用vim等文本编辑方法编辑目录下的<code>jupyter_notebook_config.py</code>文件，找到如下代码段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## The directory to use for notebooks and kernels.</span></span><br><span class="line"><span class="comment">#c.NotebookApp.notebook_dir = &#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>将第二行内容取消注释，并将引号内更改为您需要指定的工作空间地址即可。</p><p>随后重新启动Jupyter Notebook即可在指定空间打开。</p></li></ol><h2 id="主题更换方法">主题更换方法</h2><h3 id="基于Jupyterthemes">基于Jupyterthemes</h3><p>Jupyter Notebook默认主题为浅色主题，虽然文字显示清晰，但长时间使用可能对眼睛刺激较大。我们可以借用Jupyterthemes插件来为Notebook更换合适的主题。</p><p>首先在CMD/Terminal输入如下命令安装Jupyterthemes插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyterthemes</span><br></pre></td></tr></table></figure><p>安装完成后即可使用。该库在使用时仅取两首字母<code>jt</code>为命令。完整的命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jt  [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT]</span><br><span class="line">    [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-dfs DFFONTSIZE]</span><br><span class="line">    [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-vim]</span><br><span class="line">    [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-altp] [-altmd] [-altout]</span><br><span class="line">    [-P] [-T] [-N] [-r] [-dfonts]</span><br></pre></td></tr></table></figure><p>例如，使用如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -t monokai -ofs 10 -nfs 13 -tfs 13 -fs 12 -T -N -lineh 140</span><br></pre></td></tr></table></figure><p>表明使用monokai主题，输出字体大小10，notebook字体大小13，文档块字体大小13，代码字体大小12，展示工具栏，展示文档名和logo，行高140。</p><p>完整的参数解释见<a href="https://github.com/dunovank/jupyter-themes">jupyter-theme</a>官方仓库。</p><p>使用<code>jt -l</code>命令可以查看目前安装的主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ jt -l</span><br><span class="line"></span><br><span class="line">Available Themes:</span><br><span class="line">   chesterish</span><br><span class="line">   grade3</span><br><span class="line">   gruvboxd</span><br><span class="line">   gruvboxl</span><br><span class="line">   monokai</span><br><span class="line">   oceans16</span><br><span class="line">   onedork</span><br><span class="line">   solarizedd</span><br><span class="line">   solarizedl</span><br></pre></td></tr></table></figure><p><img src="https://download.mariozzj.cn/img/picgo/202110091024596.jpeg" alt="主题展示"></p><p>上图展示了部分主题样式基本情况，可根据喜好自行更换主题。</p><p>使用<code>jt -r</code>命令则可以重置主题。</p><h3 id="基于Stylish">基于Stylish</h3><p>因为Jupyter Notebook是在浏览器呈现，那么任意形式的更换样式表就可以实现对主题的修改。例如较为著名的Stylish插件的社区中就有很多开发者分享了自己定制的Jupyter Notebook主题，这些主题的呈现效果整体上优于jupyterthemes。</p><p><a href="https://userstyles.org/">Stylish官网</a></p><p><a href="https://chrome.google.com/webstore/detail/stylish-custom-themes-for/fjnbnpbmkenffdnngjfgmeleoegfcffe">Stylish-Chrome插件下载</a></p><p>而且，如果您熟练掌握CSS语法，也可以自行基于Stylish定制合适的Jupyter Notebook主题。</p><p><img src="https://download.mariozzj.cn/img/picgo/202110091024781.jpeg" alt="Stylish 暗黑主题效果"></p><h2 id="魔法命令">魔法命令</h2><p>魔法命令在代码块中执行，但是不属于Python语言的代码。使用魔法命令可以在执行代码的同时执行附加效果。</p><h3 id="执行Shell命令">执行Shell命令</h3><p>执行Shell命令并不是魔法命令的一部分，但是功能类似。</p><p>在代码块中键入<code>!</code>+shell命令即可在当前目录执行。</p><p>典型的应用场景例如，当我们需要使用某个包但是Jupyter Notebook所用环境中并没有此包，那么就可以利用此特性，在Notebook内完成包的安装。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install selenium</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">Collecting selenium</span><br><span class="line">  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/80/d6/4294f0b4bce4de0abf13e17190289f9d0613b0a44e5dd6a7f5ca98459853/selenium-3.141.0-py2.py3-none-any.whl (904 kB)</span><br><span class="line">     |████████████████████████████████| 904 kB 1.2 MB/s eta 0:00:01</span><br><span class="line">Requirement already satisfied: urllib3 in /root/anaconda3/lib/python3.8/site-packages (from selenium) (1.25.9)</span><br><span class="line">Installing collected packages: selenium</span><br><span class="line">Successfully installed selenium-3.141.0</span><br></pre></td></tr></table></figure><p>或者，我们共享脚本给他人运行时，需要其下载一些文件，就可以使用wget命令来下载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!wget https://tianchi-competition.oss-cn-hangzhou.aliyuncs.com/<span class="number">531810</span>/test_a.csv.<span class="built_in">zip</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--2021-01-08 21:51:25--  https://tianchi-competition.oss-cn-hangzhou.aliyuncs.com/531810/test_a.csv.zip</span><br><span class="line">Resolving tianchi-competition.oss-cn-hangzhou.aliyuncs.com (tianchi-competition.oss-cn-hangzhou.aliyuncs.com)... 118.31.232.194</span><br><span class="line">Connecting to tianchi-competition.oss-cn-hangzhou.aliyuncs.com (tianchi-competition.oss-cn-hangzhou.aliyuncs.com)|118.31.232.194|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 61986708 (59M) [application/zip]</span><br><span class="line">Saving to: ‘test_a.csv.zip’</span><br><span class="line"></span><br><span class="line">100%[======================================&gt;] 61,986,708  14.6MB/s   in 4.0s   </span><br><span class="line"></span><br><span class="line">2021-01-08 21:51:30 (14.9 MB/s) - ‘test_a.csv.zip’ saved [61986708/619867</span><br></pre></td></tr></table></figure><h3 id="常用魔法命令">常用魔法命令</h3><h4 id="run">%run</h4><figure class="highlight plaintext"><figcaption><span>command</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%run 脚本文件地址</span><br></pre></td></tr></table></figure><p>可以在接下来的代码块中运行指定的脚本文件。</p><h4 id="time系列">%time系列</h4><figure class="highlight plaintext"><figcaption><span>command</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%time &#123;一行代码&#125;</span><br><span class="line">%%time </span><br><span class="line">&#123;代码块剩余内容&#125;</span><br><span class="line"></span><br><span class="line">%timeit &#123;一行代码&#125;</span><br><span class="line">%%timeit</span><br><span class="line">&#123;代码块剩余内容&#125;</span><br></pre></td></tr></table></figure><p>使用%time和%%time可以计算一行/一个单元格内的代码执行一次所需的时间。这在模型训练和大文件读取时是很实用的，有助于使用者把握时间和环境性能。</p><p>而%timeit和%%timeit会将指定代码内容执行很多次，最后计算出平均运行所需时间，一般用于算法的评估。</p><h4 id="whos">%whos</h4><p>该命令可以查看本脚本中仍在占用内存的变量的类型和值等情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">9</span></span><br><span class="line">i = <span class="number">10</span></span><br><span class="line">s = <span class="string">&quot;This is a String&quot;</span></span><br><span class="line"></span><br><span class="line">%whos</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Variable   Type         Data/Info</span><br><span class="line">---------------------------------</span><br><span class="line">i          int          10</span><br><span class="line">j          int          9</span><br><span class="line">np         module       &lt;module &#x27;numpy&#x27; from &#x27;/ro&lt;...&gt;kages/numpy/__init__.py&#x27;&gt;</span><br><span class="line">pd         module       &lt;module &#x27;pandas&#x27; from &#x27;/r&lt;...&gt;ages/pandas/__init__.py&#x27;&gt;</span><br><span class="line">s          str          This is a String</span><br></pre></td></tr></table></figure><h4 id="del-reset">%del %reset</h4><p>使用<code>%del</code>可以删除某个变量；使用<code>%reset</code>可以清除所有变量。</p><h4 id="load">%load</h4><p>使用<code>%load</code>可以加载脚本文件内容并填充到代码块中。值得一提的是%load后不仅可以接本地计算机上的绝对地址和相对地址，还可以接其他服务器的地址，例如使用%load获取某网页的原代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%load http://crafts.mariozzj.cn/</span><br></pre></td></tr></table></figure><h4 id="matplotlib-inline">%matplotlib inline</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot(np.arange(<span class="number">20</span>))</span><br></pre></td></tr></table></figure><p>在使用matplotlib绘图之前写上这样一行魔法命令可以让绘制出的图片直接显示在输出区域。</p><h2 id="导出">导出</h2><p>Jupyter Notebook的代码块和文档块可以以合适的形式导出，导出的格式包括HTML、LaTeX、Markdown、PDF等。</p><p>导出的Markdown中，普通文档块成为Markdown文档，而代码块成为Markdown的代码块，输出部分也成为代码块（输出的图片、表格等不在代码块内，但是仍然会有效保存）。</p><p>导出的PDF是经由LaTeX转化的，最大限度地保留了原始脚本的呈现效果，在代码块和输出区旁会显示In/Out+编号，调整适配到合适的纸张大小。需要注意的是在Jupyter Notebook中直接导出PDF，不支持显示中文，但是也有可以导出含中文PDF的方法。</p><ol><li><p>经由md导出PDF</p><p>在Jupyter Notebook中以markdown格式导出文件后，使用Typora等markdown文本编辑器再对格式进行转换，可以生成PDF以供打印或导出。由于转换为PDF的过程是在编辑器中进行的，所以最终格式是由编辑器决定的，而且不会保留IN/OUT标注等信息。</p></li><li><p>经由LaTeX导出PDF</p><p>在Jupyter Notebook中可以以LaTeX格式导出，随后可以用LaTeX编辑器进行转换，或者采取以下步骤以使转换的PDF支持显示中文：</p><ol><li><p>安装MiKTeX。<a href="https://miktex.org/download">下载链接</a></p></li><li><p>生成LaTeX文件，可以在CMD/Terminal中进入脚本文件所在目录，输入<code>jupyter nbconvert --to latex 文件名.ipynb</code>，等待后生成文件名.tex文件。</p></li><li><p>使用文本编辑器打开文件名.tex文件，在<code>\documentclass&#123;article&#125;</code>后或<code>\documentclass[11pt]&#123;article&#125;</code>后或<code>\documentclass[11pt]&#123;ctexart&#125;</code>后插入以下两行语句，保存。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;fontspec, xunicode, xltxtra&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="keyword">\setmainfont</span>&#123;Microsoft YaHei&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>再在CMD/Terminal中输入<code>xelatex 文件名.tex</code>即可完成转化，生成的文件名.pdf在同目录下。</p><p><img src="https://download.mariozzj.cn/img/picgo/202110091025604.gif" alt="转换操作"></p></li></ol><h1>升级体验</h1><p>Jupyter Notebook 已经展现出了它在数据分析与处理方面的便捷性，但是使用下来还是有一些体验可以优化，例如：</p><ul><li>相比于传统 IDE，文件目录和脚本操作页面是分开的，如果需要切换文件可能比较麻烦</li><li>Notebook 需要先单独在终端启动，才具有查看 <code>.ipynb</code> 文件的能力，不能直接双击打开</li></ul><p>这里提供两个能够缓解上述使用痛点的工具，因为只是升级体验，这两个工具的基本使用和 Notebook 类似，就不再赘述。</p><h2 id="JupyterLab">JupyterLab</h2><p>Jupyter Lab 和 Jupyter Notebook 一样同属于 Jupyter Project，二者在使用上几乎一致，个人认为 Jupyter Lab 是在 Notebook 基础上进行了升级。</p><h3 id="安装与启动-2">安装与启动</h3><p><a href="https://jupyter.org/install.html">Jupyter官网</a> 也给出了安装教程，摘录如下：</p><p>如果您已经安装了<code>conda</code>，可以使用conda进行安装。在 CMD/Terminal 输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge jupyterlab</span><br></pre></td></tr></table></figure><p>或者，如果您想使用<code>pip</code>安装，在安装好pip之后可以在 CMD/Terminal 输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyterlab</span><br></pre></td></tr></table></figure><p>安装完成后，在 CMD/Terminal 中输入如下命令即可启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter-lab</span><br></pre></td></tr></table></figure><p>一般而言，系统会帮您在默认浏览器打开 Jupyter Lab 主界面（文件系统），如果没有自动打开，您也可以参照命令行输出在浏览器自行进入。</p><h3 id="界面展示">界面展示</h3><p>Lab 最主要变化在于在页面左侧加入了文件目录，打开的标签页以内嵌标签页而不是浏览器标签页展示。</p><p><img src="https://download.mariozzj.cn/img/picgo/202110091104518.png" alt="Jupyterlab 主界面"></p><p>对 <code>.ipynb</code> 文件的操作，Lab 和 Notebook 完全相同，因此切换成本很低！</p><p>同时，Jupyter Lab 支持渲染 csv 等结构化数据为<strong>表格形式</strong>，对纯文本文件也可以直接编辑。</p><p><img src="https://download.mariozzj.cn/img/picgo/202110091106880.png" alt="Jupyter Lab 表格渲染"></p><h2 id="VS-Code">VS Code</h2><p>VS Code 是一款强大轻量级 IDE，支持丰富的语言拓展，同时还有多种强力插件。</p><h3 id="安装与启动-3">安装与启动</h3><p>如果没有安装 VS Code，可以前往官方页面下载安装： <a href="https://code.visualstudio.com/Download">Download Visual Studio Code - Mac, Linux, Windows</a></p><p>如果已安装 VS Code，但是没有安装 Python，可以在扩展页面安装：</p><p><img src="https://download.mariozzj.cn/img/picgo/202110091151070.png" alt="VSC安装扩展-Python"></p><p>VS Code 安装 Jupyter 扩展后，就可以支持渲染 <code>.ipynb</code> 文件了，在扩展页面安装即可：</p><p><img src="https://download.mariozzj.cn/img/picgo/202110091154620.png" alt="VSC安装扩展-Jupyter"></p><h3 id="界面展示-2">界面展示</h3><p>VS Code 对 <code>.ipynb</code> 脚本的页面操作也很类似，同时也支持文件树、版本控制等，相对而言功能更加强大。</p><p>VS Code 相对于 Notebook 的提升在于：<strong>增加了文件目录</strong>，同时能够在文件夹中<strong>直接双击</strong> <code>.ipynb</code> <strong>文件打开预览</strong>，不需要启动服务就可以渲染查看。</p><p><img src="https://download.mariozzj.cn/img/picgo/202110091156617.png" alt="VSCode 主界面"></p>]]></content>
      
      
      <categories>
          
          <category> 工具干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jupyter </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Hexo 搭建属于自己的博客</title>
      <link href="/posts/569080df/"/>
      <url>/posts/569080df/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://blog.mariozzj.cn/posts/569080df/">https://blog.mariozzj.cn/posts/569080df/</a></p></blockquote><h1>前言</h1><h2 id="为什么要建博客">为什么要建博客</h2><p>其实我很早就有了建博客的想法，当时刚学会开发简单的 Web 应用，在网上浏览时发现很多人建议建一个博客练手，便想着要去跟风去写。后来，随着个人知识面的拓展和深入，发现有太多的知识和经验值得沉淀和交流，且<strong>很多复杂性的知识是“一言难尽”的，可能需要成百上千字的描述，辅之以图片视频等媒体</strong>。</p><p>另外，根据“学习金字塔”理论（Edgar Dale，1946），<strong>对知识进行演示、实践和传授能够显著提升学习保持率</strong>，而沉淀为博客或视频正是这样一种形式，我认为一方面可以让无形的知识转为有形的博客，便于之后复习和追溯，另一方面通过沉淀转化可以提高我对知识的记忆和掌握水平。</p><h2 id="建设原理">建设原理</h2><p>既然是内容平台，博客自然是重内容，轻形式，主要重心点放在内容上，仅保留少量的交流功能即可。</p><p>这里我使用 <a href="https://hexo.io/">Hexo</a> 框架搭建博客，该框架基于 <a href="https://nodejs.org/zh-cn/">Node.js</a> ，使用者不需要掌握 node 原理，Hexo 会根据配置项中预设好的模板自动将内容转换为静态页面。</p><p>Hexo 提供了多种形式的主题：<a href="https://hexo.io/themes/">Themes | Hexo</a>，这里我选用的是 <a href="https://butterfly.js.org/">Butterfly</a>。该主题较为贴近我对博客美观性的要求，且原生支持一系列配置项和插件，能满足我的需要。</p><p>虽然我有自己的服务器，但是为了提高其可用性，我还是使用了可以白嫖的 <a href="https://pages.github.com/">GitHub Pages</a> 服务，将 Hexo 生成的静态页面部署上去，从而可以让大家访问。对于评论、说说等功能插件还用到了 <a href="https://artitalk.js.org/">Artitalk</a>、<a href="https://waline.js.org/">Waline</a>、<a href="https://vercel.com/">Vercel</a> 和 <a href="https://leancloud.app/">LeanCloud 国际版</a>，有兴趣可自行了解，本文不赘述。</p><h1>本地建设</h1><h2 id="基础环境安装">基础环境安装</h2><h3 id="安装-Node-js">安装 Node.js</h3><p>使用我的方法建设博客，最核心的框架是 Hexo，其基于 Node.js 环境。如果没有 Node 环境需要自行安装，在 <a href="https://nodejs.org/zh-cn/download/">Node.js 官方下载页面</a> 根据操作系统下载即可，具体操作可以参考 <a href="https://www.cnblogs.com/jianguo221/p/11487532.html">windows安装npm教程–nodejs - 遥望那月 - 博客园 (cnblogs.com)</a>。</p><p>这里为和我使用的一些插件兼容，我使用的是 <code>12.18.0</code> 版本。该版本自带 npm。安装完成后在终端运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm  -v</span><br></pre></td></tr></table></figure><p>如果正常响应对应版本号，则说明安装及环境变量配置成功。</p><h3 id="安装-Hexo">安装 Hexo</h3><p>使用 npm（node 的包管理器，可以类比 python 的 pip）可以直接安装 Hexo。在终端输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><p>即可安装。终端运行 <code>hexo -v</code> 检查是否安装正常。</p><p>安装后就可以开始配置了，首先，选择一个本地文件夹作为博客的目录，终端切换到该目录下，运行如下命令初始化该目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init .</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>成功运行后，即可使用 hexo 的命令对该目录进行操作了。默认情况下，hexo 使用 landscape 主题，运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>即可从本地运行博客服务器。浏览器打开终端提示的页面（默认为 <code>https://localhost:4000/</code>），即可查看。</p><p><img src="https://download.mariozzj.cn/img/picgo/20210923150624.png" alt="Hexo-landscape demo"></p><p>默认页面为内置的 <code>hello-world.md</code> 文档。至此我们已经完成了 Hexo 的安装，如要了解更多配置项可参考<a href="https://hexo.io/docs/configuration">Configuration | Hexo</a>，要了解更多 Hexo 命令可参考 <a href="https://hexo.io/docs/commands">Commands | Hexo</a>。</p><h2 id="主题配置：以-Butterfly-为例">主题配置：以 Butterfly 为例</h2><p>大部分人可能都会嫌默认主题 landscape 丑，所以可以进入 Hexo 的主题页面：<a href="https://hexo.io/themes/">Themes | Hexo</a> 挑选符合自己需求的主题进行进一步配置。这里我选用了 Butterfly。作者 <a href="https://github.com/jerryc127">jerryc127 (Jerry Wong)</a> 在主题页面给出了详尽的文档，参见： <a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a>。</p><p>实际上，大部分的操作都只需要理解 <code>_config.yml</code> 里面的配置项，不需要掌握任何的代码原理。按照作者文档给出的步骤一步步按需进行修改即可，对于非必要参数也可以选择不配置。</p><p>作者建议大多数更改都在主题配置文档 <code>_config_butterfly.yml</code> 中进行，但是有一些插件只会识别 <code>_config.yml</code> 中的配置，建议自行做好备份。</p><ul><li><a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始 | Butterfly</a></li><li><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></li><li><a href="https://butterfly.js.org/posts/4aa8abbe/">Butterfly 安裝文檔(三) 主題配置-1 | Butterfly</a></li><li><a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安裝文檔(四) 主題配置-2 | Butterfly</a></li></ul><p>完成这几篇文档里面的配置之后，就可以正常使用博客了！建议牢记以下 hexo 命令：</p><ul><li><code>hexo clean</code> —— 清空之前已生成的全部静态文件</li><li><code>hexo generate</code> —— 根据配置生成新的静态文件，<code>.md</code> 文档会在这一步自动解析生成静态页面。</li><li><code>hexo server</code> —— 在本地服务器启动 hexo 服务。</li></ul><p>关于 Butterfly 的进阶教程查看：<a href="https://butterfly.js.org/posts/4073eda/">Butterfly 安裝文檔(六) 進階教程 | Butterfly</a></p><p>如在 Butterfly 配置项中存在疑问，可查看：<a href="https://butterfly.js.org/posts/98d20436/">Butterfly 安裝文檔(五) 主題問答 | Butterfly</a></p><h2 id="推荐插件">推荐插件</h2><h3 id="评论系统：Waline">评论系统：Waline</h3><p>在 Butterfly 文档 <a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安裝文檔(四) 主題配置-2 | Butterfly</a> 中作者介绍了很多评论系统，这里我使用过一部分，最后决定使用的是 Waline。我这里也为使用过的系统写一些评价：</p><ul><li>Disquejs：要翻墙</li><li>livere（来必力）：韩国的，这个一开始吸引到我是因为他可以用国内常见社交平台登录，这样有人评论我也可以推理一下是谁，但是后面发现他会往我的页面里面插乱七八糟的广告（是的也有你们想象的那种），有时登录体验也很差，就放弃了。</li><li>Gitalk：这个用的人蛮多，原理是基于 Github 的 Issue，但是考虑到我的读者不一定都有 Github 账号，且有时候 Github 会被墙，就放弃了。</li><li>Valine：衍生为 Waline 了</li><li>Waline：虽然不支持第三方登录，但是注册只要随便填信息就行，还不用验证，也可以不留信息评论，这样也很方便交流。另外，结合 Leancloud 我可以对评论设置邮箱推送，这样有了新评论我也能第一时间看到，很方便，在 Leancloud 也可以维护掉不友好的评论，完全满足我的需求。</li></ul><p>这里 Butterfly 作者文档写的不是很详细，我补充说明一些。简单来说，首先，在主题配置文件中寻找 <code>comments</code> 配置项，修改为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Waline</span> <span class="comment"># 这里启用 Waline，注意大小写</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># 双评论系统展示评论系统名</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">true</span> <span class="comment"># 懒加载，用户滚动到评论处时才加载评论</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># Display comment count in top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in Home Page</span></span><br></pre></td></tr></table></figure><p>然后按照 Waline 的说明文档：<a href="https://waline.js.org/guide/get-started.html">快速上手 | Waline</a>，完成 LeanCloud 设置 和 Vercel 部署两步，复制下来 Vercel 提供的 URL。最后在主题配置文件末尾增加以下配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">serverURL:</span>  <span class="comment"># 这里填写 Vercel 提供的 URL</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style https://zh-tw.gravatar.com/site/implement/images/#default-image</span></span><br><span class="line">  <span class="attr">avatarCDN:</span> <span class="comment"># Gravatar CDN baseURL</span></span><br><span class="line">  <span class="attr">bg:</span> <span class="comment"># waline background</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><p>即可启用。另外特别推荐 Waline 的评论通知功能，参照 <a href="https://waline.js.org/guide/server/notification.html#%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5">评论通知 | Waline</a> ，在 Vercel 完成参数（<code>SMTP_SERVICE</code>、<code>SMTP_USER</code>、<code>SMTP_PASS</code>、<code>SMTP_NAME</code>、<code>SMTP_URL</code>、<code>AUTHOR_EMAIL</code>）的配置就可以了。这里我使用 Outlook365 的邮箱配置成功。这个页面还提供了微信通知和 QQ 通知，但是我测试了下提供服务的三方不是很稳定，且会影响到邮件的正常发送，所以我没有启用。</p><h3 id="说说系统：Artitalk">说说系统：Artitalk</h3><p>这个插件在 Butterfly 进阶教程文档：<a href="https://butterfly.js.org/posts/4073eda/#Artitalk">Butterfly 安裝文檔(六) 進階教程 | Butterfly</a> 有提及。</p><p>说说系统更像是一个只属于自己的留言板，我可以在上面发表一些想法，但是设置好权限之后只有自己能发，别人不能回复。</p><p><img src="https://download.mariozzj.cn/img/picgo/20210923154050.png" alt="Artitalk 在页面中的详情"></p><h3 id="豆瓣爬虫：hexo-douban">豆瓣爬虫：hexo-douban</h3><p>这个插件在 Butterfly 进阶教程文档中有提及：<a href="https://butterfly.js.org/posts/4073eda/#%E9%9B%BB%E5%BD%B1">Butterfly 安裝文檔(六) 進階教程 | Butterfly</a></p><p>这个插件可以在每次生成静态页面之前，运行一个豆瓣爬虫，爬取你指定的豆瓣账户的电影、书籍、游戏记录，并生成静态页面。这个插件已经很久没有维护，所以需要降级到 node <code>v12.18.0</code> 版本才可以正常使用。</p><p>每次运行 <code>hexo douban</code> 即可运行爬虫并生成静态页面。</p><p><img src="https://download.mariozzj.cn/img/picgo/20210923154308.png" alt="豆瓣列表在页面中的详情"></p><h1>在线发布</h1><h2 id="配置-Github-仓库">配置 Github 仓库</h2><p>在 Github 上创建好仓库，并在本地设置好博客目录，准备发布。</p><p>在 Github 仓库的设置页面选择 Pages 选项卡即可对页面进行配置。一般来说，如果仓库名称为 {用户名}.github.io 会自动完成配置，对应的页面部署域名为 <code>https://&#123;用户名&#125;.github.io</code>。这里我用了自己的域名，我在服务商那边将域名解析到我的 Github 页面（<code>https://mariozzj.github.io</code>），再在这里设置，系统就会自动在目录处生成一个 <code>CNAME</code> 文件，之后可以使用原域名直接访问。</p><p><img src="https://download.mariozzj.cn/img/picgo/20210923161436.png" alt="Github Pages 设置页面"></p><h2 id="方法一：使用-Hexo-部署">方法一：使用 Hexo 部署</h2><p>Hexo 官方文档给出了一种一步部署的方法：<a href="https://hexo.io/docs/one-command-deployment">One-Command Deployment | Hexo</a></p><p>首先需要安装 <code>hexo-deployer-git</code> ，在终端运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>再在 <code>_config.yml</code> 中配置好自己的 git 仓库相关设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span> <span class="comment"># Git 仓库链接</span></span><br><span class="line">  <span class="attr">branch:</span> [<span class="string">branch</span>] <span class="comment"># 分支</span></span><br><span class="line">  <span class="attr">message:</span> [<span class="string">message</span>] <span class="comment"># git commit 信息。如Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>随后，每次完成页面时，运行 <code>hexo clean</code> 之后直接运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>即可完成一系列上传操作。</p><h2 id="方法二：使用-Github-Action-部署（推荐）">方法二：使用 Github Action 部署（推荐）</h2><p>我更推荐这一种，因为我对博客的修改实际上是对原文档和配置文件的修改。如果使用 <code>hexo deploy</code>，那么在 Github 上看到的 commit 记录都是对静态页面 <code>HTML</code> 的修改，实际没有参考价值（当然，也可以对源单独设一个分支，但是感觉比较麻烦）</p><p>Github Action 配置后，可以根据行动（如<code>push</code>）自动执行持续集成、持续部署操作（CI/CD），Github 会在云端服务器执行配置好的脚本。这里就是 Github Action 替我们执行 <code>hexo clean</code>、<code>hexo generate</code>、<code>git commit</code>、<code>git push</code>等操作，我们只需把代码推送到源文件分支即可。</p><h3 id="配置-Github-Secrets">配置 Github Secrets</h3><p>不是任何一台云服务器都可以直接向我们的仓库推送代码，需要“登录验证”。这里我们需要生成 Access Token，让 Github Action “登录”并推送到仓库以部署网页。</p><p>登录 Github，进入个人账户的 <a href="https://github.com/settings/tokens">Settings - Developer Settings - Personal Access Tokens</a>，点击 <code>Generate new token</code> 生成新的 token，注意权限配置添加读写相关权限，将生成的 token 复制下来。</p><p><img src="https://download.mariozzj.cn/img/picgo/20210923172557.png" alt="Access Token 生成页面"></p><p>随后，进入项目仓库的 <a href="https://github.com/#username/#reponame/settings/secrets/actions">Settings - Secrets - Actions</a>，点击 <code>new repository secret</code> 添加以下两个参数：</p><ul><li><code>GH_TOKEN</code>：填写上一步生成的 token</li><li><code>GIT_EMAIL</code>：填写你的用户对应 git 使用的电子邮箱</li></ul><h3 id="配置工作流（workflow）">配置工作流（workflow）</h3><p>工作流是一次持续集成的过程，由多个构建任务（job）组成，一个构建任务由多个步骤（step）组成，每个步骤包含多个 action。</p><p>在博客所在目录下新建 <code>.github</code> 文件夹，在该文件夹下新建 <code>workflows</code> 文件夹，并在其中创建 <code>deployment.yml</code>，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deployment</span> <span class="comment">### workflow</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">hexo</span>] <span class="comment"># 当推送到 hexo 分支时触发 workflow</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">hexo-deployment:</span> <span class="comment">### jobs</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span>  </span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span> </span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;12.x&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span> <span class="string">&amp;</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">files</span> <span class="comment">### steps</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span> <span class="comment">### actions，这里是安装了 hexo 和主题、插件</span></span><br><span class="line">        <span class="string">node</span> <span class="string">-v</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">un</span> <span class="string">hexo-renderer-marked</span> <span class="string">--save</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">un</span> <span class="string">hexo-renderer-kramed</span> <span class="string">--sav</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">i</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">i</span> <span class="string">hexo-renderer-markdown-it</span> <span class="string">--save</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">i</span> <span class="string">hexo-theme-butterfly</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span> <span class="string">@neilsustc/markdown-it-katex</span> <span class="string">hexo-wordcount</span> <span class="string">hexo-butterfly-douban</span> <span class="string">hexo-renderer-pug</span> <span class="string">hexo-renderer-stylus</span> <span class="string">hexo-generator-search</span> <span class="string">hexo-butterfly-artitalk</span> <span class="string">hexo-abbrlink</span> <span class="string">--save</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">i</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">douban</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Github</span> <span class="string">Pages</span> <span class="comment">### 这一步是部署，填写相关信息</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">GIT_NAME:</span> <span class="string">MarioZZJ</span> </span><br><span class="line">        <span class="attr">GIT_EMAIL:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GIT_EMAIL</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">REPO:</span> <span class="string">github.com/MarioZZJ/blog-MarioZZJ</span></span><br><span class="line">        <span class="attr">GH_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        cd ./public &amp;&amp; git init &amp;&amp; git add .</span></span><br><span class="line"><span class="string">        git config --global user.name $GIT_NAME</span></span><br><span class="line"><span class="string">        git config --global user.email $GIT_EMAIL</span></span><br><span class="line"><span class="string">        git commit -m &quot;Site deployed by GitHub Actions&quot;</span></span><br><span class="line"><span class="string">        git config --global init.defaultBranch master</span></span><br><span class="line"><span class="string">        git push --force --quiet &quot;https://$GH_TOKEN@$REPO&quot; master:master</span></span><br></pre></td></tr></table></figure><p>将包含该配置文件的项目推送到远程分支，就完成了 action 的配置。这样，每次 push 到指定分支时触发该工作流，可以在 Github 项目仓库的 Action 选项卡查看具体的配置过程。</p><p><img src="https://download.mariozzj.cn/img/picgo/20210923180233.png" alt="仓库 Action 页面"></p><p><img src="https://download.mariozzj.cn/img/picgo/20210923180255.png" alt="Action 执行详情"></p><h1>想要白嫖</h1><p>无需代码开发，这可能是建一个自定义博客较为简单的方法了，其中最为关键的一步 <strong>【主题配置】</strong> ，我没有写下来详细过程，而是直接引用了原作者的教程文档，这一步其实会耗费最多的时间。如果连这一步都懒得去配置，<s>那可真是无药可救了</s>， <strong>我可以给你一个配置好的模板仓库</strong> ！只要你觉得我这个 <a href="https://blog.mariozzj.cn">博客</a> 看着还可以的话，可以把我配置好的参数直接拿去用！这里只需要修改部分插件的密钥即可，Action 也配置好了只需自行更改 Github Secrets。当然， <strong>本地别忘了安装 node 、hexo 和我用到的插件</strong> （在 package.json 中）</p><p>仓库地址：<a href="https://github.com/MarioStudio/blog-MarioZZJ">MarioStudio/blog-MarioZZJ: Personal blog of MarioZZJ. Source in hexo branch, pages in master branch. Deployed by Github Actions.</a></p><p>点击 <code>use this template</code> 即可在你的账号里面创建一个一样的仓库。</p><p>如果觉得喜欢的话，不妨给我的仓库点个 Star！感谢支持</p>]]></content>
      
      
      <categories>
          
          <category> 工具干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo.js </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/ffffffff/"/>
      <url>/posts/ffffffff/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
